(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = require('./lib/bezier');

},{"./lib/bezier":2}],2:[function(require,module,exports){
/**
  A javascript Bezier curve library by Pomax.

  Based on http://pomax.github.io/bezierinfo

  This code is MIT licensed.
**/
(function() {
  "use strict";

  // math-inlining.
  var abs = Math.abs,
      min = Math.min,
      max = Math.max,
      acos = Math.acos,
      sqrt = Math.sqrt,
      pi = Math.PI,
      // a zero coordinate, which is surprisingly useful
      ZERO = {x:0,y:0,z:0};

  // quite needed
  var utils = require('./utils.js');

  // not quite needed, but eventually this'll be useful...
  var PolyBezier = require('./poly-bezier.js');

  /**
   * Bezier curve constructor. The constructor argument can be one of three things:
   *
   * 1. array/4 of {x:..., y:..., z:...}, z optional
   * 2. numerical array/8 ordered x1,y1,x2,y2,x3,y3,x4,y4
   * 3. numerical array/12 ordered x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4
   *
   */
  var Bezier = function(coords) {
    var args = (coords && coords.forEach) ? coords : [].slice.call(arguments);
    var coordlen = false;
    if(typeof args[0] === "object") {
      coordlen = args.length;
      var newargs = [];
      args.forEach(function(point) {
        ['x','y','z'].forEach(function(d) {
          if(typeof point[d] !== "undefined") {
            newargs.push(point[d]);
          }
        });
      });
      args = newargs;
    }
    var higher = false;
    var len = args.length;
    if (coordlen) {
      if(coordlen>4) {
        if (arguments.length !== 1) {
          throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");
        }
        higher = true;
      }
    } else {
      if(len!==6 && len!==8 && len!==9 && len!==12) {
        if (arguments.length !== 1) {
          throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");
        }
      }
    }
    var _3d = (!higher && (len === 9 || len === 12)) || (coords && coords[0] && typeof coords[0].z !== "undefined");
    this._3d = _3d;
    var points = [];
    for(var idx=0, step=(_3d ? 3 : 2); idx<len; idx+=step) {
      var point = {
        x: args[idx],
        y: args[idx+1]
      };
      if(_3d) { point.z = args[idx+2] };
      points.push(point);
    }
    this.order = points.length - 1;
    this.points = points;
    var dims = ['x','y'];
    if(_3d) dims.push('z');
    this.dims = dims;
    this.dimlen = dims.length;

    (function(curve) {
      var order = curve.order;
      var points = curve.points;
      var a = utils.align(points, {p1:points[0], p2:points[order]});
      for(var i=0; i<a.length; i++) {
        if(abs(a[i].y) > 0.0001) {
          curve._linear = false;
          return;
        }
      }
      curve._linear = true;
    }(this));

    this._t1 = 0;
    this._t2 = 1;
    this.update();
  };

  Bezier.fromSVG = function(svgString) {
    var list = svgString.match(/[-+]?\d*\.?\d+(?:[eE][-+]?\d+)?/g).map(parseFloat);
    var relative = /[cq]/.test(svgString);
    if(!relative) return new Bezier(list);
    list = list.map(function(v,i) {
      return i < 2 ? v : v + list[i % 2];
    });
    return new Bezier(list);
  };

  function getABC(n,S,B,E,t) {
    if(typeof t === "undefined") { t = 0.5; }
    var u = utils.projectionratio(t,n),
        um = 1-u,
        C = {
          x: u*S.x + um*E.x,
          y: u*S.y + um*E.y
        },
        s = utils.abcratio(t,n),
        A = {
          x: B.x + (B.x-C.x)/s,
          y: B.y + (B.y-C.y)/s
        };
    return { A:A, B:B, C:C };
  }

  Bezier.quadraticFromPoints = function(p1,p2,p3, t) {
    if(typeof t === "undefined") { t = 0.5; }
    // shortcuts, although they're really dumb
    if(t===0) { return new Bezier(p2,p2,p3); }
    if(t===1) { return new Bezier(p1,p2,p2); }
    // real fitting.
    var abc = getABC(2,p1,p2,p3,t);
    return new Bezier(p1, abc.A, p3);
  };

  Bezier.cubicFromPoints = function(S,B,E, t,d1) {
    if(typeof t === "undefined") { t = 0.5; }
    var abc = getABC(3,S,B,E,t);
    if(typeof d1 === "undefined") { d1 = utils.dist(B,abc.C); }
    var d2 = d1 * (1-t)/t;

    var selen = utils.dist(S,E),
        lx = (E.x-S.x)/selen,
        ly = (E.y-S.y)/selen,
        bx1 = d1 * lx,
        by1 = d1 * ly,
        bx2 = d2 * lx,
        by2 = d2 * ly;
    // derivation of new hull coordinates
    var e1  = { x: B.x - bx1, y: B.y - by1 },
        e2  = { x: B.x + bx2, y: B.y + by2 },
        A = abc.A,
        v1  = { x: A.x + (e1.x-A.x)/(1-t), y: A.y + (e1.y-A.y)/(1-t) },
        v2  = { x: A.x + (e2.x-A.x)/(t), y: A.y + (e2.y-A.y)/(t) },
        nc1 = { x: S.x + (v1.x-S.x)/(t), y: S.y + (v1.y-S.y)/(t) },
        nc2 = { x: E.x + (v2.x-E.x)/(1-t), y: E.y + (v2.y-E.y)/(1-t) };
    // ...done
    return new Bezier(S,nc1,nc2,E);
  };

  var getUtils = function() {
    return utils;
  };

  Bezier.getUtils = getUtils;

  Bezier.prototype = {
    getUtils: getUtils,
    valueOf: function() {
      return this.toString();
    },
    toString: function() {
      return utils.pointsToString(this.points);
    },
    toSVG: function(relative) {
      if(this._3d) return false;
      var p = this.points,
          x = p[0].x,
          y = p[0].y,
          s = ["M", x, y, (this.order===2 ? "Q":"C")];
      for(var i=1, last=p.length; i<last; i++) {
        s.push(p[i].x);
        s.push(p[i].y);
      }
      return s.join(" ");
    },
    update: function() {
      // one-time compute derivative coordinates
      this.dpoints = [];
      for(var p=this.points, d=p.length, c=d-1; d>1; d--, c--) {
        var list = [];
        for(var j=0, dpt; j<c; j++) {
          dpt = {
            x: c * (p[j+1].x - p[j].x),
            y: c * (p[j+1].y - p[j].y)
          };
          if(this._3d) {
            dpt.z = c * (p[j+1].z - p[j].z);
          }
          list.push(dpt);
        }
        this.dpoints.push(list);
        p = list;
      };
      this.computedirection();
    },
    computedirection: function() {
      var points = this.points;
      var angle = utils.angle(points[0], points[this.order], points[1]);
      this.clockwise = angle > 0;
    },
    length: function() {
      return utils.length(this.derivative.bind(this));
    },
    _lut: [],
    getLUT: function(steps) {
      steps = steps || 100;
      if (this._lut.length === steps) { return this._lut; }
      this._lut = [];
      for(var t=0; t<=steps; t++) {
        this._lut.push(this.compute(t/steps));
      }
      return this._lut;
    },
    on: function(point, error) {
      error = error || 5;
      var lut = this.getLUT(), hits = [], c, t=0;
      for(var i=0; i<lut.length; i++) {
        c = lut[i];
        if (utils.dist(c,point) < error) {
          hits.push(c)
          t += i / lut.length;
        }
      }
      if(!hits.length) return false;
      return t /= hits.length;
    },
    project: function(point) {
      // step 1: coarse check
      var LUT = this.getLUT(), l = LUT.length-1,
          closest = utils.closest(LUT, point),
          mdist = closest.mdist,
          mpos = closest.mpos;
      if (mpos===0 || mpos===l) {
        var t = mpos/l, pt = this.compute(t);
        pt.t = t;
        pt.d = mdist;
        return pt;
      }

      // step 2: fine check
      var ft, t, p, d,
          t1 = (mpos-1)/l,
          t2 = (mpos+1)/l,
          step = 0.1/l;
      mdist += 1;
      for(t=t1,ft=t; t<t2+step; t+=step) {
        p = this.compute(t);
        d = utils.dist(point, p);
        if (d<mdist) {
          mdist = d;
          ft = t;
        }
      }
      p = this.compute(ft);
      p.t = ft;
      p.d = mdist;
      return p;
    },
    get: function(t) {
      return this.compute(t);
    },
    point: function(idx) {
      return this.points[idx];
    },
    compute: function(t) {
      // shortcuts
      if(t===0) { return this.points[0]; }
      if(t===1) { return this.points[this.order]; }

      var p = this.points;
      var mt = 1-t;

      // linear?
      if(this.order===1) {
        ret = {
          x: mt*p[0].x + t*p[1].x,
          y: mt*p[0].y + t*p[1].y
        };
        if (this._3d) { ret.z = mt*p[0].z + t*p[1].z; }
        return ret;
      }

      // quadratic/cubic curve?
      if(this.order<4) {
        var mt2 = mt*mt,
            t2 = t*t,
            a,b,c,d = 0;
        if(this.order===2) {
          p = [p[0], p[1], p[2], ZERO];
          a = mt2;
          b = mt*t*2;
          c = t2;
        }
        else if(this.order===3) {
          a = mt2*mt;
          b = mt2*t*3;
          c = mt*t2*3;
          d = t*t2;
        }
        var ret = {
          x: a*p[0].x + b*p[1].x + c*p[2].x + d*p[3].x,
          y: a*p[0].y + b*p[1].y + c*p[2].y + d*p[3].y
        };
        if(this._3d) {
          ret.z = a*p[0].z + b*p[1].z + c*p[2].z + d*p[3].z;
        }
        return ret;
      }

      // higher order curves: use de Casteljau's computation
      var dCpts = JSON.parse(JSON.stringify(this.points));
      while(dCpts.length > 1) {
        for (var i=0; i<dCpts.length-1; i++) {
          dCpts[i] = {
            x: dCpts[i].x + (dCpts[i+1].x - dCpts[i].x) * t,
            y: dCpts[i].y + (dCpts[i+1].y - dCpts[i].y) * t
          };
          if (typeof dCpts[i].z !== "undefined") {
            dCpts[i] = dCpts[i].z + (dCpts[i+1].z - dCpts[i].z) * t
          }
        }
        dCpts.splice(dCpts.length-1, 1);
      }
      return dCpts[0];
    },
    raise: function() {
      var p = this.points, np = [p[0]], i, k=p.length, pi, pim;
      for (var i=1; i<k; i++) {
        pi = p[i];
        pim = p[i-1];
        np[i] = {
          x: (k-i)/k * pi.x + i/k * pim.x,
          y: (k-i)/k * pi.y + i/k * pim.y
        };
      }
      np[k] = p[k-1];
      return new Bezier(np);
    },
    derivative: function(t) {
      var mt = 1-t,
          a,b,c=0,
          p = this.dpoints[0];
      if(this.order===2) { p = [p[0], p[1], ZERO]; a = mt; b = t; }
      if(this.order===3) { a = mt*mt; b = mt*t*2; c = t*t; }
      var ret = {
        x: a*p[0].x + b*p[1].x + c*p[2].x,
        y: a*p[0].y + b*p[1].y + c*p[2].y
      };
      if(this._3d) {
        ret.z = a*p[0].z + b*p[1].z + c*p[2].z;
      }
      return ret;
    },
    inflections: function() {
      return utils.inflections(this.points);
    },
    normal: function(t) {
      return this._3d ? this.__normal3(t) : this.__normal2(t);
    },
    __normal2: function(t) {
      var d = this.derivative(t);
      var q = sqrt(d.x*d.x + d.y*d.y)
      return { x: -d.y/q, y: d.x/q };
    },
    __normal3: function(t) {
      // see http://stackoverflow.com/questions/25453159
      var r1 = this.derivative(t),
          r2 = this.derivative(t+0.01),
          q1 = sqrt(r1.x*r1.x + r1.y*r1.y + r1.z*r1.z),
          q2 = sqrt(r2.x*r2.x + r2.y*r2.y + r2.z*r2.z);
      r1.x /= q1; r1.y /= q1; r1.z /= q1;
      r2.x /= q2; r2.y /= q2; r2.z /= q2;
      // cross product
      var c = {
        x: r2.y*r1.z - r2.z*r1.y,
        y: r2.z*r1.x - r2.x*r1.z,
        z: r2.x*r1.y - r2.y*r1.x
      };
      var m = sqrt(c.x*c.x + c.y*c.y + c.z*c.z);
      c.x /= m; c.y /= m; c.z /= m;
      // rotation matrix
      var R = [   c.x*c.x,   c.x*c.y-c.z, c.x*c.z+c.y,
                c.x*c.y+c.z,   c.y*c.y,   c.y*c.z-c.x,
                c.x*c.z-c.y, c.y*c.z+c.x,   c.z*c.z    ];
      // normal vector:
      var n = {
        x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,
        y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,
        z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z
      };
      return n;
    },
    hull: function(t) {
      var p = this.points,
          _p = [],
          pt,
          q = [],
          idx = 0,
          i=0,
          l=0;
      q[idx++] = p[0];
      q[idx++] = p[1];
      q[idx++] = p[2];
      if(this.order === 3) { q[idx++] = p[3]; }
      // we lerp between all points at each iteration, until we have 1 point left.
      while(p.length>1) {
        _p = [];
        for(i=0, l=p.length-1; i<l; i++) {
          pt = utils.lerp(t,p[i],p[i+1]);
          q[idx++] = pt;
          _p.push(pt);
        }
        p = _p;
      }
      return q;
    },
    split: function(t1, t2) {
      // shortcuts
      if(t1===0 && !!t2) { return this.split(t2).left; }
      if(t2===1) { return this.split(t1).right; }

      // no shortcut: use "de Casteljau" iteration.
      var q = this.hull(t1);
      var result = {
        left: this.order === 2 ? new Bezier([q[0],q[3],q[5]]) : new Bezier([q[0],q[4],q[7],q[9]]),
        right: this.order === 2 ? new Bezier([q[5],q[4],q[2]]) : new Bezier([q[9],q[8],q[6],q[3]]),
        span: q
      };

      // make sure we bind _t1/_t2 information!
      result.left._t1  = utils.map(0,  0,1, this._t1,this._t2);
      result.left._t2  = utils.map(t1, 0,1, this._t1,this._t2);
      result.right._t1 = utils.map(t1, 0,1, this._t1,this._t2);
      result.right._t2 = utils.map(1,  0,1, this._t1,this._t2);

      // if we have no t2, we're done
      if(!t2) { return result; }

      // if we have a t2, split again:
      t2 = utils.map(t2,t1,1,0,1);
      var subsplit = result.right.split(t2);
      return subsplit.left;
    },
    extrema: function() {
      var dims = this.dims,
          result={},
          roots=[],
          p, mfn;
      dims.forEach(function(dim) {
        mfn = function(v) { return v[dim]; };
        p = this.dpoints[0].map(mfn);
        result[dim] = utils.droots(p);
        if(this.order === 3) {
          p = this.dpoints[1].map(mfn);
          result[dim] = result[dim].concat(utils.droots(p));
        }
        result[dim] = result[dim].filter(function(t) { return (t>=0 && t<=1); });
        roots = roots.concat(result[dim].sort());
      }.bind(this));
      roots = roots.sort().filter(function(v,idx) { return (roots.indexOf(v) === idx); });
      result.values = roots;
      return result;
    },
    bbox: function() {
      var extrema = this.extrema(), result = {};
      this.dims.forEach(function(d) {
        result[d] = utils.getminmax(this, d, extrema[d]);
      }.bind(this));
      return result;
    },
    overlaps: function(curve) {
      var lbbox = this.bbox(),
          tbbox = curve.bbox();
      return utils.bboxoverlap(lbbox,tbbox);
    },
    offset: function(t, d) {
      if(typeof d !== "undefined") {
        var c = this.get(t);
        var n = this.normal(t);
        var ret = {
          c: c,
          n: n,
          x: c.x + n.x * d,
          y: c.y + n.y * d
        };
        if(this._3d) {
          ret.z = c.z + n.z * d;
        };
        return ret;
      }
      if(this._linear) {
        var nv = this.normal(0);
        var coords = this.points.map(function(p) {
          var ret = {
            x: p.x + t * nv.x,
            y: p.y + t * nv.y
          };
          if(p.z && n.z) { ret.z = p.z + t * nv.z; }
          return ret;
        });
        return [new Bezier(coords)];
      }
      var reduced = this.reduce();
      return reduced.map(function(s) {
        return s.scale(t);
      });
    },
    simple: function() {
      if(this.order===3) {
        var a1 = utils.angle(this.points[0], this.points[3], this.points[1]);
        var a2 = utils.angle(this.points[0], this.points[3], this.points[2]);
        if(a1>0 && a2<0 || a1<0 && a2>0) return false;
      }
      var n1 = this.normal(0);
      var n2 = this.normal(1);
      var s = n1.x*n2.x + n1.y*n2.y;
      if(this._3d) { s += n1.z*n2.z; }
      var angle = abs(acos(s));
      return angle < pi/3;
    },
    reduce: function() {
      var i, t1=0, t2=0, step=0.01, segment, pass1=[], pass2=[];
      // first pass: split on extrema
      var extrema = this.extrema().values;
      if(extrema.indexOf(0)===-1) { extrema = [0].concat(extrema); }
      if(extrema.indexOf(1)===-1) { extrema.push(1); }

      for(t1=extrema[0], i=1; i<extrema.length; i++) {
        t2 = extrema[i];
        segment = this.split(t1,t2);
        segment._t1 = t1;
        segment._t2 = t2;
        pass1.push(segment);
        t1 = t2;
      }

      // second pass: further reduce these segments to simple segments
      pass1.forEach(function(p1) {
        t1=0;
        t2=0;
        while(t2 <= 1) {
          for(t2=t1+step; t2<=1+step; t2+=step) {
            segment = p1.split(t1,t2);
            if(!segment.simple()) {
              t2 -= step;
              if(abs(t1-t2)<step) {
                // we can never form a reduction
                return [];
              }
              segment = p1.split(t1,t2);
              segment._t1 = utils.map(t1,0,1,p1._t1,p1._t2);
              segment._t2 = utils.map(t2,0,1,p1._t1,p1._t2);
              pass2.push(segment);
              t1 = t2;
              break;
            }
          }
        }
        if(t1<1) {
          segment = p1.split(t1,1);
          segment._t1 = utils.map(t1,0,1,p1._t1,p1._t2);
          segment._t2 = p1._t2;
          pass2.push(segment);
        }
      });
      return pass2;
    },
    scale: function(d) {
      var order = this.order;
      var distanceFn = false
      if(typeof d === "function") { distanceFn = d; }
      if(distanceFn && order === 2) { return this.raise().scale(distanceFn); }

      // TODO: add special handling for degenerate (=linear) curves.
      var clockwise = this.clockwise;
      var r1 = distanceFn ? distanceFn(0) : d;
      var r2 = distanceFn ? distanceFn(1) : d;
      var v = [ this.offset(0,10), this.offset(1,10) ];
      var o = utils.lli4(v[0], v[0].c, v[1], v[1].c);
      if(!o) { throw new Error("cannot scale this curve. Try reducing it first."); }
      // move all points by distance 'd' wrt the origin 'o'
      var points=this.points, np=[];

      // move end points by fixed distance along normal.
      [0,1].forEach(function(t) {
        var p = np[t*order] = utils.copy(points[t*order]);
        p.x += (t?r2:r1) * v[t].n.x;
        p.y += (t?r2:r1) * v[t].n.y;
      }.bind(this));

      if (!distanceFn) {
        // move control points to lie on the intersection of the offset
        // derivative vector, and the origin-through-control vector
        [0,1].forEach(function(t) {
          if(this.order===2 && !!t) return;
          var p = np[t*order];
          var d = this.derivative(t);
          var p2 = { x: p.x + d.x, y: p.y + d.y };
          np[t+1] = utils.lli4(p, p2, o, points[t+1]);
        }.bind(this));
        return new Bezier(np);
      }

      // move control points by "however much necessary to
      // ensure the correct tangent to endpoint".
      [0,1].forEach(function(t) {
        if(this.order===2 && !!t) return;
        var p = points[t+1];
        var ov = {
          x: p.x - o.x,
          y: p.y - o.y
        };
        var rc = distanceFn ? distanceFn((t+1)/order) : d;
        if(distanceFn && !clockwise) rc = -rc;
        var m = sqrt(ov.x*ov.x + ov.y*ov.y);
        ov.x /= m;
        ov.y /= m;
        np[t+1] = {
          x: p.x + rc*ov.x,
          y: p.y + rc*ov.y
        }
      }.bind(this));
      return new Bezier(np);
    },
    outline: function(d1, d2, d3, d4) {
      d2 = (typeof d2 === "undefined") ? d1 : d2;
      var reduced = this.reduce(),
          len = reduced.length,
          fcurves = [],
          bcurves = [],
          p,
          alen = 0,
          tlen = this.length();

      var graduated = (typeof d3 !== "undefined" && typeof d4 !== "undefined");

      function linearDistanceFunction(s,e, tlen,alen,slen) {
        return function (v) {
          var f1 = alen/tlen, f2 = (alen+slen)/tlen, d = e-s;
          return utils.map(v, 0,1, s+f1*d, s+f2*d);
        };
      };

      // form curve oulines
      reduced.forEach(function(segment) {
        slen = segment.length();
        if (graduated) {
          fcurves.push(segment.scale(  linearDistanceFunction( d1, d3, tlen,alen,slen)  ));
          bcurves.push(segment.scale(  linearDistanceFunction(-d2,-d4, tlen,alen,slen)  ));
        } else {
          fcurves.push(segment.scale( d1));
          bcurves.push(segment.scale(-d2));
        }
        alen += slen;
      });

      // reverse the "return" outline
      bcurves = bcurves.map(function(s) {
        p = s.points;
        if(p[3]) { s.points = [p[3],p[2],p[1],p[0]]; }
        else { s.points = [p[2],p[1],p[0]]; }
        return s;
      }).reverse();

      // form the endcaps as lines
      var fs = fcurves[0].points[0],
          fe = fcurves[len-1].points[fcurves[len-1].points.length-1],
          bs = bcurves[len-1].points[bcurves[len-1].points.length-1],
          be = bcurves[0].points[0],
          ls = utils.makeline(bs,fs),
          le = utils.makeline(fe,be),
          segments = [ls].concat(fcurves).concat([le]).concat(bcurves),
          slen = segments.length;

      return new PolyBezier(segments);
    },
    outlineshapes: function(d1, d2, curveIntersectionThreshold) {
      d2 = d2 || d1;
      var outline = this.outline(d1,d2).curves;
      var shapes = [];
      for(var i=1, len=outline.length; i < len/2; i++) {
        var shape = utils.makeshape(outline[i], outline[len-i], curveIntersectionThreshold);
        shape.startcap.virtual = (i > 1);
        shape.endcap.virtual = (i < len/2-1);
        shapes.push(shape);
      }
      return shapes;
    },
    intersects: function(curve, curveIntersectionThreshold) {
      if(!curve) return this.selfintersects(curveIntersectionThreshold);
      if(curve.p1 && curve.p2) {
        return this.lineIntersects(curve);
      }
      if(curve instanceof Bezier) { curve = curve.reduce(); }
      return this.curveintersects(this.reduce(), curve, curveIntersectionThreshold);
    },
    lineIntersects: function(line) {
      var mx = min(line.p1.x, line.p2.x),
          my = min(line.p1.y, line.p2.y),
          MX = max(line.p1.x, line.p2.x),
          MY = max(line.p1.y, line.p2.y),
          self=this;
      return utils.roots(this.points, line).filter(function(t) {
        var p = self.get(t);
        return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);
      });
    },
    selfintersects: function(curveIntersectionThreshold) {
      var reduced = this.reduce();
      // "simple" curves cannot intersect with their direct
      // neighbour, so for each segment X we check whether
      // it intersects [0:x-2][x+2:last].
      var i,len=reduced.length-2,results=[],result,left,right;
      for(i=0; i<len; i++) {
        left = reduced.slice(i,i+1);
        right = reduced.slice(i+2);
        result = this.curveintersects(left, right, curveIntersectionThreshold);
        results = results.concat( result );
      }
      return results;
    },
    curveintersects: function(c1, c2, curveIntersectionThreshold) {
      var pairs = [];
      // step 1: pair off any overlapping segments
      c1.forEach(function(l) {
        c2.forEach(function(r) {
          if(l.overlaps(r)) {
            pairs.push({ left: l, right: r });
          }
        });
      });
      // step 2: for each pairing, run through the convergence algorithm.
      var intersections = [];
      pairs.forEach(function(pair) {
        var result = utils.pairiteration(pair.left, pair.right, curveIntersectionThreshold);
        if(result.length > 0) {
          intersections = intersections.concat(result);
        }
      });
      return intersections;
    },
    arcs: function(errorThreshold) {
      errorThreshold = errorThreshold || 0.5;
      var circles = [];
      return this._iterate(errorThreshold, circles);
    },
    _error: function(pc, np1, s, e) {
      var q = (e - s) / 4,
          c1 = this.get(s + q),
          c2 = this.get(e - q),
          ref = utils.dist(pc, np1),
          d1  = utils.dist(pc, c1),
          d2  = utils.dist(pc, c2);
      return abs(d1-ref) + abs(d2-ref);
    },
    _iterate: function(errorThreshold, circles) {
      var s = 0, e = 1, safety;
      // we do a binary search to find the "good `t` closest to no-longer-good"
      do {
        safety=0;

        // step 1: start with the maximum possible arc
        e = 1;

        // points:
        var np1 = this.get(s), np2, np3, arc, prev_arc;

        // booleans:
        var curr_good = false, prev_good = false, done;

        // numbers:
        var m = e, prev_e = 1, step = 0;

        // step 2: find the best possible arc
        do {
          prev_good = curr_good;
          prev_arc = arc;
          m = (s + e)/2;
          step++;

          np2 = this.get(m);
          np3 = this.get(e);

          arc = utils.getccenter(np1, np2, np3);
          
          //also save the t values
          arc.interval = {
            start: s,
            end: e
          };

          var error = this._error(arc, np1, s, e);
          curr_good = (error <= errorThreshold);

          done = prev_good && !curr_good;
          if(!done) prev_e = e;

          // this arc is fine: we can move 'e' up to see if we can find a wider arc
          if(curr_good) {
            // if e is already at max, then we're done for this arc.
            if (e >= 1) {
              prev_e = 1;
              prev_arc = arc;
              break;
            }
            // if not, move it up by half the iteration distance
            e = e + (e-s)/2;
          }

          // this is a bad arc: we need to move 'e' down to find a good arc
          else {
            e = m;
          }
        }
        while(!done && safety++<100);

        if(safety>=100) {
          console.error("arc abstraction somehow failed...");
          break;
        }

        // console.log("[F] arc found", s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);

        prev_arc = (prev_arc ? prev_arc : arc);
        circles.push(prev_arc);
        s = prev_e;
      }
      while(e < 1);
      return circles;
    }
  };

  module.exports = Bezier;

}());

},{"./poly-bezier.js":3,"./utils.js":4}],3:[function(require,module,exports){
(function() {
  "use strict";

  var utils = require('./utils.js');

  /**
   * Poly Bezier
   * @param {[type]} curves [description]
   */
  var PolyBezier = function(curves) {
    this.curves = [];
    this._3d = false;
    if(!!curves) {
      this.curves = curves;
      this._3d = this.curves[0]._3d;
    }
  }

  PolyBezier.prototype = {
    valueOf: function() {
      return this.toString();
    },
    toString: function() {
      return "[" + this.curves.map(function(curve) {
        return utils.pointsToString(curve.points);
      }).join(", ") + "]";
    },
    addCurve: function(curve) {
      this.curves.push(curve);
      this._3d = this._3d || curve._3d;
    },
    length: function() {
      return this.curves.map(function(v) { return v.length(); }).reduce(function(a,b) { return a+b; });
    },
    curve: function(idx) {
      return this.curves[idx];
    },
    bbox: function() {
      var c = this.curves;
      var bbox = c[0].bbox();
      for(var i=1; i<c.length; i++) {
        utils.expandbox(bbox, c[i].bbox());
      }
      return bbox;
    },
    offset: function(d) {
      var offset = [];
      this.curves.forEach(function(v) {
        offset = offset.concat(v.offset(d));
      });
      return new PolyBezier(offset);
    }
  };

  module.exports = PolyBezier;
}());

},{"./utils.js":4}],4:[function(require,module,exports){
(function() {
  "use strict";

  // math-inlining.
  var abs = Math.abs,
      cos = Math.cos,
      sin = Math.sin,
      acos = Math.acos,
      atan2 = Math.atan2,
      sqrt = Math.sqrt,
      pow = Math.pow,
      // cube root function yielding real roots
      crt = function(v) { return (v<0) ? -pow(-v,1/3) : pow(v,1/3); },
      // trig constants
      pi = Math.PI,
      tau = 2*pi,
      quart = pi/2,
      // float precision significant decimal
      epsilon = 0.000001,
      // extremas used in bbox calculation and similar algorithms
      nMax = Number.MAX_SAFE_INTEGER,
      nMin = Number.MIN_SAFE_INTEGER;

  // Bezier utility functions
  var utils = {
    // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
    Tvalues: [
      -0.0640568928626056260850430826247450385909,
       0.0640568928626056260850430826247450385909,
      -0.1911188674736163091586398207570696318404,
       0.1911188674736163091586398207570696318404,
      -0.3150426796961633743867932913198102407864,
       0.3150426796961633743867932913198102407864,
      -0.4337935076260451384870842319133497124524,
       0.4337935076260451384870842319133497124524,
      -0.5454214713888395356583756172183723700107,
       0.5454214713888395356583756172183723700107,
      -0.6480936519369755692524957869107476266696,
       0.6480936519369755692524957869107476266696,
      -0.7401241915785543642438281030999784255232,
       0.7401241915785543642438281030999784255232,
      -0.8200019859739029219539498726697452080761,
       0.8200019859739029219539498726697452080761,
      -0.8864155270044010342131543419821967550873,
       0.8864155270044010342131543419821967550873,
      -0.9382745520027327585236490017087214496548,
       0.9382745520027327585236490017087214496548,
      -0.9747285559713094981983919930081690617411,
       0.9747285559713094981983919930081690617411,
      -0.9951872199970213601799974097007368118745,
       0.9951872199970213601799974097007368118745
    ],

    // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
    Cvalues: [
      0.1279381953467521569740561652246953718517,
      0.1279381953467521569740561652246953718517,
      0.1258374563468282961213753825111836887264,
      0.1258374563468282961213753825111836887264,
      0.1216704729278033912044631534762624256070,
      0.1216704729278033912044631534762624256070,
      0.1155056680537256013533444839067835598622,
      0.1155056680537256013533444839067835598622,
      0.1074442701159656347825773424466062227946,
      0.1074442701159656347825773424466062227946,
      0.0976186521041138882698806644642471544279,
      0.0976186521041138882698806644642471544279,
      0.0861901615319532759171852029837426671850,
      0.0861901615319532759171852029837426671850,
      0.0733464814110803057340336152531165181193,
      0.0733464814110803057340336152531165181193,
      0.0592985849154367807463677585001085845412,
      0.0592985849154367807463677585001085845412,
      0.0442774388174198061686027482113382288593,
      0.0442774388174198061686027482113382288593,
      0.0285313886289336631813078159518782864491,
      0.0285313886289336631813078159518782864491,
      0.0123412297999871995468056670700372915759,
      0.0123412297999871995468056670700372915759
    ],

    arcfn: function(t, derivativeFn) {
      var d = derivativeFn(t);
      var l = d.x*d.x + d.y*d.y;
      if(typeof d.z !== "undefined") {
        l += d.z*d.z;
      }
      return sqrt(l);
    },

    between: function(v, m, M) {
      return (m <= v && v <= M) || utils.approximately(v, m) || utils.approximately(v, M);
    },

    approximately: function(a,b,precision) {
      return abs(a-b) <= (precision || epsilon);
    },

    length: function(derivativeFn) {
      var z=0.5,sum=0,len=utils.Tvalues.length,i,t;
      for(i=0; i<len; i++) {
        t = z * utils.Tvalues[i] + z;
        sum += utils.Cvalues[i] * utils.arcfn(t,derivativeFn);
      }
      return z * sum;
    },

    map: function(v, ds,de, ts,te) {
      var d1 = de-ds, d2 = te-ts, v2 =  v-ds, r = v2/d1;
      return ts + d2*r;
    },

    lerp: function(r, v1, v2) {
      var ret = {
        x: v1.x + r*(v2.x-v1.x),
        y: v1.y + r*(v2.y-v1.y)
      };
      if(!!v1.z && !!v2.z) {
        ret.z =  v1.z + r*(v2.z-v1.z);
      }
      return ret;
    },

    pointToString: function(p) {
      var s = p.x+"/"+p.y;
      if(typeof p.z !== "undefined") {
        s += "/"+p.z;
      }
      return s;
    },

    pointsToString: function(points) {
      return "[" + points.map(utils.pointToString).join(", ") + "]";
    },

    copy: function(obj) {
      return JSON.parse(JSON.stringify(obj));
    },

    angle: function(o,v1,v2) {
      var dx1 = v1.x - o.x,
          dy1 = v1.y - o.y,
          dx2 = v2.x - o.x,
          dy2 = v2.y - o.y,
          cross = dx1*dy2 - dy1*dx2,
          dot = dx1*dx2 + dy1*dy2;
      return atan2(cross, dot);
    },

    // round as string, to avoid rounding errors
    round: function(v, d) {
      var s = '' + v;
      var pos = s.indexOf(".");
      return parseFloat(s.substring(0,pos+1+d));
    },

    dist: function(p1, p2) {
      var dx = p1.x - p2.x,
          dy = p1.y - p2.y;
      return sqrt(dx*dx+dy*dy);
    },

    closest: function(LUT, point) {
      var mdist = pow(2,63), mpos, d;
      LUT.forEach(function(p, idx) {
        d = utils.dist(point, p);
        if (d<mdist) {
          mdist = d;
          mpos = idx;
        }
      });
      return { mdist:mdist, mpos:mpos };
    },

    abcratio: function(t, n) {
      // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc
      if (n!==2 && n!==3) {
        return false;
      }
      if (typeof t === "undefined") {
        t = 0.5;
      } else if (t===0 || t===1) {
        return t;
      }
      var bottom = pow(t,n) + pow(1-t,n), top = bottom - 1;
      return abs(top/bottom);
    },

    projectionratio: function(t, n) {
      // see u(t) note on http://pomax.github.io/bezierinfo/#abc
      if (n!==2 && n!==3) {
        return false;
      }
      if (typeof t === "undefined") {
        t = 0.5;
      } else if (t===0 || t===1) {
        return t;
      }
      var top = pow(1-t, n), bottom = pow(t,n) + top;
      return top/bottom;
    },

    lli8: function(x1,y1,x2,y2,x3,y3,x4,y4) {
      var nx=(x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4),
          ny=(x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4),
          d=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);
      if(d==0) { return false; }
      return { x: nx/d, y: ny/d };
    },

    lli4: function(p1,p2,p3,p4) {
      var x1 = p1.x, y1 = p1.y,
          x2 = p2.x, y2 = p2.y,
          x3 = p3.x, y3 = p3.y,
          x4 = p4.x, y4 = p4.y;
      return utils.lli8(x1,y1,x2,y2,x3,y3,x4,y4);
    },

    lli: function(v1, v2) {
      return utils.lli4(v1,v1.c,v2,v2.c);
    },

    makeline: function(p1,p2) {
      var Bezier = require('./bezier');
      var x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y, dx = (x2-x1)/3, dy = (y2-y1)/3;
      return new Bezier(x1, y1, x1+dx, y1+dy, x1+2*dx, y1+2*dy, x2, y2);
    },

    findbbox: function(sections) {
      var mx=nMax,my=nMax,MX=nMin,MY=nMin;
      sections.forEach(function(s) {
        var bbox = s.bbox();
        if(mx > bbox.x.min) mx = bbox.x.min;
        if(my > bbox.y.min) my = bbox.y.min;
        if(MX < bbox.x.max) MX = bbox.x.max;
        if(MY < bbox.y.max) MY = bbox.y.max;
      });
      return {
        x: { min: mx, mid:(mx+MX)/2, max: MX, size:MX-mx },
        y: { min: my, mid:(my+MY)/2, max: MY, size:MY-my }
      }
    },

    shapeintersections: function(s1, bbox1, s2, bbox2, curveIntersectionThreshold) {
      if(!utils.bboxoverlap(bbox1, bbox2)) return [];
      var intersections = [];
      var a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];
      var a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];
      a1.forEach(function(l1) {
        if(l1.virtual) return;
        a2.forEach(function(l2) {
          if(l2.virtual) return;
          var iss = l1.intersects(l2, curveIntersectionThreshold);
          if(iss.length>0) {
            iss.c1 = l1;
            iss.c2 = l2;
            iss.s1 = s1;
            iss.s2 = s2;
            intersections.push(iss);
          }
        });
      });
      return intersections;
    },

    makeshape: function(forward, back, curveIntersectionThreshold) {
      var bpl = back.points.length;
      var fpl = forward.points.length;
      var start  = utils.makeline(back.points[bpl-1], forward.points[0]);
      var end    = utils.makeline(forward.points[fpl-1], back.points[0]);
      var shape  = {
        startcap: start,
        forward: forward,
        back: back,
        endcap: end,
        bbox: utils.findbbox([start, forward, back, end])
      };
      var self = utils;
      shape.intersections = function(s2) {
        return self.shapeintersections(shape,shape.bbox,s2,s2.bbox, curveIntersectionThreshold);
      };
      return shape;
    },

    getminmax: function(curve, d, list) {
      if(!list) return { min:0, max:0 };
      var min=nMax, max=nMin,t,c;
      if(list.indexOf(0)===-1) { list = [0].concat(list); }
      if(list.indexOf(1)===-1) { list.push(1); }
      for(var i=0,len=list.length; i<len; i++) {
        t = list[i];
        c = curve.get(t);
        if(c[d] < min) { min = c[d]; }
        if(c[d] > max) { max = c[d]; }
      }
      return { min:min, mid:(min+max)/2, max:max, size:max-min };
    },

    align: function(points, line) {
      var tx = line.p1.x,
          ty = line.p1.y,
          a = -atan2(line.p2.y-ty, line.p2.x-tx),
          d = function(v) {
            return {
              x: (v.x-tx)*cos(a) - (v.y-ty)*sin(a),
              y: (v.x-tx)*sin(a) + (v.y-ty)*cos(a)
            };
          };
      return points.map(d);
    },

    roots: function(points, line) {
      line = line || {p1:{x:0,y:0},p2:{x:1,y:0}};
      var order = points.length - 1;
      var p = utils.align(points, line);
      var reduce = function(t) { return 0<=t && t <=1; };

      if (order === 2) {
        var a = p[0].y,
            b = p[1].y,
            c = p[2].y,
            d = a - 2*b + c;
        if(d!==0) {
          var m1 = -sqrt(b*b-a*c),
              m2 = -a+b,
              v1 = -( m1+m2)/d,
              v2 = -(-m1+m2)/d;
          return [v1, v2].filter(reduce);
        }
        else if(b!==c && d===0) {
          return [ (2*b-c)/2*(b-c) ].filter(reduce);
        }
        return [];
      }

      // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm
      var pa = p[0].y,
          pb = p[1].y,
          pc = p[2].y,
          pd = p[3].y,
          d = (-pa + 3*pb - 3*pc + pd),
          a = (3*pa - 6*pb + 3*pc) / d,
          b = (-3*pa + 3*pb) / d,
          c = pa / d,
          p = (3*b - a*a)/3,
          p3 = p/3,
          q = (2*a*a*a - 9*a*b + 27*c)/27,
          q2 = q/2,
          discriminant = q2*q2 + p3*p3*p3,
          u1,v1,x1,x2,x3;
       if (discriminant < 0) {
        var mp3 = -p/3,
            mp33 = mp3*mp3*mp3,
            r = sqrt( mp33 ),
            t = -q/(2*r),
            cosphi = t<-1 ? -1 : t>1 ? 1 : t,
            phi = acos(cosphi),
            crtr = crt(r),
            t1 = 2*crtr;
        x1 = t1 * cos(phi/3) - a/3;
        x2 = t1 * cos((phi+tau)/3) - a/3;
        x3 = t1 * cos((phi+2*tau)/3) - a/3;
        return [x1, x2, x3].filter(reduce);
      } else if(discriminant === 0) {
        u1 = q2 < 0 ? crt(-q2) : -crt(q2);
        x1 = 2*u1-a/3;
        x2 = -u1 - a/3;
        return [x1,x2].filter(reduce);
      } else {
        var sd = sqrt(discriminant);
        u1 = crt(-q2+sd);
        v1 = crt(q2+sd);
        return [u1-v1-a/3].filter(reduce);;
      }
    },

    droots: function(p) {
      // quadratic roots are easy
      if(p.length === 3) {
        var a = p[0],
            b = p[1],
            c = p[2],
            d = a - 2*b + c;
        if(d!==0) {
          var m1 = -sqrt(b*b-a*c),
              m2 = -a+b,
              v1 = -( m1+m2)/d,
              v2 = -(-m1+m2)/d;
          return [v1, v2];
        }
        else if(b!==c && d===0) {
          return [(2*b-c)/(2*(b-c))];
        }
        return [];
      }

      // linear roots are even easier
      if(p.length === 2) {
        var a = p[0], b = p[1];
        if(a!==b) {
          return [a/(a-b)];
        }
        return [];
      }
    },

    inflections: function(points) {
      if (points.length<4) return [];

      // FIXME: TODO: add in inflection abstraction for quartic+ curves?

      var p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }),
          a = p[2].x * p[1].y,
          b = p[3].x * p[1].y,
          c = p[1].x * p[2].y,
          d = p[3].x * p[2].y,
          v1 = 18 * (-3*a + 2*b + 3*c - d),
          v2 = 18 * (3*a - b - 3*c),
          v3 = 18 * (c - a);

      if (utils.approximately(v1,0)){
        if(!utils.approximately(v2,0)){
          var t = -v3/v2;
          if (0 <= t && t <= 1)
             return [t];
        }
        return [];
      }

      var trm = v2*v2 - 4*v1*v3,
          sq = Math.sqrt(trm),
          d = 2 * v1;

      if (utils.approximately(d,0)) return [];

      return [(sq-v2)/d, -(v2+sq)/d].filter(function(r) {
        return (0 <= r && r <= 1);
      });
    },

    bboxoverlap: function(b1,b2) {
      var dims=['x','y'],len=dims.length,i,dim,l,t,d
      for(i=0; i<len; i++) {
        dim = dims[i];
        l = b1[dim].mid;
        t = b2[dim].mid;
        d = (b1[dim].size + b2[dim].size)/2;
        if(abs(l-t) >= d) return false;
      }
      return true;
    },

    expandbox: function(bbox, _bbox) {
      if(_bbox.x.min < bbox.x.min) { bbox.x.min = _bbox.x.min; }
      if(_bbox.y.min < bbox.y.min) { bbox.y.min = _bbox.y.min; }
      if(_bbox.z && _bbox.z.min < bbox.z.min) { bbox.z.min = _bbox.z.min; }
      if(_bbox.x.max > bbox.x.max) { bbox.x.max = _bbox.x.max; }
      if(_bbox.y.max > bbox.y.max) { bbox.y.max = _bbox.y.max; }
      if(_bbox.z && _bbox.z.max > bbox.z.max) { bbox.z.max = _bbox.z.max; }
      bbox.x.mid = (bbox.x.min + bbox.x.max)/2;
      bbox.y.mid = (bbox.y.min + bbox.y.max)/2;
      if(bbox.z) { bbox.z.mid = (bbox.z.min + bbox.z.max)/2; }
      bbox.x.size = bbox.x.max - bbox.x.min;
      bbox.y.size = bbox.y.max - bbox.y.min;
      if(bbox.z) { bbox.z.size = bbox.z.max - bbox.z.min; }
    },

    pairiteration: function(c1, c2, curveIntersectionThreshold) {
      var c1b = c1.bbox(),
          c2b = c2.bbox(),
          r = 100000,
          threshold = curveIntersectionThreshold || 0.5;
      if(c1b.x.size + c1b.y.size < threshold && c2b.x.size + c2b.y.size < threshold) {
        return [ ((r * (c1._t1+c1._t2)/2)|0)/r + "/" + ((r * (c2._t1+c2._t2)/2)|0)/r ];
      }
      var cc1 = c1.split(0.5),
          cc2 = c2.split(0.5),
          pairs = [
            {left: cc1.left, right: cc2.left },
            {left: cc1.left, right: cc2.right },
            {left: cc1.right, right: cc2.right },
            {left: cc1.right, right: cc2.left }];
      pairs = pairs.filter(function(pair) {
        return utils.bboxoverlap(pair.left.bbox(),pair.right.bbox());
      });
      var results = [];
      if(pairs.length === 0) return results;
      pairs.forEach(function(pair) {
        results = results.concat(
          utils.pairiteration(pair.left, pair.right, threshold)
        );
      })
      results = results.filter(function(v,i) {
        return results.indexOf(v) === i;
      });
      return results;
    },

    getccenter: function(p1,p2,p3) {
      var dx1 = (p2.x - p1.x),
          dy1 = (p2.y - p1.y),
          dx2 = (p3.x - p2.x),
          dy2 = (p3.y - p2.y);
      var dx1p = dx1 * cos(quart) - dy1 * sin(quart),
          dy1p = dx1 * sin(quart) + dy1 * cos(quart),
          dx2p = dx2 * cos(quart) - dy2 * sin(quart),
          dy2p = dx2 * sin(quart) + dy2 * cos(quart);
      // chord midpoints
      var mx1 = (p1.x + p2.x)/2,
          my1 = (p1.y + p2.y)/2,
          mx2 = (p2.x + p3.x)/2,
          my2 = (p2.y + p3.y)/2;
      // midpoint offsets
      var mx1n = mx1 + dx1p,
          my1n = my1 + dy1p,
          mx2n = mx2 + dx2p,
          my2n = my2 + dy2p;
      // intersection of these lines:
      var arc = utils.lli8(mx1,my1,mx1n,my1n, mx2,my2,mx2n,my2n),
          r = utils.dist(arc,p1),
          // arc start/end values, over mid point:
          s = atan2(p1.y - arc.y, p1.x - arc.x),
          m = atan2(p2.y - arc.y, p2.x - arc.x),
          e = atan2(p3.y - arc.y, p3.x - arc.x),
          _;
      // determine arc direction (cw/ccw correction)
      if (s<e) {
        // if s<m<e, arc(s, e)
        // if m<s<e, arc(e, s + tau)
        // if s<e<m, arc(e, s + tau)
        if (s>m || m>e) { s += tau; }
        if (s>e) { _=e; e=s; s=_; }
      } else {
        // if e<m<s, arc(e, s)
        // if m<e<s, arc(s, e + tau)
        // if e<s<m, arc(s, e + tau)
        if (e<m && m<s) { _=e; e=s; s=_; } else { e += tau; }
      }
      // assign and done.
      arc.s = s;
      arc.e = e;
      arc.r = r;
      return arc;
    }
  };

  module.exports = utils;
}());

},{"./bezier":2}],5:[function(require,module,exports){
// ==ClosureCompiler==
// @output_file_name fit-curve.min.js
// @compilation_level SIMPLE_OPTIMIZATIONS
// ==/ClosureCompiler==

/**
 *  @preserve  JavaScript implementation of
 *  Algorithm for Automatically Fitting Digitized Curves
 *  by Philip J. Schneider
 *  "Graphics Gems", Academic Press, 1990
 *
 *  The MIT License (MIT)
 *
 *  https://github.com/soswow/fit-curves
 */

/**
 * Fit one or more Bezier curves to a set of points.
 *
 * @param {Array<Array<Number>>} points - Array of digitized points, e.g. [[5,5],[5,50],[110,140],[210,160],[320,110]]
 * @param {Number} maxError - Tolerance, squared error between points and fitted curve
 * @returns {Array<Array<Array<Number>>>} Array of Bezier curves, where each element is [first-point, control-point-1, control-point-2, second-point] and points are [x, y]
 */
function fitCurve(points, maxError, progressCallback) {
    if (!Array.isArray(points)) {
        throw new TypeError("First argument should be an array");
    }
    points.forEach((point) => {
        if(!Array.isArray(point) || point.length !== 2
        || typeof point[0] !== 'number' || typeof point[1] !== 'number'){
            throw Error("Each point should be an array of two numbers")
        }
    });
    // Remove duplicate points
    points = points.filter((point, i) =>
        i === 0 || !(point[0] === points[i-1][0] && point[1] === points[i-1][1])
    );

    if (points.length < 2) {
        return [];
    }

    const len = points.length;
    const leftTangent = createTangent(points[1], points[0]);
    const rightTangent = createTangent(points[len - 2], points[len - 1]);

    return fitCubic(points, leftTangent, rightTangent, maxError, progressCallback);
}

/**
 * Fit a Bezier curve to a (sub)set of digitized points.
 * Your code should not call this function directly. Use {@link fitCurve} instead.
 *
 * @param {Array<Array<Number>>} points - Array of digitized points, e.g. [[5,5],[5,50],[110,140],[210,160],[320,110]]
 * @param {Array<Number>} leftTangent - Unit tangent vector at start point
 * @param {Array<Number>} rightTangent - Unit tangent vector at end point
 * @param {Number} error - Tolerance, squared error between points and fitted curve
 * @returns {Array<Array<Array<Number>>>} Array of Bezier curves, where each element is [first-point, control-point-1, control-point-2, second-point] and points are [x, y]
 */
function fitCubic(points, leftTangent, rightTangent, error, progressCallback) {
    const MaxIterations = 20;   //Max times to try iterating (to find an acceptable curve)

    var bezCurve,               //Control points of fitted Bezier curve
        u,                      //Parameter values for point
        uPrime,                 //Improved parameter values
        maxError, prevErr,      //Maximum fitting error
        splitPoint, prevSplit,  //Point to split point set at if we need more than one curve
        centerVector, toCenterTangent, fromCenterTangent,  //Unit tangent vector(s) at splitPoint
        beziers,                //Array of fitted Bezier curves if we need more than one curve
        dist, i;

    //console.log('fitCubic, ', points.length);

    //Use heuristic if region only has two points in it
    if (points.length === 2) {
        dist = maths.vectorLen(maths.subtract(points[0], points[1])) / 3.0;
        bezCurve = [
            points[0],
            maths.addArrays(points[0], maths.mulItems(leftTangent,  dist)),
            maths.addArrays(points[1], maths.mulItems(rightTangent, dist)),
            points[1]
        ];
        return [bezCurve];
    }

    //Parameterize points, and attempt to fit curve
    u = chordLengthParameterize(points);
    [bezCurve, maxError, splitPoint] = generateAndReport(points, u, u, leftTangent, rightTangent, progressCallback)

    if (maxError < error) {
        return [bezCurve];
    }
    //If error not too large, try some reparameterization and iteration
    if (maxError < (error*error)) {

        uPrime = u;
        prevErr = maxError;
        prevSplit = splitPoint;

        for (i = 0; i < MaxIterations; i++) {

            uPrime = reparameterize(bezCurve, points, uPrime);
            [bezCurve, maxError, splitPoint] = generateAndReport(points, u, uPrime, leftTangent, rightTangent, progressCallback);

            if (maxError < error) {
                return [bezCurve];
            }
            //If the development of the fitted curve grinds to a halt,
            //we abort this attempt (and try a shorter curve):
            else if(splitPoint === prevSplit) {
                let errChange = maxError/prevErr;
                if((errChange > .9999) && (errChange < 1.0001)) {
                    break;
                }
            }

            prevErr = maxError;
            prevSplit = splitPoint;
        }
    }

    //Fitting failed -- split at max error point and fit recursively
    beziers = [];

    //To create a smooth transition from one curve segment to the next,
    //we calculate the tangent of the points directly before and after the center,
    //and use that same tangent both to and from the center point.
    centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint + 1]);
    //However, should those two points be equal, the normal tangent calculation will fail.
    //Instead, we calculate the tangent from that "double-point" to the center point, and rotate 90deg.
    if((centerVector[0] === 0) && (centerVector[1] === 0)) {
        //toCenterTangent = createTangent(points[splitPoint - 1], points[splitPoint]);
        //fromCenterTangent = createTangent(points[splitPoint + 1], points[splitPoint]);

        //[x,y] -> [-y,x]: http://stackoverflow.com/a/4780141/1869660
        centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint])
                            .reverse();
        centerVector[0] = -centerVector[0];
    }
    toCenterTangent = maths.normalize(centerVector);
    //To and from need to point in opposite directions:
    fromCenterTangent = maths.mulItems(toCenterTangent, -1);

    /*
    Note: An alternative to this "divide and conquer" recursion could be to always
          let new curve segments start by trying to go all the way to the end,
          instead of only to the end of the current subdivided polyline.
          That might let many segments fit a few points more, reducing the number of total segments.

          However, a few tests have shown that the segment reduction is insignificant
          (240 pts, 100 err: 25 curves vs 27 curves. 140 pts, 100 err: 17 curves on both),
          and the results take twice as many steps and milliseconds to finish,
          without looking any better than what we already have.
    */
    beziers = beziers.concat(fitCubic(points.slice(0, splitPoint + 1), leftTangent, toCenterTangent,    error, progressCallback));
    beziers = beziers.concat(fitCubic(points.slice(splitPoint),        fromCenterTangent, rightTangent, error, progressCallback));
    return beziers;
};

function generateAndReport(points, paramsOrig, paramsPrime, leftTangent, rightTangent, progressCallback) {
    var bezCurve, maxError, splitPoint;

    bezCurve = generateBezier(points, paramsPrime, leftTangent, rightTangent, progressCallback);
    //Find max deviation of points to fitted curve.
    //Here we always use the original parameters (from chordLengthParameterize()),
    //because we need to compare the current curve to the actual source polyline,
    //and not the currently iterated parameters which reparameterize() & generateBezier() use,
    //as those have probably drifted far away and may no longer be in ascending order.
    [maxError, splitPoint] = computeMaxError(points, bezCurve, paramsOrig);

    if(progressCallback) {
        progressCallback({
            bez: bezCurve,
            points: points,
            params: paramsOrig,
            maxErr: maxError,
            maxPoint: splitPoint,
        });
    }

    return [bezCurve, maxError, splitPoint];
}

/**
 * Use least-squares method to find Bezier control points for region.
 *
 * @param {Array<Array<Number>>} points - Array of digitized points
 * @param {Array<Number>} parameters - Parameter values for region
 * @param {Array<Number>} leftTangent - Unit tangent vector at start point
 * @param {Array<Number>} rightTangent - Unit tangent vector at end point
 * @returns {Array<Array<Number>>} Approximated Bezier curve: [first-point, control-point-1, control-point-2, second-point] where points are [x, y]
 */
function generateBezier(points, parameters, leftTangent, rightTangent) {
    var bezCurve,                       //Bezier curve ctl pts
        A, a,                           //Precomputed rhs for eqn
        C, X,                           //Matrices C & X
        det_C0_C1, det_C0_X, det_X_C1,  //Determinants of matrices
        alpha_l, alpha_r,               //Alpha values, left and right

        epsilon, segLength,
        i, len, tmp, u, ux,
        firstPoint = points[0],
        lastPoint = points[points.length-1];

    bezCurve = [firstPoint, null, null, lastPoint];
    //console.log('gb', parameters.length);

    //Compute the A's
    A = maths.zeros_Xx2x2(parameters.length);
    for (i = 0, len = parameters.length; i < len; i++) {
        u = parameters[i];
        ux = 1 - u;
        a = A[i];

        a[0] = maths.mulItems(leftTangent,  3 * u  * (ux*ux));
        a[1] = maths.mulItems(rightTangent, 3 * ux * (u*u));
    }

    //Create the C and X matrices
    C = [[0,0], [0,0]];
    X = [0,0];
    for (i = 0, len = points.length; i < len; i++) {
        u = parameters[i];
        a = A[i];

        C[0][0] += maths.dot(a[0], a[0]);
        C[0][1] += maths.dot(a[0], a[1]);
        C[1][0] += maths.dot(a[0], a[1]);
        C[1][1] += maths.dot(a[1], a[1]);

        tmp = maths.subtract(points[i], bezier.q([firstPoint, firstPoint, lastPoint, lastPoint], u));

        X[0] += maths.dot(a[0], tmp);
        X[1] += maths.dot(a[1], tmp);
    }

    //Compute the determinants of C and X
    det_C0_C1 = (C[0][0] * C[1][1]) - (C[1][0] * C[0][1]);
    det_C0_X  = (C[0][0] * X[1]   ) - (C[1][0] * X[0]   );
    det_X_C1  = (X[0]    * C[1][1]) - (X[1]    * C[0][1]);

    //Finally, derive alpha values
    alpha_l = det_C0_C1 === 0 ? 0 : det_X_C1 / det_C0_C1;
    alpha_r = det_C0_C1 === 0 ? 0 : det_C0_X / det_C0_C1;

    //If alpha negative, use the Wu/Barsky heuristic (see text).
    //If alpha is 0, you get coincident control points that lead to
    //divide by zero in any subsequent NewtonRaphsonRootFind() call.
    segLength = maths.vectorLen(maths.subtract(firstPoint, lastPoint));
    epsilon = 1.0e-6 * segLength;
    if (alpha_l < epsilon || alpha_r < epsilon) {
        //Fall back on standard (probably inaccurate) formula, and subdivide further if needed.
        bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent,  segLength / 3.0));
        bezCurve[2] = maths.addArrays(lastPoint,  maths.mulItems(rightTangent, segLength / 3.0));
    } else {
        //First and last control points of the Bezier curve are
        //positioned exactly at the first and last data points
        //Control points 1 and 2 are positioned an alpha distance out
        //on the tangent vectors, left and right, respectively
        bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent,  alpha_l));
        bezCurve[2] = maths.addArrays(lastPoint,  maths.mulItems(rightTangent, alpha_r));
    }

    return bezCurve;
};

/**
 * Given set of points and their parameterization, try to find a better parameterization.
 *
 * @param {Array<Array<Number>>} bezier - Current fitted curve
 * @param {Array<Array<Number>>} points - Array of digitized points
 * @param {Array<Number>} parameters - Current parameter values
 * @returns {Array<Number>} New parameter values
 */
function reparameterize(bezier, points, parameters) {
    /*
    var j, len, point, results, u;
    results = [];
    for (j = 0, len = points.length; j < len; j++) {
        point = points[j], u = parameters[j];

        results.push(newtonRaphsonRootFind(bezier, point, u));
    }
    return results;
    //*/
    return parameters.map((p, i) => newtonRaphsonRootFind(bezier, points[i], p));
};

/**
 * Use Newton-Raphson iteration to find better root.
 *
 * @param {Array<Array<Number>>} bez - Current fitted curve
 * @param {Array<Number>} point - Digitized point
 * @param {Number} u - Parameter value for "P"
 * @returns {Number} New u
 */
function newtonRaphsonRootFind(bez, point, u) {
    /*
        Newton's root finding algorithm calculates f(x)=0 by reiterating
        x_n+1 = x_n - f(x_n)/f'(x_n)
        We are trying to find curve parameter u for some point p that minimizes
        the distance from that point to the curve. Distance point to curve is d=q(u)-p.
        At minimum distance the point is perpendicular to the curve.
        We are solving
        f = q(u)-p * q'(u) = 0
        with
        f' = q'(u) * q'(u) + q(u)-p * q''(u)
        gives
        u_n+1 = u_n - |q(u_n)-p * q'(u_n)| / |q'(u_n)**2 + q(u_n)-p * q''(u_n)|
    */

    var d = maths.subtract(bezier.q(bez, u), point),
        qprime = bezier.qprime(bez, u),
        numerator = /*sum(*/maths.mulMatrix(d, qprime)/*)*/,
        denominator = maths.sum(maths.addItems( maths.squareItems(qprime), maths.mulMatrix(d, bezier.qprimeprime(bez, u)) ));

    if (denominator === 0) {
        return u;
    } else {
        return u - (numerator/denominator);
    }
};

/**
 * Assign parameter values to digitized points using relative distances between points.
 *
 * @param {Array<Array<Number>>} points - Array of digitized points
 * @returns {Array<Number>} Parameter values
 */
function chordLengthParameterize(points) {
    var u = [], currU, prevU, prevP;

    points.forEach((p, i) => {
        currU = i ? prevU + maths.vectorLen(maths.subtract(p, prevP))
                  : 0;
        u.push(currU);

        prevU = currU;
        prevP = p;
    })
    u = u.map(x => x/prevU);

    return u;
};

/**
 * Find the maximum squared distance of digitized points to fitted curve.
 *
 * @param {Array<Array<Number>>} points - Array of digitized points
 * @param {Array<Array<Number>>} bez - Fitted curve
 * @param {Array<Number>} parameters - Parameterization of points
 * @returns {Array<Number>} Maximum error (squared) and point of max error
 */
function computeMaxError(points, bez, parameters) {
    var dist,       //Current error
        maxDist,    //Maximum error
        splitPoint, //Point of maximum error
        v,          //Vector from point to curve
        i, count, point, t;

    maxDist = 0;
    splitPoint = points.length / 2;

    const t_distMap = mapTtoRelativeDistances(bez, 10);

    for (i = 0, count = points.length; i < count; i++) {
        point = points[i];
        //Find 't' for a point on the bez curve that's as close to 'point' as possible:
        t = find_t(bez, parameters[i], t_distMap, 10);

        v = maths.subtract(bezier.q(bez, t), point);
        dist = v[0]*v[0] + v[1]*v[1];

        if (dist > maxDist) {
            maxDist = dist;
            splitPoint = i;
        }
    }

    return [maxDist, splitPoint];
};

//Sample 't's and map them to relative distances along the curve:
var mapTtoRelativeDistances = function (bez, B_parts) {
    var B_t_curr;
    var B_t_dist = [0];
    var B_t_prev = bez[0];
    var sumLen = 0;

    for (var i=1; i<=B_parts; i++) {
      B_t_curr = bezier.q(bez, i/B_parts);

      sumLen += maths.vectorLen(maths.subtract(B_t_curr, B_t_prev));

      B_t_dist.push(sumLen);
      B_t_prev = B_t_curr;
    }

    //Normalize B_length to the same interval as the parameter distances; 0 to 1:
    B_t_dist = B_t_dist.map(x => x/sumLen);
    return B_t_dist;
};

function find_t(bez, param, t_distMap, B_parts) {
    if(param < 0) { return 0; }
    if(param > 1) { return 1; }

    /*
        'param' is a value between 0 and 1 telling us the relative position
        of a point on the source polyline (linearly from the start (0) to the end (1)).
        To see if a given curve - 'bez' - is a close approximation of the polyline,
        we compare such a poly-point to the point on the curve that's the same
        relative distance along the curve's length.

        But finding that curve-point takes a little work:
        There is a function "B(t)" to find points along a curve from the parametric parameter 't'
        (also relative from 0 to 1: http://stackoverflow.com/a/32841764/1869660
                                    http://pomax.github.io/bezierinfo/#explanation),
        but 't' isn't linear by length (http://gamedev.stackexchange.com/questions/105230).

        So, we sample some points along the curve using a handful of values for 't'.
        Then, we calculate the length between those samples via plain euclidean distance;
        B(t) concentrates the points around sharp turns, so this should give us a good-enough outline of the curve.
        Thus, for a given relative distance ('param'), we can now find an upper and lower value
        for the corresponding 't' by searching through those sampled distances.
        Finally, we just use linear interpolation to find a better value for the exact 't'.

        More info:
            http://gamedev.stackexchange.com/questions/105230/points-evenly-spaced-along-a-bezier-curve
            http://stackoverflow.com/questions/29438398/cheap-way-of-calculating-cubic-bezier-length
            http://steve.hollasch.net/cgindex/curves/cbezarclen.html
            https://github.com/retuxx/tinyspline
    */
    var lenMax, lenMin, tMax, tMin, t;

    //Find the two t-s that the current param distance lies between,
    //and then interpolate a somewhat accurate value for the exact t:
    for(var i = 1; i <= B_parts; i++) {

        if(param <= t_distMap[i]) {
            tMin   = (i-1) / B_parts;
            tMax   = i / B_parts;
            lenMin = t_distMap[i-1];
            lenMax = t_distMap[i];

            t = (param-lenMin)/(lenMax-lenMin) * (tMax-tMin) + tMin;
            break;
        }
    }
    return t;
}

/**
 * Creates a vector of length 1 which shows the direction from B to A
 */
function createTangent(pointA, pointB) {
    return maths.normalize(maths.subtract(pointA, pointB));
}

/*
    Simplified versions of what we need from math.js
    Optimized for our input, which is only numbers and 1x2 arrays (i.e. [x, y] coordinates).
*/
class maths {
    //zeros = logAndRun(math.zeros);
    static zeros_Xx2x2(x) {
        var zs = [];
        while(x--) { zs.push([0,0]); }
        return zs
    }

    //multiply = logAndRun(math.multiply);
    static mulItems(items, multiplier) {
        //return items.map(x => x*multiplier);
        return [items[0]*multiplier, items[1]*multiplier];
    }
    static mulMatrix(m1, m2) {
        //https://en.wikipedia.org/wiki/Matrix_multiplication#Matrix_product_.28two_matrices.29
        //Simplified to only handle 1-dimensional matrices (i.e. arrays) of equal length:
        //  return m1.reduce((sum,x1,i) => sum + (x1*m2[i]),
        //                   0);
        return (m1[0]*m2[0]) + (m1[1]*m2[1]);
    }

    //Only used to subract to points (or at least arrays):
    //  subtract = logAndRun(math.subtract);
    static subtract(arr1, arr2) {
        //return arr1.map((x1, i) => x1 - arr2[i]);
        return [arr1[0]-arr2[0], arr1[1]-arr2[1]];
    }

    //add = logAndRun(math.add);
    static addArrays(arr1, arr2) {
        //return arr1.map((x1, i) => x1 + arr2[i]);
        return [arr1[0]+arr2[0], arr1[1]+arr2[1]];
    }
    static addItems(items, addition) {
        //return items.map(x => x+addition);
        return [items[0]+addition, items[1]+addition];
    }

    //var sum = logAndRun(math.sum);
    static sum(items) {
        return items.reduce((sum,x) => sum + x);
    }

    //chain = math.chain;

    //Only used on two arrays. The dot product is equal to the matrix product in this case:
    //  dot = logAndRun(math.dot);
    static dot(m1, m2) {
        return maths.mulMatrix(m1, m2);
    }

    //https://en.wikipedia.org/wiki/Norm_(mathematics)#Euclidean_norm
    //  var norm = logAndRun(math.norm);
    static vectorLen(v) {
        var a = v[0], b = v[1];
        return Math.sqrt(a*a + b*b);
    }

    //math.divide = logAndRun(math.divide);
    static divItems(items, divisor) {
        //return items.map(x => x/divisor);
        return [items[0]/divisor, items[1]/divisor];
    }

    //var dotPow = logAndRun(math.dotPow);
    static squareItems(items) {
        //return items.map(x => x*x);
        var a = items[0], b = items[1];
        return [a*a, b*b];
    }

    static normalize(v) {
        return this.divItems(v, this.vectorLen(v));
    }

    //Math.pow = logAndRun(Math.pow);
}


class bezier {
    //Evaluates cubic bezier at t, return point
    static q(ctrlPoly, t) {
        var tx = 1.0 - t;
        var pA = maths.mulItems( ctrlPoly[0],      tx * tx * tx ),
            pB = maths.mulItems( ctrlPoly[1],  3 * tx * tx *  t ),
            pC = maths.mulItems( ctrlPoly[2],  3 * tx *  t *  t ),
            pD = maths.mulItems( ctrlPoly[3],       t *  t *  t );
        return maths.addArrays(maths.addArrays(pA, pB), maths.addArrays(pC, pD));
    }

    //Evaluates cubic bezier first derivative at t, return point
    static qprime(ctrlPoly, t) {
        var tx = 1.0 - t;
        var pA = maths.mulItems( maths.subtract(ctrlPoly[1], ctrlPoly[0]),  3 * tx * tx ),
            pB = maths.mulItems( maths.subtract(ctrlPoly[2], ctrlPoly[1]),  6 * tx *  t ),
            pC = maths.mulItems( maths.subtract(ctrlPoly[3], ctrlPoly[2]),  3 *  t *  t );
        return maths.addArrays(maths.addArrays(pA, pB), pC);
    }

    //Evaluates cubic bezier second derivative at t, return point
    static qprimeprime(ctrlPoly, t) {
        return maths.addArrays(maths.mulItems( maths.addArrays(maths.subtract(ctrlPoly[2], maths.mulItems(ctrlPoly[1], 2)), ctrlPoly[0]),  6 * (1.0 - t) ),
                               maths.mulItems( maths.addArrays(maths.subtract(ctrlPoly[3], maths.mulItems(ctrlPoly[2], 2)), ctrlPoly[1]),  6 *        t  ));
    }
}

module.exports = fitCurve;

},{}],6:[function(require,module,exports){
/*!
* svg.js - A lightweight library for manipulating and animating SVG.
* @version 2.3.7
* https://svgdotjs.github.io/
*
* @copyright Wout Fierens <wout@mick-wout.com>
* @license MIT
*
* BUILT: Sat Jan 14 2017 07:23:18 GMT+0100 (CET)
*/;
(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    define(function(){
      return factory(root, root.document)
    })
  } else if (typeof exports === 'object') {
    module.exports = root.document ? factory(root, root.document) : function(w){ return factory(w, w.document) }
  } else {
    root.SVG = factory(root, root.document)
  }
}(typeof window !== "undefined" ? window : this, function(window, document) {

// The main wrapping element
var SVG = this.SVG = function(element) {
  if (SVG.supported) {
    element = new SVG.Doc(element)

    if(!SVG.parser.draw)
      SVG.prepare()

    return element
  }
}

// Default namespaces
SVG.ns    = 'http://www.w3.org/2000/svg'
SVG.xmlns = 'http://www.w3.org/2000/xmlns/'
SVG.xlink = 'http://www.w3.org/1999/xlink'
SVG.svgjs = 'http://svgjs.com/svgjs'

// Svg support test
SVG.supported = (function() {
  return !! document.createElementNS &&
         !! document.createElementNS(SVG.ns,'svg').createSVGRect
})()

// Don't bother to continue if SVG is not supported
if (!SVG.supported) return false

// Element id sequence
SVG.did  = 1000

// Get next named element id
SVG.eid = function(name) {
  return 'Svgjs' + capitalize(name) + (SVG.did++)
}

// Method for element creation
SVG.create = function(name) {
  // create element
  var element = document.createElementNS(this.ns, name)

  // apply unique id
  element.setAttribute('id', this.eid(name))

  return element
}

// Method for extending objects
SVG.extend = function() {
  var modules, methods, key, i

  // Get list of modules
  modules = [].slice.call(arguments)

  // Get object with extensions
  methods = modules.pop()

  for (i = modules.length - 1; i >= 0; i--)
    if (modules[i])
      for (key in methods)
        modules[i].prototype[key] = methods[key]

  // Make sure SVG.Set inherits any newly added methods
  if (SVG.Set && SVG.Set.inherit)
    SVG.Set.inherit()
}

// Invent new element
SVG.invent = function(config) {
  // Create element initializer
  var initializer = typeof config.create == 'function' ?
    config.create :
    function() {
      this.constructor.call(this, SVG.create(config.create))
    }

  // Inherit prototype
  if (config.inherit)
    initializer.prototype = new config.inherit

  // Extend with methods
  if (config.extend)
    SVG.extend(initializer, config.extend)

  // Attach construct method to parent
  if (config.construct)
    SVG.extend(config.parent || SVG.Container, config.construct)

  return initializer
}

// Adopt existing svg elements
SVG.adopt = function(node) {
  // check for presence of node
  if (!node) return null

  // make sure a node isn't already adopted
  if (node.instance) return node.instance

  // initialize variables
  var element

  // adopt with element-specific settings
  if (node.nodeName == 'svg')
    element = node.parentNode instanceof SVGElement ? new SVG.Nested : new SVG.Doc
  else if (node.nodeName == 'linearGradient')
    element = new SVG.Gradient('linear')
  else if (node.nodeName == 'radialGradient')
    element = new SVG.Gradient('radial')
  else if (SVG[capitalize(node.nodeName)])
    element = new SVG[capitalize(node.nodeName)]
  else
    element = new SVG.Element(node)

  // ensure references
  element.type  = node.nodeName
  element.node  = node
  node.instance = element

  // SVG.Class specific preparations
  if (element instanceof SVG.Doc)
    element.namespace().defs()

  // pull svgjs data from the dom (getAttributeNS doesn't work in html5)
  element.setData(JSON.parse(node.getAttribute('svgjs:data')) || {})

  return element
}

// Initialize parsing element
SVG.prepare = function() {
  // Select document body and create invisible svg element
  var body = document.getElementsByTagName('body')[0]
    , draw = (body ? new SVG.Doc(body) :  new SVG.Doc(document.documentElement).nested()).size(2, 0)

  // Create parser object
  SVG.parser = {
    body: body || document.documentElement
  , draw: draw.style('opacity:0;position:fixed;left:100%;top:100%;overflow:hidden')
  , poly: draw.polyline().node
  , path: draw.path().node
  , native: SVG.create('svg')
  }
}

SVG.parser = {
  native: SVG.create('svg')
}

document.addEventListener('DOMContentLoaded', function() {
  if(!SVG.parser.draw)
    SVG.prepare()
}, false)

// Storage for regular expressions
SVG.regex = {
  // Parse unit value
  numberAndUnit:    /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i

  // Parse hex value
, hex:              /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i

  // Parse rgb value
, rgb:              /rgb\((\d+),(\d+),(\d+)\)/

  // Parse reference id
, reference:        /#([a-z0-9\-_]+)/i

  // Parse matrix wrapper
, matrix:           /matrix\(|\)/g

  // Elements of a matrix
, matrixElements:   /,*\s+|,/

  // Whitespace
, whitespace:       /\s/g

  // Test hex value
, isHex:            /^#[a-f0-9]{3,6}$/i

  // Test rgb value
, isRgb:            /^rgb\(/

  // Test css declaration
, isCss:            /[^:]+:[^;]+;?/

  // Test for blank string
, isBlank:          /^(\s+)?$/

  // Test for numeric string
, isNumber:         /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i

  // Test for percent value
, isPercent:        /^-?[\d\.]+%$/

  // Test for image url
, isImage:          /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i

  // The following regex are used to parse the d attribute of a path

  // Replaces all negative exponents
, negExp:           /e\-/gi

  // Replaces all comma
, comma:            /,/g

  // Replaces all hyphens
, hyphen:           /\-/g

  // Replaces and tests for all path letters
, pathLetters:      /[MLHVCSQTAZ]/gi

  // yes we need this one, too
, isPathLetter:     /[MLHVCSQTAZ]/i

  // split at whitespaces
, whitespaces:      /\s+/

  // matches X
, X:                /X/g
}

SVG.utils = {
  // Map function
  map: function(array, block) {
    var i
      , il = array.length
      , result = []

    for (i = 0; i < il; i++)
      result.push(block(array[i]))

    return result
  }

  // Filter function
, filter: function(array, block) {
    var i
      , il = array.length
      , result = []

    for (i = 0; i < il; i++)
      if (block(array[i]))
        result.push(array[i])

    return result
  }

  // Degrees to radians
, radians: function(d) {
    return d % 360 * Math.PI / 180
  }

  // Radians to degrees
, degrees: function(r) {
    return r * 180 / Math.PI % 360
  }

, filterSVGElements: function(nodes) {
    return this.filter( nodes, function(el) { return el instanceof SVGElement })
  }

}

SVG.defaults = {
  // Default attribute values
  attrs: {
    // fill and stroke
    'fill-opacity':     1
  , 'stroke-opacity':   1
  , 'stroke-width':     0
  , 'stroke-linejoin':  'miter'
  , 'stroke-linecap':   'butt'
  , fill:               '#000000'
  , stroke:             '#000000'
  , opacity:            1
    // position
  , x:                  0
  , y:                  0
  , cx:                 0
  , cy:                 0
    // size
  , width:              0
  , height:             0
    // radius
  , r:                  0
  , rx:                 0
  , ry:                 0
    // gradient
  , offset:             0
  , 'stop-opacity':     1
  , 'stop-color':       '#000000'
    // text
  , 'font-size':        16
  , 'font-family':      'Helvetica, Arial, sans-serif'
  , 'text-anchor':      'start'
  }

}
// Module for color convertions
SVG.Color = function(color) {
  var match

  // initialize defaults
  this.r = 0
  this.g = 0
  this.b = 0

  if(!color) return

  // parse color
  if (typeof color === 'string') {
    if (SVG.regex.isRgb.test(color)) {
      // get rgb values
      match = SVG.regex.rgb.exec(color.replace(/\s/g,''))

      // parse numeric values
      this.r = parseInt(match[1])
      this.g = parseInt(match[2])
      this.b = parseInt(match[3])

    } else if (SVG.regex.isHex.test(color)) {
      // get hex values
      match = SVG.regex.hex.exec(fullHex(color))

      // parse numeric values
      this.r = parseInt(match[1], 16)
      this.g = parseInt(match[2], 16)
      this.b = parseInt(match[3], 16)

    }

  } else if (typeof color === 'object') {
    this.r = color.r
    this.g = color.g
    this.b = color.b

  }

}

SVG.extend(SVG.Color, {
  // Default to hex conversion
  toString: function() {
    return this.toHex()
  }
  // Build hex value
, toHex: function() {
    return '#'
      + compToHex(this.r)
      + compToHex(this.g)
      + compToHex(this.b)
  }
  // Build rgb value
, toRgb: function() {
    return 'rgb(' + [this.r, this.g, this.b].join() + ')'
  }
  // Calculate true brightness
, brightness: function() {
    return (this.r / 255 * 0.30)
         + (this.g / 255 * 0.59)
         + (this.b / 255 * 0.11)
  }
  // Make color morphable
, morph: function(color) {
    this.destination = new SVG.Color(color)

    return this
  }
  // Get morphed color at given position
, at: function(pos) {
    // make sure a destination is defined
    if (!this.destination) return this

    // normalise pos
    pos = pos < 0 ? 0 : pos > 1 ? 1 : pos

    // generate morphed color
    return new SVG.Color({
      r: ~~(this.r + (this.destination.r - this.r) * pos)
    , g: ~~(this.g + (this.destination.g - this.g) * pos)
    , b: ~~(this.b + (this.destination.b - this.b) * pos)
    })
  }

})

// Testers

// Test if given value is a color string
SVG.Color.test = function(color) {
  color += ''
  return SVG.regex.isHex.test(color)
      || SVG.regex.isRgb.test(color)
}

// Test if given value is a rgb object
SVG.Color.isRgb = function(color) {
  return color && typeof color.r == 'number'
               && typeof color.g == 'number'
               && typeof color.b == 'number'
}

// Test if given value is a color
SVG.Color.isColor = function(color) {
  return SVG.Color.isRgb(color) || SVG.Color.test(color)
}
// Module for array conversion
SVG.Array = function(array, fallback) {
  array = (array || []).valueOf()

  // if array is empty and fallback is provided, use fallback
  if (array.length == 0 && fallback)
    array = fallback.valueOf()

  // parse array
  this.value = this.parse(array)
}

SVG.extend(SVG.Array, {
  // Make array morphable
  morph: function(array) {
    this.destination = this.parse(array)

    // normalize length of arrays
    if (this.value.length != this.destination.length) {
      var lastValue       = this.value[this.value.length - 1]
        , lastDestination = this.destination[this.destination.length - 1]

      while(this.value.length > this.destination.length)
        this.destination.push(lastDestination)
      while(this.value.length < this.destination.length)
        this.value.push(lastValue)
    }

    return this
  }
  // Clean up any duplicate points
, settle: function() {
    // find all unique values
    for (var i = 0, il = this.value.length, seen = []; i < il; i++)
      if (seen.indexOf(this.value[i]) == -1)
        seen.push(this.value[i])

    // set new value
    return this.value = seen
  }
  // Get morphed array at given position
, at: function(pos) {
    // make sure a destination is defined
    if (!this.destination) return this

    // generate morphed array
    for (var i = 0, il = this.value.length, array = []; i < il; i++)
      array.push(this.value[i] + (this.destination[i] - this.value[i]) * pos)

    return new SVG.Array(array)
  }
  // Convert array to string
, toString: function() {
    return this.value.join(' ')
  }
  // Real value
, valueOf: function() {
    return this.value
  }
  // Parse whitespace separated string
, parse: function(array) {
    array = array.valueOf()

    // if already is an array, no need to parse it
    if (Array.isArray(array)) return array

    return this.split(array)
  }
  // Strip unnecessary whitespace
, split: function(string) {
    return string.trim().split(/\s+/)
  }
  // Reverse array
, reverse: function() {
    this.value.reverse()

    return this
  }

})
// Poly points array
SVG.PointArray = function(array, fallback) {
  this.constructor.call(this, array, fallback || [[0,0]])
}

// Inherit from SVG.Array
SVG.PointArray.prototype = new SVG.Array

SVG.extend(SVG.PointArray, {
  // Convert array to string
  toString: function() {
    // convert to a poly point string
    for (var i = 0, il = this.value.length, array = []; i < il; i++)
      array.push(this.value[i].join(','))

    return array.join(' ')
  }
  // Convert array to line object
, toLine: function() {
    return {
      x1: this.value[0][0]
    , y1: this.value[0][1]
    , x2: this.value[1][0]
    , y2: this.value[1][1]
    }
  }
  // Get morphed array at given position
, at: function(pos) {
    // make sure a destination is defined
    if (!this.destination) return this

    // generate morphed point string
    for (var i = 0, il = this.value.length, array = []; i < il; i++)
      array.push([
        this.value[i][0] + (this.destination[i][0] - this.value[i][0]) * pos
      , this.value[i][1] + (this.destination[i][1] - this.value[i][1]) * pos
      ])

    return new SVG.PointArray(array)
  }
  // Parse point string
, parse: function(array) {
    var points = []

    array = array.valueOf()

    // if already is an array, no need to parse it
    if (Array.isArray(array)) return array

    // parse points
    array = array.trim().split(/\s+|,/)

    // validate points - https://svgwg.org/svg2-draft/shapes.html#DataTypePoints
    // Odd number of coordinates is an error. In such cases, drop the last odd coordinate.
    if (array.length % 2 !== 0) array.pop()

    // wrap points in two-tuples and parse points as floats
    for(var i = 0, len = array.length; i < len; i = i + 2)
      points.push([ parseFloat(array[i]), parseFloat(array[i+1]) ])

    return points
  }
  // Move point string
, move: function(x, y) {
    var box = this.bbox()

    // get relative offset
    x -= box.x
    y -= box.y

    // move every point
    if (!isNaN(x) && !isNaN(y))
      for (var i = this.value.length - 1; i >= 0; i--)
        this.value[i] = [this.value[i][0] + x, this.value[i][1] + y]

    return this
  }
  // Resize poly string
, size: function(width, height) {
    var i, box = this.bbox()

    // recalculate position of all points according to new size
    for (i = this.value.length - 1; i >= 0; i--) {
      this.value[i][0] = ((this.value[i][0] - box.x) * width)  / box.width  + box.x
      this.value[i][1] = ((this.value[i][1] - box.y) * height) / box.height + box.y
    }

    return this
  }
  // Get bounding box of points
, bbox: function() {
    SVG.parser.poly.setAttribute('points', this.toString())

    return SVG.parser.poly.getBBox()
  }

})
// Path points array
SVG.PathArray = function(array, fallback) {
  this.constructor.call(this, array, fallback || [['M', 0, 0]])
}

// Inherit from SVG.Array
SVG.PathArray.prototype = new SVG.Array

SVG.extend(SVG.PathArray, {
  // Convert array to string
  toString: function() {
    return arrayToString(this.value)
  }
  // Move path string
, move: function(x, y) {
    // get bounding box of current situation
    var box = this.bbox()

    // get relative offset
    x -= box.x
    y -= box.y

    if (!isNaN(x) && !isNaN(y)) {
      // move every point
      for (var l, i = this.value.length - 1; i >= 0; i--) {
        l = this.value[i][0]

        if (l == 'M' || l == 'L' || l == 'T')  {
          this.value[i][1] += x
          this.value[i][2] += y

        } else if (l == 'H')  {
          this.value[i][1] += x

        } else if (l == 'V')  {
          this.value[i][1] += y

        } else if (l == 'C' || l == 'S' || l == 'Q')  {
          this.value[i][1] += x
          this.value[i][2] += y
          this.value[i][3] += x
          this.value[i][4] += y

          if (l == 'C')  {
            this.value[i][5] += x
            this.value[i][6] += y
          }

        } else if (l == 'A')  {
          this.value[i][6] += x
          this.value[i][7] += y
        }

      }
    }

    return this
  }
  // Resize path string
, size: function(width, height) {
    // get bounding box of current situation
    var i, l, box = this.bbox()

    // recalculate position of all points according to new size
    for (i = this.value.length - 1; i >= 0; i--) {
      l = this.value[i][0]

      if (l == 'M' || l == 'L' || l == 'T')  {
        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x
        this.value[i][2] = ((this.value[i][2] - box.y) * height) / box.height + box.y

      } else if (l == 'H')  {
        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x

      } else if (l == 'V')  {
        this.value[i][1] = ((this.value[i][1] - box.y) * height) / box.height + box.y

      } else if (l == 'C' || l == 'S' || l == 'Q')  {
        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x
        this.value[i][2] = ((this.value[i][2] - box.y) * height) / box.height + box.y
        this.value[i][3] = ((this.value[i][3] - box.x) * width)  / box.width  + box.x
        this.value[i][4] = ((this.value[i][4] - box.y) * height) / box.height + box.y

        if (l == 'C')  {
          this.value[i][5] = ((this.value[i][5] - box.x) * width)  / box.width  + box.x
          this.value[i][6] = ((this.value[i][6] - box.y) * height) / box.height + box.y
        }

      } else if (l == 'A')  {
        // resize radii
        this.value[i][1] = (this.value[i][1] * width)  / box.width
        this.value[i][2] = (this.value[i][2] * height) / box.height

        // move position values
        this.value[i][6] = ((this.value[i][6] - box.x) * width)  / box.width  + box.x
        this.value[i][7] = ((this.value[i][7] - box.y) * height) / box.height + box.y
      }

    }

    return this
  }
  // Test if the passed path array use the same path data commands as this path array
, equalCommands: function(pathArray) {
    var i, il, equalCommands

    pathArray = new SVG.PathArray(pathArray)

    equalCommands = this.value.length === pathArray.value.length
    for(i = 0, il = this.value.length; equalCommands && i < il; i++) {
      equalCommands = this.value[i][0] === pathArray.value[i][0]
    }

    return equalCommands
  }
  // Make path array morphable
, morph: function(pathArray) {
    pathArray = new SVG.PathArray(pathArray)

    if(this.equalCommands(pathArray)) {
      this.destination = pathArray
    } else {
      this.destination = null
    }

    return this
  }
  // Get morphed path array at given position
, at: function(pos) {
    // make sure a destination is defined
    if (!this.destination) return this

    var sourceArray = this.value
      , destinationArray = this.destination.value
      , array = [], pathArray = new SVG.PathArray()
      , i, il, j, jl

    // Animate has specified in the SVG spec
    // See: https://www.w3.org/TR/SVG11/paths.html#PathElement
    for (i = 0, il = sourceArray.length; i < il; i++) {
      array[i] = [sourceArray[i][0]]
      for(j = 1, jl = sourceArray[i].length; j < jl; j++) {
        array[i][j] = sourceArray[i][j] + (destinationArray[i][j] - sourceArray[i][j]) * pos
      }
      // For the two flags of the elliptical arc command, the SVG spec say:
      // Flags and booleans are interpolated as fractions between zero and one, with any non-zero value considered to be a value of one/true
      // Elliptical arc command as an array followed by corresponding indexes:
      // ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]
      //   0    1   2        3                 4             5      6  7
      if(array[i][0] === 'A') {
        array[i][4] = +(array[i][4] != 0)
        array[i][5] = +(array[i][5] != 0)
      }
    }

    // Directly modify the value of a path array, this is done this way for performance
    pathArray.value = array
    return pathArray
  }
  // Absolutize and parse path to array
, parse: function(array) {
    // if it's already a patharray, no need to parse it
    if (array instanceof SVG.PathArray) return array.valueOf()

    // prepare for parsing
    var i, x0, y0, s, seg, arr
      , x = 0
      , y = 0
      , paramCnt = { 'M':2, 'L':2, 'H':1, 'V':1, 'C':6, 'S':4, 'Q':4, 'T':2, 'A':7 }

    if(typeof array == 'string'){

      array = array
        .replace(SVG.regex.negExp, 'X')         // replace all negative exponents with certain char
        .replace(SVG.regex.pathLetters, ' $& ') // put some room between letters and numbers
        .replace(SVG.regex.hyphen, ' -')        // add space before hyphen
        .replace(SVG.regex.comma, ' ')          // unify all spaces
        .replace(SVG.regex.X, 'e-')             // add back the expoent
        .trim()                                 // trim
        .split(SVG.regex.whitespaces)           // split into array

      // at this place there could be parts like ['3.124.854.32'] because we could not determine the point as seperator till now
      // we fix this elements in the next loop
      for(i = array.length; --i;){
        if(array[i].indexOf('.') != array[i].lastIndexOf('.')){
          var split = array[i].split('.') // split at the point
          var first = [split.shift(), split.shift()].join('.') // join the first number together
          array.splice.apply(array, [i, 1].concat(first, split.map(function(el){ return '.'+el }))) // add first and all other entries back to array
        }
      }

    }else{
      array = array.reduce(function(prev, curr){
        return [].concat.apply(prev, curr)
      }, [])
    }

    // array now is an array containing all parts of a path e.g. ['M', '0', '0', 'L', '30', '30' ...]

    var arr = []

    do{

      // Test if we have a path letter
      if(SVG.regex.isPathLetter.test(array[0])){
        s = array[0]
        array.shift()
      // If last letter was a move command and we got no new, it defaults to [L]ine
      }else if(s == 'M'){
        s = 'L'
      }else if(s == 'm'){
        s = 'l'
      }

      // add path letter as first element
      seg = [s.toUpperCase()]

      // push all necessary parameters to segment
      for(i = 0; i < paramCnt[seg[0]]; ++i){
        seg.push(parseFloat(array.shift()))
      }

      // upper case
      if(s == seg[0]){

        if(s == 'M' || s == 'L' || s == 'C' || s == 'Q' || s == 'S' || s == 'T'){
          x = seg[paramCnt[seg[0]]-1]
          y = seg[paramCnt[seg[0]]]
        }else if(s == 'V'){
          y = seg[1]
        }else if(s == 'H'){
          x = seg[1]
        }else if(s == 'A'){
          x = seg[6]
          y = seg[7]
        }

      // lower case
      }else{

        // convert relative to absolute values
        if(s == 'm' || s == 'l' || s == 'c' || s == 's' || s == 'q' || s == 't'){

          seg[1] += x
          seg[2] += y

          if(seg[3] != null){
            seg[3] += x
            seg[4] += y
          }

          if(seg[5] != null){
            seg[5] += x
            seg[6] += y
          }

          // move pointer
          x = seg[paramCnt[seg[0]]-1]
          y = seg[paramCnt[seg[0]]]

        }else if(s == 'v'){
          seg[1] += y
          y = seg[1]
        }else if(s == 'h'){
          seg[1] += x
          x = seg[1]
        }else if(s == 'a'){
          seg[6] += x
          seg[7] += y
          x = seg[6]
          y = seg[7]
        }

      }

      if(seg[0] == 'M'){
        x0 = x
        y0 = y
      }

      if(seg[0] == 'Z'){
        x = x0
        y = y0
      }

      arr.push(seg)

    }while(array.length)

    return arr

  }
  // Get bounding box of path
, bbox: function() {
    SVG.parser.path.setAttribute('d', this.toString())

    return SVG.parser.path.getBBox()
  }

})

// Module for unit convertions
SVG.Number = SVG.invent({
  // Initialize
  create: function(value, unit) {
    // initialize defaults
    this.value = 0
    this.unit  = unit || ''

    // parse value
    if (typeof value === 'number') {
      // ensure a valid numeric value
      this.value = isNaN(value) ? 0 : !isFinite(value) ? (value < 0 ? -3.4e+38 : +3.4e+38) : value

    } else if (typeof value === 'string') {
      unit = value.match(SVG.regex.numberAndUnit)

      if (unit) {
        // make value numeric
        this.value = parseFloat(unit[1])

        // normalize
        if (unit[5] == '%')
          this.value /= 100
        else if (unit[5] == 's')
          this.value *= 1000

        // store unit
        this.unit = unit[5]
      }

    } else {
      if (value instanceof SVG.Number) {
        this.value = value.valueOf()
        this.unit  = value.unit
      }
    }

  }
  // Add methods
, extend: {
    // Stringalize
    toString: function() {
      return (
        this.unit == '%' ?
          ~~(this.value * 1e8) / 1e6:
        this.unit == 's' ?
          this.value / 1e3 :
          this.value
      ) + this.unit
    }
  , toJSON: function() {
      return this.toString()
    }
  , // Convert to primitive
    valueOf: function() {
      return this.value
    }
    // Add number
  , plus: function(number) {
      return new SVG.Number(this + new SVG.Number(number), this.unit)
    }
    // Subtract number
  , minus: function(number) {
      return this.plus(-new SVG.Number(number))
    }
    // Multiply number
  , times: function(number) {
      return new SVG.Number(this * new SVG.Number(number), this.unit)
    }
    // Divide number
  , divide: function(number) {
      return new SVG.Number(this / new SVG.Number(number), this.unit)
    }
    // Convert to different unit
  , to: function(unit) {
      var number = new SVG.Number(this)

      if (typeof unit === 'string')
        number.unit = unit

      return number
    }
    // Make number morphable
  , morph: function(number) {
      this.destination = new SVG.Number(number)

      return this
    }
    // Get morphed number at given position
  , at: function(pos) {
      // Make sure a destination is defined
      if (!this.destination) return this

      // Generate new morphed number
      return new SVG.Number(this.destination)
          .minus(this)
          .times(pos)
          .plus(this)
    }

  }
})

SVG.Element = SVG.invent({
  // Initialize node
  create: function(node) {
    // make stroke value accessible dynamically
    this._stroke = SVG.defaults.attrs.stroke

    // initialize data object
    this.dom = {}

    // create circular reference
    if (this.node = node) {
      this.type = node.nodeName
      this.node.instance = this

      // store current attribute value
      this._stroke = node.getAttribute('stroke') || this._stroke
    }
  }

  // Add class methods
, extend: {
    // Move over x-axis
    x: function(x) {
      return this.attr('x', x)
    }
    // Move over y-axis
  , y: function(y) {
      return this.attr('y', y)
    }
    // Move by center over x-axis
  , cx: function(x) {
      return x == null ? this.x() + this.width() / 2 : this.x(x - this.width() / 2)
    }
    // Move by center over y-axis
  , cy: function(y) {
      return y == null ? this.y() + this.height() / 2 : this.y(y - this.height() / 2)
    }
    // Move element to given x and y values
  , move: function(x, y) {
      return this.x(x).y(y)
    }
    // Move element by its center
  , center: function(x, y) {
      return this.cx(x).cy(y)
    }
    // Set width of element
  , width: function(width) {
      return this.attr('width', width)
    }
    // Set height of element
  , height: function(height) {
      return this.attr('height', height)
    }
    // Set element size to given width and height
  , size: function(width, height) {
      var p = proportionalSize(this, width, height)

      return this
        .width(new SVG.Number(p.width))
        .height(new SVG.Number(p.height))
    }
    // Clone element
  , clone: function(parent) {
      // clone element and assign new id
      var clone = assignNewId(this.node.cloneNode(true))

      // insert the clone in the given parent or after myself
      if(parent) parent.add(clone)
      else this.after(clone)

      return clone
    }
    // Remove element
  , remove: function() {
      if (this.parent())
        this.parent().removeElement(this)

      return this
    }
    // Replace element
  , replace: function(element) {
      this.after(element).remove()

      return element
    }
    // Add element to given container and return self
  , addTo: function(parent) {
      return parent.put(this)
    }
    // Add element to given container and return container
  , putIn: function(parent) {
      return parent.add(this)
    }
    // Get / set id
  , id: function(id) {
      return this.attr('id', id)
    }
    // Checks whether the given point inside the bounding box of the element
  , inside: function(x, y) {
      var box = this.bbox()

      return x > box.x
          && y > box.y
          && x < box.x + box.width
          && y < box.y + box.height
    }
    // Show element
  , show: function() {
      return this.style('display', '')
    }
    // Hide element
  , hide: function() {
      return this.style('display', 'none')
    }
    // Is element visible?
  , visible: function() {
      return this.style('display') != 'none'
    }
    // Return id on string conversion
  , toString: function() {
      return this.attr('id')
    }
    // Return array of classes on the node
  , classes: function() {
      var attr = this.attr('class')

      return attr == null ? [] : attr.trim().split(/\s+/)
    }
    // Return true if class exists on the node, false otherwise
  , hasClass: function(name) {
      return this.classes().indexOf(name) != -1
    }
    // Add class to the node
  , addClass: function(name) {
      if (!this.hasClass(name)) {
        var array = this.classes()
        array.push(name)
        this.attr('class', array.join(' '))
      }

      return this
    }
    // Remove class from the node
  , removeClass: function(name) {
      if (this.hasClass(name)) {
        this.attr('class', this.classes().filter(function(c) {
          return c != name
        }).join(' '))
      }

      return this
    }
    // Toggle the presence of a class on the node
  , toggleClass: function(name) {
      return this.hasClass(name) ? this.removeClass(name) : this.addClass(name)
    }
    // Get referenced element form attribute value
  , reference: function(attr) {
      return SVG.get(this.attr(attr))
    }
    // Returns the parent element instance
  , parent: function(type) {
      var parent = this

      // check for parent
      if(!parent.node.parentNode) return null

      // get parent element
      parent = SVG.adopt(parent.node.parentNode)

      if(!type) return parent

      // loop trough ancestors if type is given
      while(parent && parent.node instanceof SVGElement){
        if(typeof type === 'string' ? parent.matches(type) : parent instanceof type) return parent
        parent = SVG.adopt(parent.node.parentNode)
      }
    }
    // Get parent document
  , doc: function() {
      return this instanceof SVG.Doc ? this : this.parent(SVG.Doc)
    }
    // return array of all ancestors of given type up to the root svg
  , parents: function(type) {
      var parents = [], parent = this

      do{
        parent = parent.parent(type)
        if(!parent || !parent.node) break

        parents.push(parent)
      } while(parent.parent)

      return parents
    }
    // matches the element vs a css selector
  , matches: function(selector){
      return matches(this.node, selector)
    }
    // Returns the svg node to call native svg methods on it
  , native: function() {
      return this.node
    }
    // Import raw svg
  , svg: function(svg) {
      // create temporary holder
      var well = document.createElement('svg')

      // act as a setter if svg is given
      if (svg && this instanceof SVG.Parent) {
        // dump raw svg
        well.innerHTML = '<svg>' + svg.replace(/\n/, '').replace(/<(\w+)([^<]+?)\/>/g, '<$1$2></$1>') + '</svg>'

        // transplant nodes
        for (var i = 0, il = well.firstChild.childNodes.length; i < il; i++)
          this.node.appendChild(well.firstChild.firstChild)

      // otherwise act as a getter
      } else {
        // create a wrapping svg element in case of partial content
        well.appendChild(svg = document.createElement('svg'))

        // write svgjs data to the dom
        this.writeDataToDom()

        // insert a copy of this node
        svg.appendChild(this.node.cloneNode(true))

        // return target element
        return well.innerHTML.replace(/^<svg>/, '').replace(/<\/svg>$/, '')
      }

      return this
    }
  // write svgjs data to the dom
  , writeDataToDom: function() {

      // dump variables recursively
      if(this.each || this.lines){
        var fn = this.each ? this : this.lines();
        fn.each(function(){
          this.writeDataToDom()
        })
      }

      // remove previously set data
      this.node.removeAttribute('svgjs:data')

      if(Object.keys(this.dom).length)
        this.node.setAttribute('svgjs:data', JSON.stringify(this.dom)) // see #428

      return this
    }
  // set given data to the elements data property
  , setData: function(o){
      this.dom = o
      return this
    }
  , is: function(obj){
      return is(this, obj)
    }
  }
})

SVG.easing = {
  '-': function(pos){return pos}
, '<>':function(pos){return -Math.cos(pos * Math.PI) / 2 + 0.5}
, '>': function(pos){return  Math.sin(pos * Math.PI / 2)}
, '<': function(pos){return -Math.cos(pos * Math.PI / 2) + 1}
}

SVG.morph = function(pos){
  return function(from, to) {
    return new SVG.MorphObj(from, to).at(pos)
  }
}

SVG.Situation = SVG.invent({

  create: function(o){
    this.init = false
    this.reversed = false
    this.reversing = false

    this.duration = new SVG.Number(o.duration).valueOf()
    this.delay = new SVG.Number(o.delay).valueOf()

    this.start = +new Date() + this.delay
    this.finish = this.start + this.duration
    this.ease = o.ease

    // this.loop is incremented from 0 to this.loops
    // it is also incremented when in an infinite loop (when this.loops is true)
    this.loop = 0
    this.loops = false

    this.animations = {
      // functionToCall: [list of morphable objects]
      // e.g. move: [SVG.Number, SVG.Number]
    }

    this.attrs = {
      // holds all attributes which are not represented from a function svg.js provides
      // e.g. someAttr: SVG.Number
    }

    this.styles = {
      // holds all styles which should be animated
      // e.g. fill-color: SVG.Color
    }

    this.transforms = [
      // holds all transformations as transformation objects
      // e.g. [SVG.Rotate, SVG.Translate, SVG.Matrix]
    ]

    this.once = {
      // functions to fire at a specific position
      // e.g. "0.5": function foo(){}
    }

  }

})


SVG.FX = SVG.invent({

  create: function(element) {
    this._target = element
    this.situations = []
    this.active = false
    this.situation = null
    this.paused = false
    this.lastPos = 0
    this.pos = 0
    // The absolute position of an animation is its position in the context of its complete duration (including delay and loops)
    // When performing a delay, absPos is below 0 and when performing a loop, its value is above 1
    this.absPos = 0
    this._speed = 1
  }

, extend: {

    /**
     * sets or returns the target of this animation
     * @param o object || number In case of Object it holds all parameters. In case of number its the duration of the animation
     * @param ease function || string Function which should be used for easing or easing keyword
     * @param delay Number indicating the delay before the animation starts
     * @return target || this
     */
    animate: function(o, ease, delay){

      if(typeof o == 'object'){
        ease = o.ease
        delay = o.delay
        o = o.duration
      }

      var situation = new SVG.Situation({
        duration: o || 1000,
        delay: delay || 0,
        ease: SVG.easing[ease || '-'] || ease
      })

      this.queue(situation)

      return this
    }

    /**
     * sets a delay before the next element of the queue is called
     * @param delay Duration of delay in milliseconds
     * @return this.target()
     */
  , delay: function(delay){
      // The delay is performed by an empty situation with its duration
      // attribute set to the duration of the delay
      var situation = new SVG.Situation({
        duration: delay,
        delay: 0,
        ease: SVG.easing['-']
      })

      return this.queue(situation)
    }

    /**
     * sets or returns the target of this animation
     * @param null || target SVG.Element which should be set as new target
     * @return target || this
     */
  , target: function(target){
      if(target && target instanceof SVG.Element){
        this._target = target
        return this
      }

      return this._target
    }

    // returns the absolute position at a given time
  , timeToAbsPos: function(timestamp){
      return (timestamp - this.situation.start) / (this.situation.duration/this._speed)
    }

    // returns the timestamp from a given absolute positon
  , absPosToTime: function(absPos){
      return this.situation.duration/this._speed * absPos + this.situation.start
    }

    // starts the animationloop
  , startAnimFrame: function(){
      this.stopAnimFrame()
      this.animationFrame = requestAnimationFrame(function(){ this.step() }.bind(this))
    }

    // cancels the animationframe
  , stopAnimFrame: function(){
      cancelAnimationFrame(this.animationFrame)
    }

    // kicks off the animation - only does something when the queue is currently not active and at least one situation is set
  , start: function(){
      // dont start if already started
      if(!this.active && this.situation){
        this.active = true
        this.startCurrent()
      }

      return this
    }

    // start the current situation
  , startCurrent: function(){
      this.situation.start = +new Date + this.situation.delay/this._speed
      this.situation.finish = this.situation.start + this.situation.duration/this._speed
      return this.initAnimations().step()
    }

    /**
     * adds a function / Situation to the animation queue
     * @param fn function / situation to add
     * @return this
     */
  , queue: function(fn){
      if(typeof fn == 'function' || fn instanceof SVG.Situation)
        this.situations.push(fn)

      if(!this.situation) this.situation = this.situations.shift()

      return this
    }

    /**
     * pulls next element from the queue and execute it
     * @return this
     */
  , dequeue: function(){
      // stop current animation
      this.situation && this.situation.stop && this.situation.stop()

      // get next animation from queue
      this.situation = this.situations.shift()

      if(this.situation){
        if(this.situation instanceof SVG.Situation) {
          this.startCurrent()
        } else {
          // If it is not a SVG.Situation, then it is a function, we execute it
          this.situation.call(this)
        }
      }

      return this
    }

    // updates all animations to the current state of the element
    // this is important when one property could be changed from another property
  , initAnimations: function() {
      var i
      var s = this.situation

      if(s.init) return this

      for(i in s.animations){

        if(i == 'viewbox'){
          s.animations[i] = this.target().viewbox().morph(s.animations[i])
        }else{

          // TODO: this is not a clean clone of the array. We may have some unchecked references
          s.animations[i].value = (i == 'plot' ? this.target().array().value : this.target()[i]())

          // sometimes we get back an object and not the real value, fix this
          if(s.animations[i].value.value){
            s.animations[i].value = s.animations[i].value.value
          }

          if(s.animations[i].relative)
            s.animations[i].destination.value = s.animations[i].destination.value + s.animations[i].value

        }

      }

      for(i in s.attrs){
        if(s.attrs[i] instanceof SVG.Color){
          var color = new SVG.Color(this.target().attr(i))
          s.attrs[i].r = color.r
          s.attrs[i].g = color.g
          s.attrs[i].b = color.b
        }else{
          s.attrs[i].value = this.target().attr(i)// + s.attrs[i].value
        }
      }

      for(i in s.styles){
        s.styles[i].value = this.target().style(i)
      }

      s.initialTransformation = this.target().matrixify()

      s.init = true
      return this
    }
  , clearQueue: function(){
      this.situations = []
      return this
    }
  , clearCurrent: function(){
      this.situation = null
      return this
    }
    /** stops the animation immediately
     * @param jumpToEnd A Boolean indicating whether to complete the current animation immediately.
     * @param clearQueue A Boolean indicating whether to remove queued animation as well.
     * @return this
     */
  , stop: function(jumpToEnd, clearQueue){
      if(!this.active) this.start()

      if(clearQueue){
        this.clearQueue()
      }

      this.active = false

      if(jumpToEnd && this.situation){
        this.atEnd()
      }

      this.stopAnimFrame()

      return this.clearCurrent()
    }

    /** resets the element to the state where the current element has started
     * @return this
     */
  , reset: function(){
      if(this.situation){
        var temp = this.situation
        this.stop()
        this.situation = temp
        this.atStart()
      }
      return this
    }

    // Stop the currently-running animation, remove all queued animations, and complete all animations for the element.
  , finish: function(){

      this.stop(true, false)

      while(this.dequeue().situation && this.stop(true, false));

      this.clearQueue().clearCurrent()

      return this
    }

    // set the internal animation pointer at the start position, before any loops, and updates the visualisation
  , atStart: function() {
    return this.at(0, true)
  }

    // set the internal animation pointer at the end position, after all the loops, and updates the visualisation
  , atEnd: function() {
    if (this.situation.loops === true) {
      // If in a infinite loop, we end the current iteration
      return this.at(this.situation.loop+1, true)
    } else if(typeof this.situation.loops == 'number') {
      // If performing a finite number of loops, we go after all the loops
      return this.at(this.situation.loops, true)
    } else {
      // If no loops, we just go at the end
      return this.at(1, true)
    }
  }

    // set the internal animation pointer to the specified position and updates the visualisation
    // if isAbsPos is true, pos is treated as an absolute position
  , at: function(pos, isAbsPos){
      var durDivSpd = this.situation.duration/this._speed

      this.absPos = pos
      // If pos is not an absolute position, we convert it into one
      if (!isAbsPos) {
        if (this.situation.reversed) this.absPos = 1 - this.absPos
        this.absPos += this.situation.loop
      }

      this.situation.start = +new Date - this.absPos * durDivSpd
      this.situation.finish = this.situation.start + durDivSpd

      return this.step(true)
    }

    /**
     * sets or returns the speed of the animations
     * @param speed null || Number The new speed of the animations
     * @return Number || this
     */
  , speed: function(speed){
      if (speed === 0) return this.pause()

      if (speed) {
        this._speed = speed
        // We use an absolute position here so that speed can affect the delay before the animation
        return this.at(this.absPos, true)
      } else return this._speed
    }

    // Make loopable
  , loop: function(times, reverse) {
      var c = this.last()

      // store total loops
      c.loops = (times != null) ? times : true
      c.loop = 0

      if(reverse) c.reversing = true
      return this
    }

    // pauses the animation
  , pause: function(){
      this.paused = true
      this.stopAnimFrame()

      return this
    }

    // unpause the animation
  , play: function(){
      if(!this.paused) return this
      this.paused = false
      // We use an absolute position here so that the delay before the animation can be paused
      return this.at(this.absPos, true)
    }

    /**
     * toggle or set the direction of the animation
     * true sets direction to backwards while false sets it to forwards
     * @param reversed Boolean indicating whether to reverse the animation or not (default: toggle the reverse status)
     * @return this
     */
  , reverse: function(reversed){
      var c = this.last()

      if(typeof reversed == 'undefined') c.reversed = !c.reversed
      else c.reversed = reversed

      return this
    }


    /**
     * returns a float from 0-1 indicating the progress of the current animation
     * @param eased Boolean indicating whether the returned position should be eased or not
     * @return number
     */
  , progress: function(easeIt){
      return easeIt ? this.situation.ease(this.pos) : this.pos
    }

    /**
     * adds a callback function which is called when the current animation is finished
     * @param fn Function which should be executed as callback
     * @return number
     */
  , after: function(fn){
      var c = this.last()
        , wrapper = function wrapper(e){
            if(e.detail.situation == c){
              fn.call(this, c)
              this.off('finished.fx', wrapper) // prevent memory leak
            }
          }

      this.target().on('finished.fx', wrapper)
      return this
    }

    // adds a callback which is called whenever one animation step is performed
  , during: function(fn){
      var c = this.last()
        , wrapper = function(e){
            if(e.detail.situation == c){
              fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, c)
            }
          }

      // see above
      this.target().off('during.fx', wrapper).on('during.fx', wrapper)

      return this.after(function(){
        this.off('during.fx', wrapper)
      })
    }

    // calls after ALL animations in the queue are finished
  , afterAll: function(fn){
      var wrapper = function wrapper(e){
            fn.call(this)
            this.off('allfinished.fx', wrapper)
          }

      // see above
      this.target().off('allfinished.fx', wrapper).on('allfinished.fx', wrapper)
      return this
    }

    // calls on every animation step for all animations
  , duringAll: function(fn){
      var wrapper = function(e){
            fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, e.detail.situation)
          }

      this.target().off('during.fx', wrapper).on('during.fx', wrapper)

      return this.afterAll(function(){
        this.off('during.fx', wrapper)
      })
    }

  , last: function(){
      return this.situations.length ? this.situations[this.situations.length-1] : this.situation
    }

    // adds one property to the animations
  , add: function(method, args, type){
      this.last()[type || 'animations'][method] = args
      setTimeout(function(){this.start()}.bind(this), 0)
      return this
    }

    /** perform one step of the animation
     *  @param ignoreTime Boolean indicating whether to ignore time and use position directly or recalculate position based on time
     *  @return this
     */
  , step: function(ignoreTime){

      // convert current time to an absolute position
      if(!ignoreTime) this.absPos = this.timeToAbsPos(+new Date)

      // This part convert an absolute position to a position
      if(this.situation.loops !== false) {
        var absPos, absPosInt, lastLoop

        // If the absolute position is below 0, we just treat it as if it was 0
        absPos = Math.max(this.absPos, 0)
        absPosInt = Math.floor(absPos)

        if(this.situation.loops === true || absPosInt < this.situation.loops) {
          this.pos = absPos - absPosInt
          lastLoop = this.situation.loop
          this.situation.loop = absPosInt
        } else {
          this.absPos = this.situation.loops
          this.pos = 1
          // The -1 here is because we don't want to toggle reversed when all the loops have been completed
          lastLoop = this.situation.loop - 1
          this.situation.loop = this.situation.loops
        }

        if(this.situation.reversing) {
          // Toggle reversed if an odd number of loops as occured since the last call of step
          this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - lastLoop) % 2)
        }

      } else {
        // If there are no loop, the absolute position must not be above 1
        this.absPos = Math.min(this.absPos, 1)
        this.pos = this.absPos
      }

      // while the absolute position can be below 0, the position must not be below 0
      if(this.pos < 0) this.pos = 0

      if(this.situation.reversed) this.pos = 1 - this.pos


      // apply easing
      var eased = this.situation.ease(this.pos)

      // call once-callbacks
      for(var i in this.situation.once){
        if(i > this.lastPos && i <= eased){
          this.situation.once[i].call(this.target(), this.pos, eased)
          delete this.situation.once[i]
        }
      }

      // fire during callback with position, eased position and current situation as parameter
      if(this.active) this.target().fire('during', {pos: this.pos, eased: eased, fx: this, situation: this.situation})

      // the user may call stop or finish in the during callback
      // so make sure that we still have a valid situation
      if(!this.situation){
        return this
      }

      // apply the actual animation to every property
      this.eachAt()

      // do final code when situation is finished
      if((this.pos == 1 && !this.situation.reversed) || (this.situation.reversed && this.pos == 0)){

        // stop animation callback
        this.stopAnimFrame()

        // fire finished callback with current situation as parameter
        this.target().fire('finished', {fx:this, situation: this.situation})

        if(!this.situations.length){
          this.target().fire('allfinished')
          this.target().off('.fx') // there shouldnt be any binding left, but to make sure...
          this.active = false
        }

        // start next animation
        if(this.active) this.dequeue()
        else this.clearCurrent()

      }else if(!this.paused && this.active){
        // we continue animating when we are not at the end
        this.startAnimFrame()
      }

      // save last eased position for once callback triggering
      this.lastPos = eased
      return this

    }

    // calculates the step for every property and calls block with it
  , eachAt: function(){
      var i, at, self = this, target = this.target(), s = this.situation

      // apply animations which can be called trough a method
      for(i in s.animations){

        at = [].concat(s.animations[i]).map(function(el){
          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el
        })

        target[i].apply(target, at)

      }

      // apply animation which has to be applied with attr()
      for(i in s.attrs){

        at = [i].concat(s.attrs[i]).map(function(el){
          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el
        })

        target.attr.apply(target, at)

      }

      // apply animation which has to be applied with style()
      for(i in s.styles){

        at = [i].concat(s.styles[i]).map(function(el){
          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el
        })

        target.style.apply(target, at)

      }

      // animate initialTransformation which has to be chained
      if(s.transforms.length){

        // get initial initialTransformation
        at = s.initialTransformation
        for(i = 0, len = s.transforms.length; i < len; i++){

          // get next transformation in chain
          var a = s.transforms[i]

          // multiply matrix directly
          if(a instanceof SVG.Matrix){

            if(a.relative){
              at = at.multiply(new SVG.Matrix().morph(a).at(s.ease(this.pos)))
            }else{
              at = at.morph(a).at(s.ease(this.pos))
            }
            continue
          }

          // when transformation is absolute we have to reset the needed transformation first
          if(!a.relative)
            a.undo(at.extract())

          // and reapply it after
          at = at.multiply(a.at(s.ease(this.pos)))

        }

        // set new matrix on element
        target.matrix(at)
      }

      return this

    }


    // adds an once-callback which is called at a specific position and never again
  , once: function(pos, fn, isEased){

      if(!isEased)pos = this.situation.ease(pos)

      this.situation.once[pos] = fn

      return this
    }

  }

, parent: SVG.Element

  // Add method to parent elements
, construct: {
    // Get fx module or create a new one, then animate with given duration and ease
    animate: function(o, ease, delay) {
      return (this.fx || (this.fx = new SVG.FX(this))).animate(o, ease, delay)
    }
  , delay: function(delay){
      return (this.fx || (this.fx = new SVG.FX(this))).delay(delay)
    }
  , stop: function(jumpToEnd, clearQueue) {
      if (this.fx)
        this.fx.stop(jumpToEnd, clearQueue)

      return this
    }
  , finish: function() {
      if (this.fx)
        this.fx.finish()

      return this
    }
    // Pause current animation
  , pause: function() {
      if (this.fx)
        this.fx.pause()

      return this
    }
    // Play paused current animation
  , play: function() {
      if (this.fx)
        this.fx.play()

      return this
    }
    // Set/Get the speed of the animations
  , speed: function(speed) {
      if (this.fx)
        if (speed == null)
          return this.fx.speed()
        else
          this.fx.speed(speed)

      return this
    }
  }

})

// MorphObj is used whenever no morphable object is given
SVG.MorphObj = SVG.invent({

  create: function(from, to){
    // prepare color for morphing
    if(SVG.Color.isColor(to)) return new SVG.Color(from).morph(to)
    // prepare number for morphing
    if(SVG.regex.numberAndUnit.test(to)) return new SVG.Number(from).morph(to)

    // prepare for plain morphing
    this.value = 0
    this.destination = to
  }

, extend: {
    at: function(pos, real){
      return real < 1 ? this.value : this.destination
    },

    valueOf: function(){
      return this.value
    }
  }

})

SVG.extend(SVG.FX, {
  // Add animatable attributes
  attr: function(a, v, relative) {
    // apply attributes individually
    if (typeof a == 'object') {
      for (var key in a)
        this.attr(key, a[key])

    } else {
      // the MorphObj takes care about the right function used
      this.add(a, new SVG.MorphObj(null, v), 'attrs')
    }

    return this
  }
  // Add animatable styles
, style: function(s, v) {
    if (typeof s == 'object')
      for (var key in s)
        this.style(key, s[key])

    else
      this.add(s, new SVG.MorphObj(null, v), 'styles')

    return this
  }
  // Animatable x-axis
, x: function(x, relative) {
    if(this.target() instanceof SVG.G){
      this.transform({x:x}, relative)
      return this
    }

    var num = new SVG.Number().morph(x)
    num.relative = relative
    return this.add('x', num)
  }
  // Animatable y-axis
, y: function(y, relative) {
    if(this.target() instanceof SVG.G){
      this.transform({y:y}, relative)
      return this
    }

    var num = new SVG.Number().morph(y)
    num.relative = relative
    return this.add('y', num)
  }
  // Animatable center x-axis
, cx: function(x) {
    return this.add('cx', new SVG.Number().morph(x))
  }
  // Animatable center y-axis
, cy: function(y) {
    return this.add('cy', new SVG.Number().morph(y))
  }
  // Add animatable move
, move: function(x, y) {
    return this.x(x).y(y)
  }
  // Add animatable center
, center: function(x, y) {
    return this.cx(x).cy(y)
  }
  // Add animatable size
, size: function(width, height) {
    if (this.target() instanceof SVG.Text) {
      // animate font size for Text elements
      this.attr('font-size', width)

    } else {
      // animate bbox based size for all other elements
      var box

      if(!width || !height){
        box = this.target().bbox()
      }

      if(!width){
        width = box.width / box.height  * height
      }

      if(!height){
        height = box.height / box.width  * width
      }

      this.add('width' , new SVG.Number().morph(width))
          .add('height', new SVG.Number().morph(height))

    }

    return this
  }
  // Add animatable plot
, plot: function(p) {
    return this.add('plot', this.target().array().morph(p))
  }
  // Add leading method
, leading: function(value) {
    return this.target().leading ?
      this.add('leading', new SVG.Number().morph(value)) :
      this
  }
  // Add animatable viewbox
, viewbox: function(x, y, width, height) {
    if (this.target() instanceof SVG.Container) {
      this.add('viewbox', new SVG.ViewBox(x, y, width, height))
    }

    return this
  }
, update: function(o) {
    if (this.target() instanceof SVG.Stop) {
      if (typeof o == 'number' || o instanceof SVG.Number) {
        return this.update({
          offset:  arguments[0]
        , color:   arguments[1]
        , opacity: arguments[2]
        })
      }

      if (o.opacity != null) this.attr('stop-opacity', o.opacity)
      if (o.color   != null) this.attr('stop-color', o.color)
      if (o.offset  != null) this.attr('offset', o.offset)
    }

    return this
  }
})

SVG.BBox = SVG.invent({
  // Initialize
  create: function(element) {
    // get values if element is given
    if (element) {
      var box

      // yes this is ugly, but Firefox can be a bitch when it comes to elements that are not yet rendered
      try {

        // the element is NOT in the dom, throw error
        if(!document.documentElement.contains(element.node)) throw new Exception('Element not in the dom')

        // find native bbox
        box = element.node.getBBox()
      } catch(e) {
        if(element instanceof SVG.Shape){
          var clone = element.clone(SVG.parser.draw).show()
          box = clone.bbox()
          clone.remove()
        }else{
          box = {
            x:      element.node.clientLeft
          , y:      element.node.clientTop
          , width:  element.node.clientWidth
          , height: element.node.clientHeight
          }
        }
      }

      // plain x and y
      this.x = box.x
      this.y = box.y

      // plain width and height
      this.width  = box.width
      this.height = box.height
    }

    // add center, right and bottom
    fullBox(this)
  }

  // Define Parent
, parent: SVG.Element

  // Constructor
, construct: {
    // Get bounding box
    bbox: function() {
      return new SVG.BBox(this)
    }
  }

})

SVG.TBox = SVG.invent({
  // Initialize
  create: function(element) {
    // get values if element is given
    if (element) {
      var t   = element.ctm().extract()
        , box = element.bbox()

      // width and height including transformations
      this.width  = box.width  * t.scaleX
      this.height = box.height * t.scaleY

      // x and y including transformations
      this.x = box.x + t.x
      this.y = box.y + t.y
    }

    // add center, right and bottom
    fullBox(this)
  }

  // Define Parent
, parent: SVG.Element

  // Constructor
, construct: {
    // Get transformed bounding box
    tbox: function() {
      return new SVG.TBox(this)
    }
  }

})


SVG.RBox = SVG.invent({
  // Initialize
  create: function(element) {
    if (element) {
      var e    = element.doc().parent()
        , box  = element.node.getBoundingClientRect()
        , zoom = 1

      // get screen offset
      this.x = box.left
      this.y = box.top

      // subtract parent offset
      this.x -= e.offsetLeft
      this.y -= e.offsetTop

      while (e = e.offsetParent) {
        this.x -= e.offsetLeft
        this.y -= e.offsetTop
      }

      // calculate cumulative zoom from svg documents
      e = element
      while (e.parent && (e = e.parent())) {
        if (e.viewbox) {
          zoom *= e.viewbox().zoom
          this.x -= e.x() || 0
          this.y -= e.y() || 0
        }
      }

      // recalculate viewbox distortion
      this.width  = box.width  /= zoom
      this.height = box.height /= zoom
    }

    // add center, right and bottom
    fullBox(this)

    // offset by window scroll position, because getBoundingClientRect changes when window is scrolled
    this.x += window.pageXOffset
    this.y += window.pageYOffset
  }

  // define Parent
, parent: SVG.Element

  // Constructor
, construct: {
    // Get rect box
    rbox: function() {
      return new SVG.RBox(this)
    }
  }

})

// Add universal merge method
;[SVG.BBox, SVG.TBox, SVG.RBox].forEach(function(c) {

  SVG.extend(c, {
    // Merge rect box with another, return a new instance
    merge: function(box) {
      var b = new c()

      // merge boxes
      b.x      = Math.min(this.x, box.x)
      b.y      = Math.min(this.y, box.y)
      b.width  = Math.max(this.x + this.width,  box.x + box.width)  - b.x
      b.height = Math.max(this.y + this.height, box.y + box.height) - b.y

      return fullBox(b)
    }

  })

})

SVG.Matrix = SVG.invent({
  // Initialize
  create: function(source) {
    var i, base = arrayToMatrix([1, 0, 0, 1, 0, 0])

    // ensure source as object
    source = source instanceof SVG.Element ?
      source.matrixify() :
    typeof source === 'string' ?
      stringToMatrix(source) :
    arguments.length == 6 ?
      arrayToMatrix([].slice.call(arguments)) :
    typeof source === 'object' ?
      source : base

    // merge source
    for (i = abcdef.length - 1; i >= 0; --i)
      this[abcdef[i]] = source && typeof source[abcdef[i]] === 'number' ?
        source[abcdef[i]] : base[abcdef[i]]
  }

  // Add methods
, extend: {
    // Extract individual transformations
    extract: function() {
      // find delta transform points
      var px    = deltaTransformPoint(this, 0, 1)
        , py    = deltaTransformPoint(this, 1, 0)
        , skewX = 180 / Math.PI * Math.atan2(px.y, px.x) - 90

      return {
        // translation
        x:        this.e
      , y:        this.f
      , transformedX:(this.e * Math.cos(skewX * Math.PI / 180) + this.f * Math.sin(skewX * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b)
      , transformedY:(this.f * Math.cos(skewX * Math.PI / 180) + this.e * Math.sin(-skewX * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d)
        // skew
      , skewX:    -skewX
      , skewY:    180 / Math.PI * Math.atan2(py.y, py.x)
        // scale
      , scaleX:   Math.sqrt(this.a * this.a + this.b * this.b)
      , scaleY:   Math.sqrt(this.c * this.c + this.d * this.d)
        // rotation
      , rotation: skewX
      , a: this.a
      , b: this.b
      , c: this.c
      , d: this.d
      , e: this.e
      , f: this.f
      , matrix: new SVG.Matrix(this)
      }
    }
    // Clone matrix
  , clone: function() {
      return new SVG.Matrix(this)
    }
    // Morph one matrix into another
  , morph: function(matrix) {
      // store new destination
      this.destination = new SVG.Matrix(matrix)

      return this
    }
    // Get morphed matrix at a given position
  , at: function(pos) {
      // make sure a destination is defined
      if (!this.destination) return this

      // calculate morphed matrix at a given position
      var matrix = new SVG.Matrix({
        a: this.a + (this.destination.a - this.a) * pos
      , b: this.b + (this.destination.b - this.b) * pos
      , c: this.c + (this.destination.c - this.c) * pos
      , d: this.d + (this.destination.d - this.d) * pos
      , e: this.e + (this.destination.e - this.e) * pos
      , f: this.f + (this.destination.f - this.f) * pos
      })

      // process parametric rotation if present
      if (this.param && this.param.to) {
        // calculate current parametric position
        var param = {
          rotation: this.param.from.rotation + (this.param.to.rotation - this.param.from.rotation) * pos
        , cx:       this.param.from.cx
        , cy:       this.param.from.cy
        }

        // rotate matrix
        matrix = matrix.rotate(
          (this.param.to.rotation - this.param.from.rotation * 2) * pos
        , param.cx
        , param.cy
        )

        // store current parametric values
        matrix.param = param
      }

      return matrix
    }
    // Multiplies by given matrix
  , multiply: function(matrix) {
      return new SVG.Matrix(this.native().multiply(parseMatrix(matrix).native()))
    }
    // Inverses matrix
  , inverse: function() {
      return new SVG.Matrix(this.native().inverse())
    }
    // Translate matrix
  , translate: function(x, y) {
      return new SVG.Matrix(this.native().translate(x || 0, y || 0))
    }
    // Scale matrix
  , scale: function(x, y, cx, cy) {
      // support uniformal scale
      if (arguments.length == 1) {
        y = x
      } else if (arguments.length == 3) {
        cy = cx
        cx = y
        y = x
      }

      return this.around(cx, cy, new SVG.Matrix(x, 0, 0, y, 0, 0))
    }
    // Rotate matrix
  , rotate: function(r, cx, cy) {
      // convert degrees to radians
      r = SVG.utils.radians(r)

      return this.around(cx, cy, new SVG.Matrix(Math.cos(r), Math.sin(r), -Math.sin(r), Math.cos(r), 0, 0))
    }
    // Flip matrix on x or y, at a given offset
  , flip: function(a, o) {
      return a == 'x' ? this.scale(-1, 1, o, 0) : this.scale(1, -1, 0, o)
    }
    // Skew
  , skew: function(x, y, cx, cy) {
      // support uniformal skew
      if (arguments.length == 1) {
        y = x
      } else if (arguments.length == 3) {
        cy = cx
        cx = y
        y = x
      }

      // convert degrees to radians
      x = SVG.utils.radians(x)
      y = SVG.utils.radians(y)

      return this.around(cx, cy, new SVG.Matrix(1, Math.tan(y), Math.tan(x), 1, 0, 0))
    }
    // SkewX
  , skewX: function(x, cx, cy) {
      return this.skew(x, 0, cx, cy)
    }
    // SkewY
  , skewY: function(y, cx, cy) {
      return this.skew(0, y, cx, cy)
    }
    // Transform around a center point
  , around: function(cx, cy, matrix) {
      return this
        .multiply(new SVG.Matrix(1, 0, 0, 1, cx || 0, cy || 0))
        .multiply(matrix)
        .multiply(new SVG.Matrix(1, 0, 0, 1, -cx || 0, -cy || 0))
    }
    // Convert to native SVGMatrix
  , native: function() {
      // create new matrix
      var matrix = SVG.parser.native.createSVGMatrix()

      // update with current values
      for (var i = abcdef.length - 1; i >= 0; i--)
        matrix[abcdef[i]] = this[abcdef[i]]

      return matrix
    }
    // Convert matrix to string
  , toString: function() {
      return 'matrix(' + this.a + ',' + this.b + ',' + this.c + ',' + this.d + ',' + this.e + ',' + this.f + ')'
    }
  }

  // Define parent
, parent: SVG.Element

  // Add parent method
, construct: {
    // Get current matrix
    ctm: function() {
      return new SVG.Matrix(this.node.getCTM())
    },
    // Get current screen matrix
    screenCTM: function() {
      return new SVG.Matrix(this.node.getScreenCTM())
    }

  }

})

SVG.Point = SVG.invent({
  // Initialize
  create: function(x,y) {
    var i, source, base = {x:0, y:0}

    // ensure source as object
    source = Array.isArray(x) ?
      {x:x[0], y:x[1]} :
    typeof x === 'object' ?
      {x:x.x, y:x.y} :
    x != null ?
      {x:x, y:(y != null ? y : x)} : base // If y has no value, then x is used has its value

    // merge source
    this.x = source.x
    this.y = source.y
  }

  // Add methods
, extend: {
    // Clone point
    clone: function() {
      return new SVG.Point(this)
    }
    // Morph one point into another
  , morph: function(x, y) {
      // store new destination
      this.destination = new SVG.Point(x, y)

      return this
    }
    // Get morphed point at a given position
  , at: function(pos) {
      // make sure a destination is defined
      if (!this.destination) return this

      // calculate morphed matrix at a given position
      var point = new SVG.Point({
        x: this.x + (this.destination.x - this.x) * pos
      , y: this.y + (this.destination.y - this.y) * pos
      })

      return point
    }
    // Convert to native SVGPoint
  , native: function() {
      // create new point
      var point = SVG.parser.native.createSVGPoint()

      // update with current values
      point.x = this.x
      point.y = this.y

      return point
    }
    // transform point with matrix
  , transform: function(matrix) {
      return new SVG.Point(this.native().matrixTransform(matrix.native()))
    }

  }

})

SVG.extend(SVG.Element, {

  // Get point
  point: function(x, y) {
    return new SVG.Point(x,y).transform(this.screenCTM().inverse());
  }

})

SVG.extend(SVG.Element, {
  // Set svg element attribute
  attr: function(a, v, n) {
    // act as full getter
    if (a == null) {
      // get an object of attributes
      a = {}
      v = this.node.attributes
      for (n = v.length - 1; n >= 0; n--)
        a[v[n].nodeName] = SVG.regex.isNumber.test(v[n].nodeValue) ? parseFloat(v[n].nodeValue) : v[n].nodeValue

      return a

    } else if (typeof a == 'object') {
      // apply every attribute individually if an object is passed
      for (v in a) this.attr(v, a[v])

    } else if (v === null) {
        // remove value
        this.node.removeAttribute(a)

    } else if (v == null) {
      // act as a getter if the first and only argument is not an object
      v = this.node.getAttribute(a)
      return v == null ?
        SVG.defaults.attrs[a] :
      SVG.regex.isNumber.test(v) ?
        parseFloat(v) : v

    } else {
      // BUG FIX: some browsers will render a stroke if a color is given even though stroke width is 0
      if (a == 'stroke-width')
        this.attr('stroke', parseFloat(v) > 0 ? this._stroke : null)
      else if (a == 'stroke')
        this._stroke = v

      // convert image fill and stroke to patterns
      if (a == 'fill' || a == 'stroke') {
        if (SVG.regex.isImage.test(v))
          v = this.doc().defs().image(v, 0, 0)

        if (v instanceof SVG.Image)
          v = this.doc().defs().pattern(0, 0, function() {
            this.add(v)
          })
      }

      // ensure correct numeric values (also accepts NaN and Infinity)
      if (typeof v === 'number')
        v = new SVG.Number(v)

      // ensure full hex color
      else if (SVG.Color.isColor(v))
        v = new SVG.Color(v)

      // parse array values
      else if (Array.isArray(v))
        v = new SVG.Array(v)

      // store parametric transformation values locally
      else if (v instanceof SVG.Matrix && v.param)
        this.param = v.param

      // if the passed attribute is leading...
      if (a == 'leading') {
        // ... call the leading method instead
        if (this.leading)
          this.leading(v)
      } else {
        // set given attribute on node
        typeof n === 'string' ?
          this.node.setAttributeNS(n, a, v.toString()) :
          this.node.setAttribute(a, v.toString())
      }

      // rebuild if required
      if (this.rebuild && (a == 'font-size' || a == 'x'))
        this.rebuild(a, v)
    }

    return this
  }
})
SVG.extend(SVG.Element, {
  // Add transformations
  transform: function(o, relative) {
    // get target in case of the fx module, otherwise reference this
    var target = this
      , matrix

    // act as a getter
    if (typeof o !== 'object') {
      // get current matrix
      matrix = new SVG.Matrix(target).extract()

      return typeof o === 'string' ? matrix[o] : matrix
    }

    // get current matrix
    matrix = new SVG.Matrix(target)

    // ensure relative flag
    relative = !!relative || !!o.relative

    // act on matrix
    if (o.a != null) {
      matrix = relative ?
        // relative
        matrix.multiply(new SVG.Matrix(o)) :
        // absolute
        new SVG.Matrix(o)

    // act on rotation
    } else if (o.rotation != null) {
      // ensure centre point
      ensureCentre(o, target)

      // apply transformation
      matrix = relative ?
        // relative
        matrix.rotate(o.rotation, o.cx, o.cy) :
        // absolute
        matrix.rotate(o.rotation - matrix.extract().rotation, o.cx, o.cy)

    // act on scale
    } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {
      // ensure centre point
      ensureCentre(o, target)

      // ensure scale values on both axes
      o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1
      o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1

      if (!relative) {
        // absolute; multiply inversed values
        var e = matrix.extract()
        o.scaleX = o.scaleX * 1 / e.scaleX
        o.scaleY = o.scaleY * 1 / e.scaleY
      }

      matrix = matrix.scale(o.scaleX, o.scaleY, o.cx, o.cy)

    // act on skew
    } else if (o.skew != null || o.skewX != null || o.skewY != null) {
      // ensure centre point
      ensureCentre(o, target)

      // ensure skew values on both axes
      o.skewX = o.skew != null ? o.skew : o.skewX != null ? o.skewX : 0
      o.skewY = o.skew != null ? o.skew : o.skewY != null ? o.skewY : 0

      if (!relative) {
        // absolute; reset skew values
        var e = matrix.extract()
        matrix = matrix.multiply(new SVG.Matrix().skew(e.skewX, e.skewY, o.cx, o.cy).inverse())
      }

      matrix = matrix.skew(o.skewX, o.skewY, o.cx, o.cy)

    // act on flip
    } else if (o.flip) {
      matrix = matrix.flip(
        o.flip
      , o.offset == null ? target.bbox()['c' + o.flip] : o.offset
      )

    // act on translate
    } else if (o.x != null || o.y != null) {
      if (relative) {
        // relative
        matrix = matrix.translate(o.x, o.y)
      } else {
        // absolute
        if (o.x != null) matrix.e = o.x
        if (o.y != null) matrix.f = o.y
      }
    }

    return this.attr('transform', matrix)
  }
})

SVG.extend(SVG.FX, {
  transform: function(o, relative) {
    // get target in case of the fx module, otherwise reference this
    var target = this.target()
      , matrix

    // act as a getter
    if (typeof o !== 'object') {
      // get current matrix
      matrix = new SVG.Matrix(target).extract()

      return typeof o === 'string' ? matrix[o] : matrix
    }

    // ensure relative flag
    relative = !!relative || !!o.relative

    // act on matrix
    if (o.a != null) {
      matrix = new SVG.Matrix(o)

    // act on rotation
    } else if (o.rotation != null) {
      // ensure centre point
      ensureCentre(o, target)

      // apply transformation
      matrix = new SVG.Rotate(o.rotation, o.cx, o.cy)

    // act on scale
    } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {
      // ensure centre point
      ensureCentre(o, target)

      // ensure scale values on both axes
      o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1
      o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1

      matrix = new SVG.Scale(o.scaleX, o.scaleY, o.cx, o.cy)

    // act on skew
    } else if (o.skewX != null || o.skewY != null) {
      // ensure centre point
      ensureCentre(o, target)

      // ensure skew values on both axes
      o.skewX = o.skewX != null ? o.skewX : 0
      o.skewY = o.skewY != null ? o.skewY : 0

      matrix = new SVG.Skew(o.skewX, o.skewY, o.cx, o.cy)

    // act on flip
    } else if (o.flip) {
      matrix = new SVG.Matrix().morph(new SVG.Matrix().flip(
        o.flip
      , o.offset == null ? target.bbox()['c' + o.flip] : o.offset
      ))

    // act on translate
    } else if (o.x != null || o.y != null) {
      matrix = new SVG.Translate(o.x, o.y)
    }

    if(!matrix) return this

    matrix.relative = relative

    this.last().transforms.push(matrix)

    setTimeout(function(){this.start()}.bind(this), 0)

    return this
  }
})

SVG.extend(SVG.Element, {
  // Reset all transformations
  untransform: function() {
    return this.attr('transform', null)
  },
  // merge the whole transformation chain into one matrix and returns it
  matrixify: function() {

    var matrix = (this.attr('transform') || '')
      // split transformations
      .split(/\)\s*,?\s*/).slice(0,-1).map(function(str){
        // generate key => value pairs
        var kv = str.trim().split('(')
        return [kv[0], kv[1].split(SVG.regex.matrixElements).map(function(str){ return parseFloat(str) })]
      })
      // calculate every transformation into one matrix
      .reduce(function(matrix, transform){

        if(transform[0] == 'matrix') return matrix.multiply(arrayToMatrix(transform[1]))
        return matrix[transform[0]].apply(matrix, transform[1])

      }, new SVG.Matrix())

    return matrix
  },
  // add an element to another parent without changing the visual representation on the screen
  toParent: function(parent) {
    if(this == parent) return this
    var ctm = this.screenCTM()
    var temp = parent.rect(1,1)
    var pCtm = temp.screenCTM().inverse()
    temp.remove()

    this.addTo(parent).untransform().transform(pCtm.multiply(ctm))

    return this
  },
  // same as above with parent equals root-svg
  toDoc: function() {
    return this.toParent(this.doc())
  }

})

SVG.Transformation = SVG.invent({

  create: function(source, inversed){

    if(arguments.length > 1 && typeof inversed != 'boolean'){
      return this.create([].slice.call(arguments))
    }

    if(typeof source == 'object'){
      for(var i = 0, len = this.arguments.length; i < len; ++i){
        this[this.arguments[i]] = source[this.arguments[i]]
      }
    }

    if(Array.isArray(source)){
      for(var i = 0, len = this.arguments.length; i < len; ++i){
        this[this.arguments[i]] = source[i]
      }
    }

    this.inversed = false

    if(inversed === true){
      this.inversed = true
    }

  }

, extend: {

    at: function(pos){

      var params = []

      for(var i = 0, len = this.arguments.length; i < len; ++i){
        params.push(this[this.arguments[i]])
      }

      var m = this._undo || new SVG.Matrix()

      m = new SVG.Matrix().morph(SVG.Matrix.prototype[this.method].apply(m, params)).at(pos)

      return this.inversed ? m.inverse() : m

    }

  , undo: function(o){
      for(var i = 0, len = this.arguments.length; i < len; ++i){
        o[this.arguments[i]] = typeof this[this.arguments[i]] == 'undefined' ? 0 : o[this.arguments[i]]
      }

      // The method SVG.Matrix.extract which was used before calling this
      // method to obtain a value for the parameter o doesn't return a cx and
      // a cy so we use the ones that were provided to this object at its creation
      o.cx = this.cx
      o.cy = this.cy

      this._undo = new SVG[capitalize(this.method)](o, true).at(1)

      return this
    }

  }

})

SVG.Translate = SVG.invent({

  parent: SVG.Matrix
, inherit: SVG.Transformation

, create: function(source, inversed){
    if(typeof source == 'object') this.constructor.call(this, source, inversed)
    else this.constructor.call(this, [].slice.call(arguments))
  }

, extend: {
    arguments: ['transformedX', 'transformedY']
  , method: 'translate'
  }

})

SVG.Rotate = SVG.invent({

  parent: SVG.Matrix
, inherit: SVG.Transformation

, create: function(source, inversed){
    if(typeof source == 'object') this.constructor.call(this, source, inversed)
    else this.constructor.call(this, [].slice.call(arguments))
  }

, extend: {
    arguments: ['rotation', 'cx', 'cy']
  , method: 'rotate'
  , at: function(pos){
      var m = new SVG.Matrix().rotate(new SVG.Number().morph(this.rotation - (this._undo ? this._undo.rotation : 0)).at(pos), this.cx, this.cy)
      return this.inversed ? m.inverse() : m
    }
  , undo: function(o){
      this._undo = o
    }
  }

})

SVG.Scale = SVG.invent({

  parent: SVG.Matrix
, inherit: SVG.Transformation

, create: function(source, inversed){
    if(typeof source == 'object') this.constructor.call(this, source, inversed)
    else this.constructor.call(this, [].slice.call(arguments))
  }

, extend: {
    arguments: ['scaleX', 'scaleY', 'cx', 'cy']
  , method: 'scale'
  }

})

SVG.Skew = SVG.invent({

  parent: SVG.Matrix
, inherit: SVG.Transformation

, create: function(source, inversed){
    if(typeof source == 'object') this.constructor.call(this, source, inversed)
    else this.constructor.call(this, [].slice.call(arguments))
  }

, extend: {
    arguments: ['skewX', 'skewY', 'cx', 'cy']
  , method: 'skew'
  }

})

SVG.extend(SVG.Element, {
  // Dynamic style generator
  style: function(s, v) {
    if (arguments.length == 0) {
      // get full style
      return this.node.style.cssText || ''

    } else if (arguments.length < 2) {
      // apply every style individually if an object is passed
      if (typeof s == 'object') {
        for (v in s) this.style(v, s[v])

      } else if (SVG.regex.isCss.test(s)) {
        // parse css string
        s = s.split(';')

        // apply every definition individually
        for (var i = 0; i < s.length; i++) {
          v = s[i].split(':')
          this.style(v[0].replace(/\s+/g, ''), v[1])
        }
      } else {
        // act as a getter if the first and only argument is not an object
        return this.node.style[camelCase(s)]
      }

    } else {
      this.node.style[camelCase(s)] = v === null || SVG.regex.isBlank.test(v) ? '' : v
    }

    return this
  }
})
SVG.Parent = SVG.invent({
  // Initialize node
  create: function(element) {
    this.constructor.call(this, element)
  }

  // Inherit from
, inherit: SVG.Element

  // Add class methods
, extend: {
    // Returns all child elements
    children: function() {
      return SVG.utils.map(SVG.utils.filterSVGElements(this.node.childNodes), function(node) {
        return SVG.adopt(node)
      })
    }
    // Add given element at a position
  , add: function(element, i) {
      if (i == null)
        this.node.appendChild(element.node)
      else if (element.node != this.node.childNodes[i])
        this.node.insertBefore(element.node, this.node.childNodes[i])

      return this
    }
    // Basically does the same as `add()` but returns the added element instead
  , put: function(element, i) {
      this.add(element, i)
      return element
    }
    // Checks if the given element is a child
  , has: function(element) {
      return this.index(element) >= 0
    }
    // Gets index of given element
  , index: function(element) {
      return [].slice.call(this.node.childNodes).indexOf(element.node)
    }
    // Get a element at the given index
  , get: function(i) {
      return SVG.adopt(this.node.childNodes[i])
    }
    // Get first child
  , first: function() {
      return this.get(0)
    }
    // Get the last child
  , last: function() {
      return this.get(this.node.childNodes.length - 1)
    }
    // Iterates over all children and invokes a given block
  , each: function(block, deep) {
      var i, il
        , children = this.children()

      for (i = 0, il = children.length; i < il; i++) {
        if (children[i] instanceof SVG.Element)
          block.apply(children[i], [i, children])

        if (deep && (children[i] instanceof SVG.Container))
          children[i].each(block, deep)
      }

      return this
    }
    // Remove a given child
  , removeElement: function(element) {
      this.node.removeChild(element.node)

      return this
    }
    // Remove all elements in this container
  , clear: function() {
      // remove children
      while(this.node.hasChildNodes())
        this.node.removeChild(this.node.lastChild)

      // remove defs reference
      delete this._defs

      return this
    }
  , // Get defs
    defs: function() {
      return this.doc().defs()
    }
  }

})

SVG.extend(SVG.Parent, {

  ungroup: function(parent, depth) {
    if(depth === 0 || this instanceof SVG.Defs) return this

    parent = parent || (this instanceof SVG.Doc ? this : this.parent(SVG.Parent))
    depth = depth || Infinity

    this.each(function(){
      if(this instanceof SVG.Defs) return this
      if(this instanceof SVG.Parent) return this.ungroup(parent, depth-1)
      return this.toParent(parent)
    })

    this.node.firstChild || this.remove()

    return this
  },

  flatten: function(parent, depth) {
    return this.ungroup(parent, depth)
  }

})
SVG.Container = SVG.invent({
  // Initialize node
  create: function(element) {
    this.constructor.call(this, element)
  }

  // Inherit from
, inherit: SVG.Parent

})

SVG.ViewBox = SVG.invent({

  create: function(source) {
    var i, base = [0, 0, 0, 0]

    var x, y, width, height, box, view, we, he
      , wm   = 1 // width multiplier
      , hm   = 1 // height multiplier
      , reg  = /[+-]?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?/gi

    if(source instanceof SVG.Element){

      we = source
      he = source
      view = (source.attr('viewBox') || '').match(reg)
      box = source.bbox

      // get dimensions of current node
      width  = new SVG.Number(source.width())
      height = new SVG.Number(source.height())

      // find nearest non-percentual dimensions
      while (width.unit == '%') {
        wm *= width.value
        width = new SVG.Number(we instanceof SVG.Doc ? we.parent().offsetWidth : we.parent().width())
        we = we.parent()
      }
      while (height.unit == '%') {
        hm *= height.value
        height = new SVG.Number(he instanceof SVG.Doc ? he.parent().offsetHeight : he.parent().height())
        he = he.parent()
      }

      // ensure defaults
      this.x      = 0
      this.y      = 0
      this.width  = width  * wm
      this.height = height * hm
      this.zoom   = 1

      if (view) {
        // get width and height from viewbox
        x      = parseFloat(view[0])
        y      = parseFloat(view[1])
        width  = parseFloat(view[2])
        height = parseFloat(view[3])

        // calculate zoom accoring to viewbox
        this.zoom = ((this.width / this.height) > (width / height)) ?
          this.height / height :
          this.width  / width

        // calculate real pixel dimensions on parent SVG.Doc element
        this.x      = x
        this.y      = y
        this.width  = width
        this.height = height

      }

    }else{

      // ensure source as object
      source = typeof source === 'string' ?
        source.match(reg).map(function(el){ return parseFloat(el) }) :
      Array.isArray(source) ?
        source :
      typeof source == 'object' ?
        [source.x, source.y, source.width, source.height] :
      arguments.length == 4 ?
        [].slice.call(arguments) :
        base

      this.x = source[0]
      this.y = source[1]
      this.width = source[2]
      this.height = source[3]
    }


  }

, extend: {

    toString: function() {
      return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height
    }
  , morph: function(v){

      var v = arguments.length == 1 ?
        [v.x, v.y, v.width, v.height] :
        [].slice.call(arguments)

      this.destination = new SVG.ViewBox(v)

      return this

    }

  , at: function(pos) {

    if(!this.destination) return this

    return new SVG.ViewBox([
        this.x + (this.destination.x - this.x) * pos
      , this.y + (this.destination.y - this.y) * pos
      , this.width + (this.destination.width - this.width) * pos
      , this.height + (this.destination.height - this.height) * pos
    ])

    }

  }

  // Define parent
, parent: SVG.Container

  // Add parent method
, construct: {

    // get/set viewbox
    viewbox: function(v) {
      if (arguments.length == 0)
        // act as a getter if there are no arguments
        return new SVG.ViewBox(this)

      // otherwise act as a setter
      v = arguments.length == 1 ?
        [v.x, v.y, v.width, v.height] :
        [].slice.call(arguments)

      return this.attr('viewBox', v)
    }

  }

})
// Add events to elements
;[  'click'
  , 'dblclick'
  , 'mousedown'
  , 'mouseup'
  , 'mouseover'
  , 'mouseout'
  , 'mousemove'
  // , 'mouseenter' -> not supported by IE
  // , 'mouseleave' -> not supported by IE
  , 'touchstart'
  , 'touchmove'
  , 'touchleave'
  , 'touchend'
  , 'touchcancel' ].forEach(function(event) {

  // add event to SVG.Element
  SVG.Element.prototype[event] = function(f) {
    var self = this

    // bind event to element rather than element node
    this.node['on' + event] = typeof f == 'function' ?
      function() { return f.apply(self, arguments) } : null

    return this
  }

})

// Initialize listeners stack
SVG.listeners = []
SVG.handlerMap = []
SVG.listenerId = 0

// Add event binder in the SVG namespace
SVG.on = function(node, event, listener, binding) {
  // create listener, get object-index
  var l     = listener.bind(binding || node.instance || node)
    , index = (SVG.handlerMap.indexOf(node) + 1 || SVG.handlerMap.push(node)) - 1
    , ev    = event.split('.')[0]
    , ns    = event.split('.')[1] || '*'


  // ensure valid object
  SVG.listeners[index]         = SVG.listeners[index]         || {}
  SVG.listeners[index][ev]     = SVG.listeners[index][ev]     || {}
  SVG.listeners[index][ev][ns] = SVG.listeners[index][ev][ns] || {}

  if(!listener._svgjsListenerId)
    listener._svgjsListenerId = ++SVG.listenerId

  // reference listener
  SVG.listeners[index][ev][ns][listener._svgjsListenerId] = l

  // add listener
  node.addEventListener(ev, l, false)
}

// Add event unbinder in the SVG namespace
SVG.off = function(node, event, listener) {
  var index = SVG.handlerMap.indexOf(node)
    , ev    = event && event.split('.')[0]
    , ns    = event && event.split('.')[1]

  if(index == -1) return

  if (listener) {
    if(typeof listener == 'function') listener = listener._svgjsListenerId
    if(!listener) return

    // remove listener reference
    if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns || '*']) {
      // remove listener
      node.removeEventListener(ev, SVG.listeners[index][ev][ns || '*'][listener], false)

      delete SVG.listeners[index][ev][ns || '*'][listener]
    }

  } else if (ns && ev) {
    // remove all listeners for a namespaced event
    if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns]) {
      for (listener in SVG.listeners[index][ev][ns])
        SVG.off(node, [ev, ns].join('.'), listener)

      delete SVG.listeners[index][ev][ns]
    }

  } else if (ns){
    // remove all listeners for a specific namespace
    for(event in SVG.listeners[index]){
        for(namespace in SVG.listeners[index][event]){
            if(ns === namespace){
                SVG.off(node, [event, ns].join('.'))
            }
        }
    }

  } else if (ev) {
    // remove all listeners for the event
    if (SVG.listeners[index][ev]) {
      for (namespace in SVG.listeners[index][ev])
        SVG.off(node, [ev, namespace].join('.'))

      delete SVG.listeners[index][ev]
    }

  } else {
    // remove all listeners on a given node
    for (event in SVG.listeners[index])
      SVG.off(node, event)

    delete SVG.listeners[index]

  }
}

//
SVG.extend(SVG.Element, {
  // Bind given event to listener
  on: function(event, listener, binding) {
    SVG.on(this.node, event, listener, binding)

    return this
  }
  // Unbind event from listener
, off: function(event, listener) {
    SVG.off(this.node, event, listener)

    return this
  }
  // Fire given event
, fire: function(event, data) {

    // Dispatch event
    if(event instanceof Event){
        this.node.dispatchEvent(event)
    }else{
        this.node.dispatchEvent(new CustomEvent(event, {detail:data}))
    }

    return this
  }
})

SVG.Defs = SVG.invent({
  // Initialize node
  create: 'defs'

  // Inherit from
, inherit: SVG.Container

})
SVG.G = SVG.invent({
  // Initialize node
  create: 'g'

  // Inherit from
, inherit: SVG.Container

  // Add class methods
, extend: {
    // Move over x-axis
    x: function(x) {
      return x == null ? this.transform('x') : this.transform({ x: x - this.x() }, true)
    }
    // Move over y-axis
  , y: function(y) {
      return y == null ? this.transform('y') : this.transform({ y: y - this.y() }, true)
    }
    // Move by center over x-axis
  , cx: function(x) {
      return x == null ? this.gbox().cx : this.x(x - this.gbox().width / 2)
    }
    // Move by center over y-axis
  , cy: function(y) {
      return y == null ? this.gbox().cy : this.y(y - this.gbox().height / 2)
    }
  , gbox: function() {

      var bbox  = this.bbox()
        , trans = this.transform()

      bbox.x  += trans.x
      bbox.x2 += trans.x
      bbox.cx += trans.x

      bbox.y  += trans.y
      bbox.y2 += trans.y
      bbox.cy += trans.y

      return bbox
    }
  }

  // Add parent method
, construct: {
    // Create a group element
    group: function() {
      return this.put(new SVG.G)
    }
  }
})

// ### This module adds backward / forward functionality to elements.

//
SVG.extend(SVG.Element, {
  // Get all siblings, including myself
  siblings: function() {
    return this.parent().children()
  }
  // Get the curent position siblings
, position: function() {
    return this.parent().index(this)
  }
  // Get the next element (will return null if there is none)
, next: function() {
    return this.siblings()[this.position() + 1]
  }
  // Get the next element (will return null if there is none)
, previous: function() {
    return this.siblings()[this.position() - 1]
  }
  // Send given element one step forward
, forward: function() {
    var i = this.position() + 1
      , p = this.parent()

    // move node one step forward
    p.removeElement(this).add(this, i)

    // make sure defs node is always at the top
    if (p instanceof SVG.Doc)
      p.node.appendChild(p.defs().node)

    return this
  }
  // Send given element one step backward
, backward: function() {
    var i = this.position()

    if (i > 0)
      this.parent().removeElement(this).add(this, i - 1)

    return this
  }
  // Send given element all the way to the front
, front: function() {
    var p = this.parent()

    // Move node forward
    p.node.appendChild(this.node)

    // Make sure defs node is always at the top
    if (p instanceof SVG.Doc)
      p.node.appendChild(p.defs().node)

    return this
  }
  // Send given element all the way to the back
, back: function() {
    if (this.position() > 0)
      this.parent().removeElement(this).add(this, 0)

    return this
  }
  // Inserts a given element before the targeted element
, before: function(element) {
    element.remove()

    var i = this.position()

    this.parent().add(element, i)

    return this
  }
  // Insters a given element after the targeted element
, after: function(element) {
    element.remove()

    var i = this.position()

    this.parent().add(element, i + 1)

    return this
  }

})
SVG.Mask = SVG.invent({
  // Initialize node
  create: function() {
    this.constructor.call(this, SVG.create('mask'))

    // keep references to masked elements
    this.targets = []
  }

  // Inherit from
, inherit: SVG.Container

  // Add class methods
, extend: {
    // Unmask all masked elements and remove itself
    remove: function() {
      // unmask all targets
      for (var i = this.targets.length - 1; i >= 0; i--)
        if (this.targets[i])
          this.targets[i].unmask()
      this.targets = []

      // remove mask from parent
      this.parent().removeElement(this)

      return this
    }
  }

  // Add parent method
, construct: {
    // Create masking element
    mask: function() {
      return this.defs().put(new SVG.Mask)
    }
  }
})


SVG.extend(SVG.Element, {
  // Distribute mask to svg element
  maskWith: function(element) {
    // use given mask or create a new one
    this.masker = element instanceof SVG.Mask ? element : this.parent().mask().add(element)

    // store reverence on self in mask
    this.masker.targets.push(this)

    // apply mask
    return this.attr('mask', 'url("#' + this.masker.attr('id') + '")')
  }
  // Unmask element
, unmask: function() {
    delete this.masker
    return this.attr('mask', null)
  }

})

SVG.ClipPath = SVG.invent({
  // Initialize node
  create: function() {
    this.constructor.call(this, SVG.create('clipPath'))

    // keep references to clipped elements
    this.targets = []
  }

  // Inherit from
, inherit: SVG.Container

  // Add class methods
, extend: {
    // Unclip all clipped elements and remove itself
    remove: function() {
      // unclip all targets
      for (var i = this.targets.length - 1; i >= 0; i--)
        if (this.targets[i])
          this.targets[i].unclip()
      this.targets = []

      // remove clipPath from parent
      this.parent().removeElement(this)

      return this
    }
  }

  // Add parent method
, construct: {
    // Create clipping element
    clip: function() {
      return this.defs().put(new SVG.ClipPath)
    }
  }
})

//
SVG.extend(SVG.Element, {
  // Distribute clipPath to svg element
  clipWith: function(element) {
    // use given clip or create a new one
    this.clipper = element instanceof SVG.ClipPath ? element : this.parent().clip().add(element)

    // store reverence on self in mask
    this.clipper.targets.push(this)

    // apply mask
    return this.attr('clip-path', 'url("#' + this.clipper.attr('id') + '")')
  }
  // Unclip element
, unclip: function() {
    delete this.clipper
    return this.attr('clip-path', null)
  }

})
SVG.Gradient = SVG.invent({
  // Initialize node
  create: function(type) {
    this.constructor.call(this, SVG.create(type + 'Gradient'))

    // store type
    this.type = type
  }

  // Inherit from
, inherit: SVG.Container

  // Add class methods
, extend: {
    // Add a color stop
    at: function(offset, color, opacity) {
      return this.put(new SVG.Stop).update(offset, color, opacity)
    }
    // Update gradient
  , update: function(block) {
      // remove all stops
      this.clear()

      // invoke passed block
      if (typeof block == 'function')
        block.call(this, this)

      return this
    }
    // Return the fill id
  , fill: function() {
      return 'url(#' + this.id() + ')'
    }
    // Alias string convertion to fill
  , toString: function() {
      return this.fill()
    }
    // custom attr to handle transform
  , attr: function(a, b, c) {
      if(a == 'transform') a = 'gradientTransform'
      return SVG.Container.prototype.attr.call(this, a, b, c)
    }
  }

  // Add parent method
, construct: {
    // Create gradient element in defs
    gradient: function(type, block) {
      return this.defs().gradient(type, block)
    }
  }
})

// Add animatable methods to both gradient and fx module
SVG.extend(SVG.Gradient, SVG.FX, {
  // From position
  from: function(x, y) {
    return (this._target || this).type == 'radial' ?
      this.attr({ fx: new SVG.Number(x), fy: new SVG.Number(y) }) :
      this.attr({ x1: new SVG.Number(x), y1: new SVG.Number(y) })
  }
  // To position
, to: function(x, y) {
    return (this._target || this).type == 'radial' ?
      this.attr({ cx: new SVG.Number(x), cy: new SVG.Number(y) }) :
      this.attr({ x2: new SVG.Number(x), y2: new SVG.Number(y) })
  }
})

// Base gradient generation
SVG.extend(SVG.Defs, {
  // define gradient
  gradient: function(type, block) {
    return this.put(new SVG.Gradient(type)).update(block)
  }

})

SVG.Stop = SVG.invent({
  // Initialize node
  create: 'stop'

  // Inherit from
, inherit: SVG.Element

  // Add class methods
, extend: {
    // add color stops
    update: function(o) {
      if (typeof o == 'number' || o instanceof SVG.Number) {
        o = {
          offset:  arguments[0]
        , color:   arguments[1]
        , opacity: arguments[2]
        }
      }

      // set attributes
      if (o.opacity != null) this.attr('stop-opacity', o.opacity)
      if (o.color   != null) this.attr('stop-color', o.color)
      if (o.offset  != null) this.attr('offset', new SVG.Number(o.offset))

      return this
    }
  }

})

SVG.Pattern = SVG.invent({
  // Initialize node
  create: 'pattern'

  // Inherit from
, inherit: SVG.Container

  // Add class methods
, extend: {
    // Return the fill id
    fill: function() {
      return 'url(#' + this.id() + ')'
    }
    // Update pattern by rebuilding
  , update: function(block) {
      // remove content
      this.clear()

      // invoke passed block
      if (typeof block == 'function')
        block.call(this, this)

      return this
    }
    // Alias string convertion to fill
  , toString: function() {
      return this.fill()
    }
    // custom attr to handle transform
  , attr: function(a, b, c) {
      if(a == 'transform') a = 'patternTransform'
      return SVG.Container.prototype.attr.call(this, a, b, c)
    }

  }

  // Add parent method
, construct: {
    // Create pattern element in defs
    pattern: function(width, height, block) {
      return this.defs().pattern(width, height, block)
    }
  }
})

SVG.extend(SVG.Defs, {
  // Define gradient
  pattern: function(width, height, block) {
    return this.put(new SVG.Pattern).update(block).attr({
      x:            0
    , y:            0
    , width:        width
    , height:       height
    , patternUnits: 'userSpaceOnUse'
    })
  }

})
SVG.Doc = SVG.invent({
  // Initialize node
  create: function(element) {
    if (element) {
      // ensure the presence of a dom element
      element = typeof element == 'string' ?
        document.getElementById(element) :
        element

      // If the target is an svg element, use that element as the main wrapper.
      // This allows svg.js to work with svg documents as well.
      if (element.nodeName == 'svg') {
        this.constructor.call(this, element)
      } else {
        this.constructor.call(this, SVG.create('svg'))
        element.appendChild(this.node)
        this.size('100%', '100%')
      }

      // set svg element attributes and ensure defs node
      this.namespace().defs()
    }
  }

  // Inherit from
, inherit: SVG.Container

  // Add class methods
, extend: {
    // Add namespaces
    namespace: function() {
      return this
        .attr({ xmlns: SVG.ns, version: '1.1' })
        .attr('xmlns:xlink', SVG.xlink, SVG.xmlns)
        .attr('xmlns:svgjs', SVG.svgjs, SVG.xmlns)
    }
    // Creates and returns defs element
  , defs: function() {
      if (!this._defs) {
        var defs

        // Find or create a defs element in this instance
        if (defs = this.node.getElementsByTagName('defs')[0])
          this._defs = SVG.adopt(defs)
        else
          this._defs = new SVG.Defs

        // Make sure the defs node is at the end of the stack
        this.node.appendChild(this._defs.node)
      }

      return this._defs
    }
    // custom parent method
  , parent: function() {
      return this.node.parentNode.nodeName == '#document' ? null : this.node.parentNode
    }
    // Fix for possible sub-pixel offset. See:
    // https://bugzilla.mozilla.org/show_bug.cgi?id=608812
  , spof: function(spof) {
      var pos = this.node.getScreenCTM()

      if (pos)
        this
          .style('left', (-pos.e % 1) + 'px')
          .style('top',  (-pos.f % 1) + 'px')

      return this
    }

      // Removes the doc from the DOM
  , remove: function() {
      if(this.parent()) {
        this.parent().removeChild(this.node);
      }

      return this;
    }
  }

})

SVG.Shape = SVG.invent({
  // Initialize node
  create: function(element) {
    this.constructor.call(this, element)
  }

  // Inherit from
, inherit: SVG.Element

})

SVG.Bare = SVG.invent({
  // Initialize
  create: function(element, inherit) {
    // construct element
    this.constructor.call(this, SVG.create(element))

    // inherit custom methods
    if (inherit)
      for (var method in inherit.prototype)
        if (typeof inherit.prototype[method] === 'function')
          this[method] = inherit.prototype[method]
  }

  // Inherit from
, inherit: SVG.Element

  // Add methods
, extend: {
    // Insert some plain text
    words: function(text) {
      // remove contents
      while (this.node.hasChildNodes())
        this.node.removeChild(this.node.lastChild)

      // create text node
      this.node.appendChild(document.createTextNode(text))

      return this
    }
  }
})


SVG.extend(SVG.Parent, {
  // Create an element that is not described by SVG.js
  element: function(element, inherit) {
    return this.put(new SVG.Bare(element, inherit))
  }
  // Add symbol element
, symbol: function() {
    return this.defs().element('symbol', SVG.Container)
  }

})
SVG.Use = SVG.invent({
  // Initialize node
  create: 'use'

  // Inherit from
, inherit: SVG.Shape

  // Add class methods
, extend: {
    // Use element as a reference
    element: function(element, file) {
      // Set lined element
      return this.attr('href', (file || '') + '#' + element, SVG.xlink)
    }
  }

  // Add parent method
, construct: {
    // Create a use element
    use: function(element, file) {
      return this.put(new SVG.Use).element(element, file)
    }
  }
})
SVG.Rect = SVG.invent({
  // Initialize node
  create: 'rect'

  // Inherit from
, inherit: SVG.Shape

  // Add parent method
, construct: {
    // Create a rect element
    rect: function(width, height) {
      return this.put(new SVG.Rect()).size(width, height)
    }
  }
})
SVG.Circle = SVG.invent({
  // Initialize node
  create: 'circle'

  // Inherit from
, inherit: SVG.Shape

  // Add parent method
, construct: {
    // Create circle element, based on ellipse
    circle: function(size) {
      return this.put(new SVG.Circle).rx(new SVG.Number(size).divide(2)).move(0, 0)
    }
  }
})

SVG.extend(SVG.Circle, SVG.FX, {
  // Radius x value
  rx: function(rx) {
    return this.attr('r', rx)
  }
  // Alias radius x value
, ry: function(ry) {
    return this.rx(ry)
  }
})

SVG.Ellipse = SVG.invent({
  // Initialize node
  create: 'ellipse'

  // Inherit from
, inherit: SVG.Shape

  // Add parent method
, construct: {
    // Create an ellipse
    ellipse: function(width, height) {
      return this.put(new SVG.Ellipse).size(width, height).move(0, 0)
    }
  }
})

SVG.extend(SVG.Ellipse, SVG.Rect, SVG.FX, {
  // Radius x value
  rx: function(rx) {
    return this.attr('rx', rx)
  }
  // Radius y value
, ry: function(ry) {
    return this.attr('ry', ry)
  }
})

// Add common method
SVG.extend(SVG.Circle, SVG.Ellipse, {
    // Move over x-axis
    x: function(x) {
      return x == null ? this.cx() - this.rx() : this.cx(x + this.rx())
    }
    // Move over y-axis
  , y: function(y) {
      return y == null ? this.cy() - this.ry() : this.cy(y + this.ry())
    }
    // Move by center over x-axis
  , cx: function(x) {
      return x == null ? this.attr('cx') : this.attr('cx', x)
    }
    // Move by center over y-axis
  , cy: function(y) {
      return y == null ? this.attr('cy') : this.attr('cy', y)
    }
    // Set width of element
  , width: function(width) {
      return width == null ? this.rx() * 2 : this.rx(new SVG.Number(width).divide(2))
    }
    // Set height of element
  , height: function(height) {
      return height == null ? this.ry() * 2 : this.ry(new SVG.Number(height).divide(2))
    }
    // Custom size function
  , size: function(width, height) {
      var p = proportionalSize(this, width, height)

      return this
        .rx(new SVG.Number(p.width).divide(2))
        .ry(new SVG.Number(p.height).divide(2))
    }
})
SVG.Line = SVG.invent({
  // Initialize node
  create: 'line'

  // Inherit from
, inherit: SVG.Shape

  // Add class methods
, extend: {
    // Get array
    array: function() {
      return new SVG.PointArray([
        [ this.attr('x1'), this.attr('y1') ]
      , [ this.attr('x2'), this.attr('y2') ]
      ])
    }
    // Overwrite native plot() method
  , plot: function(x1, y1, x2, y2) {
      if (typeof y1 !== 'undefined')
        x1 = { x1: x1, y1: y1, x2: x2, y2: y2 }
      else
        x1 = new SVG.PointArray(x1).toLine()

      return this.attr(x1)
    }
    // Move by left top corner
  , move: function(x, y) {
      return this.attr(this.array().move(x, y).toLine())
    }
    // Set element size to given width and height
  , size: function(width, height) {
      var p = proportionalSize(this, width, height)

      return this.attr(this.array().size(p.width, p.height).toLine())
    }
  }

  // Add parent method
, construct: {
    // Create a line element
    line: function(x1, y1, x2, y2) {
      return this.put(new SVG.Line).plot(x1, y1, x2, y2)
    }
  }
})

SVG.Polyline = SVG.invent({
  // Initialize node
  create: 'polyline'

  // Inherit from
, inherit: SVG.Shape

  // Add parent method
, construct: {
    // Create a wrapped polyline element
    polyline: function(p) {
      return this.put(new SVG.Polyline).plot(p)
    }
  }
})

SVG.Polygon = SVG.invent({
  // Initialize node
  create: 'polygon'

  // Inherit from
, inherit: SVG.Shape

  // Add parent method
, construct: {
    // Create a wrapped polygon element
    polygon: function(p) {
      return this.put(new SVG.Polygon).plot(p)
    }
  }
})

// Add polygon-specific functions
SVG.extend(SVG.Polyline, SVG.Polygon, {
  // Get array
  array: function() {
    return this._array || (this._array = new SVG.PointArray(this.attr('points')))
  }
  // Plot new path
, plot: function(p) {
    return this.attr('points', (this._array = new SVG.PointArray(p)))
  }
  // Move by left top corner
, move: function(x, y) {
    return this.attr('points', this.array().move(x, y))
  }
  // Set element size to given width and height
, size: function(width, height) {
    var p = proportionalSize(this, width, height)

    return this.attr('points', this.array().size(p.width, p.height))
  }

})
// unify all point to point elements
SVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, {
  // Define morphable array
  morphArray:  SVG.PointArray
  // Move by left top corner over x-axis
, x: function(x) {
    return x == null ? this.bbox().x : this.move(x, this.bbox().y)
  }
  // Move by left top corner over y-axis
, y: function(y) {
    return y == null ? this.bbox().y : this.move(this.bbox().x, y)
  }
  // Set width of element
, width: function(width) {
    var b = this.bbox()

    return width == null ? b.width : this.size(width, b.height)
  }
  // Set height of element
, height: function(height) {
    var b = this.bbox()

    return height == null ? b.height : this.size(b.width, height)
  }
})
SVG.Path = SVG.invent({
  // Initialize node
  create: 'path'

  // Inherit from
, inherit: SVG.Shape

  // Add class methods
, extend: {
    // Define morphable array
    morphArray:  SVG.PathArray
    // Get array
  , array: function() {
      return this._array || (this._array = new SVG.PathArray(this.attr('d')))
    }
    // Plot new poly points
  , plot: function(p) {
      return this.attr('d', (this._array = new SVG.PathArray(p)))
    }
    // Move by left top corner
  , move: function(x, y) {
      return this.attr('d', this.array().move(x, y))
    }
    // Move by left top corner over x-axis
  , x: function(x) {
      return x == null ? this.bbox().x : this.move(x, this.bbox().y)
    }
    // Move by left top corner over y-axis
  , y: function(y) {
      return y == null ? this.bbox().y : this.move(this.bbox().x, y)
    }
    // Set element size to given width and height
  , size: function(width, height) {
      var p = proportionalSize(this, width, height)

      return this.attr('d', this.array().size(p.width, p.height))
    }
    // Set width of element
  , width: function(width) {
      return width == null ? this.bbox().width : this.size(width, this.bbox().height)
    }
    // Set height of element
  , height: function(height) {
      return height == null ? this.bbox().height : this.size(this.bbox().width, height)
    }

  }

  // Add parent method
, construct: {
    // Create a wrapped path element
    path: function(d) {
      return this.put(new SVG.Path).plot(d)
    }
  }
})
SVG.Image = SVG.invent({
  // Initialize node
  create: 'image'

  // Inherit from
, inherit: SVG.Shape

  // Add class methods
, extend: {
    // (re)load image
    load: function(url) {
      if (!url) return this

      var self = this
        , img  = document.createElement('img')

      // preload image
      img.onload = function() {
        var p = self.parent(SVG.Pattern)

        if(p === null) return

        // ensure image size
        if (self.width() == 0 && self.height() == 0)
          self.size(img.width, img.height)

        // ensure pattern size if not set
        if (p && p.width() == 0 && p.height() == 0)
          p.size(self.width(), self.height())

        // callback
        if (typeof self._loaded === 'function')
          self._loaded.call(self, {
            width:  img.width
          , height: img.height
          , ratio:  img.width / img.height
          , url:    url
          })
      }

      img.onerror = function(e){
        if (typeof self._error === 'function'){
            self._error.call(self, e)
        }
      }

      return this.attr('href', (img.src = this.src = url), SVG.xlink)
    }
    // Add loaded callback
  , loaded: function(loaded) {
      this._loaded = loaded
      return this
    }

  , error: function(error) {
      this._error = error
      return this
    }
  }

  // Add parent method
, construct: {
    // create image element, load image and set its size
    image: function(source, width, height) {
      return this.put(new SVG.Image).load(source).size(width || 0, height || width || 0)
    }
  }

})
SVG.Text = SVG.invent({
  // Initialize node
  create: function() {
    this.constructor.call(this, SVG.create('text'))

    this.dom.leading = new SVG.Number(1.3)    // store leading value for rebuilding
    this._rebuild = true                      // enable automatic updating of dy values
    this._build   = false                     // disable build mode for adding multiple lines

    // set default font
    this.attr('font-family', SVG.defaults.attrs['font-family'])
  }

  // Inherit from
, inherit: SVG.Shape

  // Add class methods
, extend: {
    // Move over x-axis
    x: function(x) {
      // act as getter
      if (x == null)
        return this.attr('x')

      // move lines as well if no textPath is present
      if (!this.textPath)
        this.lines().each(function() { if (this.dom.newLined) this.x(x) })

      return this.attr('x', x)
    }
    // Move over y-axis
  , y: function(y) {
      var oy = this.attr('y')
        , o  = typeof oy === 'number' ? oy - this.bbox().y : 0

      // act as getter
      if (y == null)
        return typeof oy === 'number' ? oy - o : oy

      return this.attr('y', typeof y === 'number' ? y + o : y)
    }
    // Move center over x-axis
  , cx: function(x) {
      return x == null ? this.bbox().cx : this.x(x - this.bbox().width / 2)
    }
    // Move center over y-axis
  , cy: function(y) {
      return y == null ? this.bbox().cy : this.y(y - this.bbox().height / 2)
    }
    // Set the text content
  , text: function(text) {
      // act as getter
      if (typeof text === 'undefined'){
        var text = ''
        var children = this.node.childNodes
        for(var i = 0, len = children.length; i < len; ++i){

          // add newline if its not the first child and newLined is set to true
          if(i != 0 && children[i].nodeType != 3 && SVG.adopt(children[i]).dom.newLined == true){
            text += '\n'
          }

          // add content of this node
          text += children[i].textContent
        }

        return text
      }

      // remove existing content
      this.clear().build(true)

      if (typeof text === 'function') {
        // call block
        text.call(this, this)

      } else {
        // store text and make sure text is not blank
        text = text.split('\n')

        // build new lines
        for (var i = 0, il = text.length; i < il; i++)
          this.tspan(text[i]).newLine()
      }

      // disable build mode and rebuild lines
      return this.build(false).rebuild()
    }
    // Set font size
  , size: function(size) {
      return this.attr('font-size', size).rebuild()
    }
    // Set / get leading
  , leading: function(value) {
      // act as getter
      if (value == null)
        return this.dom.leading

      // act as setter
      this.dom.leading = new SVG.Number(value)

      return this.rebuild()
    }
    // Get all the first level lines
  , lines: function() {
      var node = (this.textPath && this.textPath() || this).node

      // filter tspans and map them to SVG.js instances
      var lines = SVG.utils.map(SVG.utils.filterSVGElements(node.childNodes), function(el){
        return SVG.adopt(el)
      })

      // return an instance of SVG.set
      return new SVG.Set(lines)
    }
    // Rebuild appearance type
  , rebuild: function(rebuild) {
      // store new rebuild flag if given
      if (typeof rebuild == 'boolean')
        this._rebuild = rebuild

      // define position of all lines
      if (this._rebuild) {
        var self = this
          , blankLineOffset = 0
          , dy = this.dom.leading * new SVG.Number(this.attr('font-size'))

        this.lines().each(function() {
          if (this.dom.newLined) {
            if (!this.textPath)
              this.attr('x', self.attr('x'))

            if(this.text() == '\n') {
              blankLineOffset += dy
            }else{
              this.attr('dy', dy + blankLineOffset)
              blankLineOffset = 0
            }
          }
        })

        this.fire('rebuild')
      }

      return this
    }
    // Enable / disable build mode
  , build: function(build) {
      this._build = !!build
      return this
    }
    // overwrite method from parent to set data properly
  , setData: function(o){
      this.dom = o
      this.dom.leading = new SVG.Number(o.leading || 1.3)
      return this
    }
  }

  // Add parent method
, construct: {
    // Create text element
    text: function(text) {
      return this.put(new SVG.Text).text(text)
    }
    // Create plain text element
  , plain: function(text) {
      return this.put(new SVG.Text).plain(text)
    }
  }

})

SVG.Tspan = SVG.invent({
  // Initialize node
  create: 'tspan'

  // Inherit from
, inherit: SVG.Shape

  // Add class methods
, extend: {
    // Set text content
    text: function(text) {
      if(text == null) return this.node.textContent + (this.dom.newLined ? '\n' : '')

      typeof text === 'function' ? text.call(this, this) : this.plain(text)

      return this
    }
    // Shortcut dx
  , dx: function(dx) {
      return this.attr('dx', dx)
    }
    // Shortcut dy
  , dy: function(dy) {
      return this.attr('dy', dy)
    }
    // Create new line
  , newLine: function() {
      // fetch text parent
      var t = this.parent(SVG.Text)

      // mark new line
      this.dom.newLined = true

      // apply new hy¡n
      return this.dy(t.dom.leading * t.attr('font-size')).attr('x', t.x())
    }
  }

})

SVG.extend(SVG.Text, SVG.Tspan, {
  // Create plain text node
  plain: function(text) {
    // clear if build mode is disabled
    if (this._build === false)
      this.clear()

    // create text node
    this.node.appendChild(document.createTextNode(text))

    return this
  }
  // Create a tspan
, tspan: function(text) {
    var node  = (this.textPath && this.textPath() || this).node
      , tspan = new SVG.Tspan

    // clear if build mode is disabled
    if (this._build === false)
      this.clear()

    // add new tspan
    node.appendChild(tspan.node)

    return tspan.text(text)
  }
  // Clear all lines
, clear: function() {
    var node = (this.textPath && this.textPath() || this).node

    // remove existing child nodes
    while (node.hasChildNodes())
      node.removeChild(node.lastChild)

    return this
  }
  // Get length of text element
, length: function() {
    return this.node.getComputedTextLength()
  }
})

SVG.TextPath = SVG.invent({
  // Initialize node
  create: 'textPath'

  // Inherit from
, inherit: SVG.Parent

  // Define parent class
, parent: SVG.Text

  // Add parent method
, construct: {
    // Create path for text to run on
    path: function(d) {
      // create textPath element
      var path  = new SVG.TextPath
        , track = this.doc().defs().path(d)

      // move lines to textpath
      while (this.node.hasChildNodes())
        path.node.appendChild(this.node.firstChild)

      // add textPath element as child node
      this.node.appendChild(path.node)

      // link textPath to path and add content
      path.attr('href', '#' + track, SVG.xlink)

      return this
    }
    // Plot path if any
  , plot: function(d) {
      var track = this.track()

      if (track)
        track.plot(d)

      return this
    }
    // Get the path track element
  , track: function() {
      var path = this.textPath()

      if (path)
        return path.reference('href')
    }
    // Get the textPath child
  , textPath: function() {
      if (this.node.firstChild && this.node.firstChild.nodeName == 'textPath')
        return SVG.adopt(this.node.firstChild)
    }
  }
})
SVG.Nested = SVG.invent({
  // Initialize node
  create: function() {
    this.constructor.call(this, SVG.create('svg'))

    this.style('overflow', 'visible')
  }

  // Inherit from
, inherit: SVG.Container

  // Add parent method
, construct: {
    // Create nested svg document
    nested: function() {
      return this.put(new SVG.Nested)
    }
  }
})
SVG.A = SVG.invent({
  // Initialize node
  create: 'a'

  // Inherit from
, inherit: SVG.Container

  // Add class methods
, extend: {
    // Link url
    to: function(url) {
      return this.attr('href', url, SVG.xlink)
    }
    // Link show attribute
  , show: function(target) {
      return this.attr('show', target, SVG.xlink)
    }
    // Link target attribute
  , target: function(target) {
      return this.attr('target', target)
    }
  }

  // Add parent method
, construct: {
    // Create a hyperlink element
    link: function(url) {
      return this.put(new SVG.A).to(url)
    }
  }
})

SVG.extend(SVG.Element, {
  // Create a hyperlink element
  linkTo: function(url) {
    var link = new SVG.A

    if (typeof url == 'function')
      url.call(link, link)
    else
      link.to(url)

    return this.parent().put(link).put(this)
  }

})
SVG.Marker = SVG.invent({
  // Initialize node
  create: 'marker'

  // Inherit from
, inherit: SVG.Container

  // Add class methods
, extend: {
    // Set width of element
    width: function(width) {
      return this.attr('markerWidth', width)
    }
    // Set height of element
  , height: function(height) {
      return this.attr('markerHeight', height)
    }
    // Set marker refX and refY
  , ref: function(x, y) {
      return this.attr('refX', x).attr('refY', y)
    }
    // Update marker
  , update: function(block) {
      // remove all content
      this.clear()

      // invoke passed block
      if (typeof block == 'function')
        block.call(this, this)

      return this
    }
    // Return the fill id
  , toString: function() {
      return 'url(#' + this.id() + ')'
    }
  }

  // Add parent method
, construct: {
    marker: function(width, height, block) {
      // Create marker element in defs
      return this.defs().marker(width, height, block)
    }
  }

})

SVG.extend(SVG.Defs, {
  // Create marker
  marker: function(width, height, block) {
    // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto
    return this.put(new SVG.Marker)
      .size(width, height)
      .ref(width / 2, height / 2)
      .viewbox(0, 0, width, height)
      .attr('orient', 'auto')
      .update(block)
  }

})

SVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, SVG.Path, {
  // Create and attach markers
  marker: function(marker, width, height, block) {
    var attr = ['marker']

    // Build attribute name
    if (marker != 'all') attr.push(marker)
    attr = attr.join('-')

    // Set marker attribute
    marker = arguments[1] instanceof SVG.Marker ?
      arguments[1] :
      this.doc().marker(width, height, block)

    return this.attr(attr, marker)
  }

})
// Define list of available attributes for stroke and fill
var sugar = {
  stroke: ['color', 'width', 'opacity', 'linecap', 'linejoin', 'miterlimit', 'dasharray', 'dashoffset']
, fill:   ['color', 'opacity', 'rule']
, prefix: function(t, a) {
    return a == 'color' ? t : t + '-' + a
  }
}

// Add sugar for fill and stroke
;['fill', 'stroke'].forEach(function(m) {
  var i, extension = {}

  extension[m] = function(o) {
    if (typeof o == 'undefined')
      return this
    if (typeof o == 'string' || SVG.Color.isRgb(o) || (o && typeof o.fill === 'function'))
      this.attr(m, o)

    else
      // set all attributes from sugar.fill and sugar.stroke list
      for (i = sugar[m].length - 1; i >= 0; i--)
        if (o[sugar[m][i]] != null)
          this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]])

    return this
  }

  SVG.extend(SVG.Element, SVG.FX, extension)

})

SVG.extend(SVG.Element, SVG.FX, {
  // Map rotation to transform
  rotate: function(d, cx, cy) {
    return this.transform({ rotation: d, cx: cx, cy: cy })
  }
  // Map skew to transform
, skew: function(x, y, cx, cy) {
    return arguments.length == 1  || arguments.length == 3 ?
      this.transform({ skew: x, cx: y, cy: cx }) :
      this.transform({ skewX: x, skewY: y, cx: cx, cy: cy })
  }
  // Map scale to transform
, scale: function(x, y, cx, cy) {
    return arguments.length == 1  || arguments.length == 3 ?
      this.transform({ scale: x, cx: y, cy: cx }) :
      this.transform({ scaleX: x, scaleY: y, cx: cx, cy: cy })
  }
  // Map translate to transform
, translate: function(x, y) {
    return this.transform({ x: x, y: y })
  }
  // Map flip to transform
, flip: function(a, o) {
    return this.transform({ flip: a, offset: o })
  }
  // Map matrix to transform
, matrix: function(m) {
    return this.attr('transform', new SVG.Matrix(m))
  }
  // Opacity
, opacity: function(value) {
    return this.attr('opacity', value)
  }
  // Relative move over x axis
, dx: function(x) {
    return this.x((this instanceof SVG.FX ? 0 : this.x()) + x, true)
  }
  // Relative move over y axis
, dy: function(y) {
    return this.y((this instanceof SVG.FX ? 0 : this.y()) + y, true)
  }
  // Relative move over x and y axes
, dmove: function(x, y) {
    return this.dx(x).dy(y)
  }
})

SVG.extend(SVG.Rect, SVG.Ellipse, SVG.Circle, SVG.Gradient, SVG.FX, {
  // Add x and y radius
  radius: function(x, y) {
    var type = (this._target || this).type;
    return type == 'radial' || type == 'circle' ?
      this.attr('r', new SVG.Number(x)) :
      this.rx(x).ry(y == null ? x : y)
  }
})

SVG.extend(SVG.Path, {
  // Get path length
  length: function() {
    return this.node.getTotalLength()
  }
  // Get point at length
, pointAt: function(length) {
    return this.node.getPointAtLength(length)
  }
})

SVG.extend(SVG.Parent, SVG.Text, SVG.FX, {
  // Set font
  font: function(o) {
    for (var k in o)
      k == 'leading' ?
        this.leading(o[k]) :
      k == 'anchor' ?
        this.attr('text-anchor', o[k]) :
      k == 'size' || k == 'family' || k == 'weight' || k == 'stretch' || k == 'variant' || k == 'style' ?
        this.attr('font-'+ k, o[k]) :
        this.attr(k, o[k])

    return this
  }
})

SVG.Set = SVG.invent({
  // Initialize
  create: function(members) {
    // Set initial state
    Array.isArray(members) ? this.members = members : this.clear()
  }

  // Add class methods
, extend: {
    // Add element to set
    add: function() {
      var i, il, elements = [].slice.call(arguments)

      for (i = 0, il = elements.length; i < il; i++)
        this.members.push(elements[i])

      return this
    }
    // Remove element from set
  , remove: function(element) {
      var i = this.index(element)

      // remove given child
      if (i > -1)
        this.members.splice(i, 1)

      return this
    }
    // Iterate over all members
  , each: function(block) {
      for (var i = 0, il = this.members.length; i < il; i++)
        block.apply(this.members[i], [i, this.members])

      return this
    }
    // Restore to defaults
  , clear: function() {
      // initialize store
      this.members = []

      return this
    }
    // Get the length of a set
  , length: function() {
      return this.members.length
    }
    // Checks if a given element is present in set
  , has: function(element) {
      return this.index(element) >= 0
    }
    // retuns index of given element in set
  , index: function(element) {
      return this.members.indexOf(element)
    }
    // Get member at given index
  , get: function(i) {
      return this.members[i]
    }
    // Get first member
  , first: function() {
      return this.get(0)
    }
    // Get last member
  , last: function() {
      return this.get(this.members.length - 1)
    }
    // Default value
  , valueOf: function() {
      return this.members
    }
    // Get the bounding box of all members included or empty box if set has no items
  , bbox: function(){
      var box = new SVG.BBox()

      // return an empty box of there are no members
      if (this.members.length == 0)
        return box

      // get the first rbox and update the target bbox
      var rbox = this.members[0].rbox()
      box.x      = rbox.x
      box.y      = rbox.y
      box.width  = rbox.width
      box.height = rbox.height

      this.each(function() {
        // user rbox for correct position and visual representation
        box = box.merge(this.rbox())
      })

      return box
    }
  }

  // Add parent method
, construct: {
    // Create a new set
    set: function(members) {
      return new SVG.Set(members)
    }
  }
})

SVG.FX.Set = SVG.invent({
  // Initialize node
  create: function(set) {
    // store reference to set
    this.set = set
  }

})

// Alias methods
SVG.Set.inherit = function() {
  var m
    , methods = []

  // gather shape methods
  for(var m in SVG.Shape.prototype)
    if (typeof SVG.Shape.prototype[m] == 'function' && typeof SVG.Set.prototype[m] != 'function')
      methods.push(m)

  // apply shape aliasses
  methods.forEach(function(method) {
    SVG.Set.prototype[method] = function() {
      for (var i = 0, il = this.members.length; i < il; i++)
        if (this.members[i] && typeof this.members[i][method] == 'function')
          this.members[i][method].apply(this.members[i], arguments)

      return method == 'animate' ? (this.fx || (this.fx = new SVG.FX.Set(this))) : this
    }
  })

  // clear methods for the next round
  methods = []

  // gather fx methods
  for(var m in SVG.FX.prototype)
    if (typeof SVG.FX.prototype[m] == 'function' && typeof SVG.FX.Set.prototype[m] != 'function')
      methods.push(m)

  // apply fx aliasses
  methods.forEach(function(method) {
    SVG.FX.Set.prototype[method] = function() {
      for (var i = 0, il = this.set.members.length; i < il; i++)
        this.set.members[i].fx[method].apply(this.set.members[i].fx, arguments)

      return this
    }
  })
}




SVG.extend(SVG.Element, {
  // Store data values on svg nodes
  data: function(a, v, r) {
    if (typeof a == 'object') {
      for (v in a)
        this.data(v, a[v])

    } else if (arguments.length < 2) {
      try {
        return JSON.parse(this.attr('data-' + a))
      } catch(e) {
        return this.attr('data-' + a)
      }

    } else {
      this.attr(
        'data-' + a
      , v === null ?
          null :
        r === true || typeof v === 'string' || typeof v === 'number' ?
          v :
          JSON.stringify(v)
      )
    }

    return this
  }
})
SVG.extend(SVG.Element, {
  // Remember arbitrary data
  remember: function(k, v) {
    // remember every item in an object individually
    if (typeof arguments[0] == 'object')
      for (var v in k)
        this.remember(v, k[v])

    // retrieve memory
    else if (arguments.length == 1)
      return this.memory()[k]

    // store memory
    else
      this.memory()[k] = v

    return this
  }

  // Erase a given memory
, forget: function() {
    if (arguments.length == 0)
      this._memory = {}
    else
      for (var i = arguments.length - 1; i >= 0; i--)
        delete this.memory()[arguments[i]]

    return this
  }

  // Initialize or return local memory object
, memory: function() {
    return this._memory || (this._memory = {})
  }

})
// Method for getting an element by id
SVG.get = function(id) {
  var node = document.getElementById(idFromReference(id) || id)
  return SVG.adopt(node)
}

// Select elements by query string
SVG.select = function(query, parent) {
  return new SVG.Set(
    SVG.utils.map((parent || document).querySelectorAll(query), function(node) {
      return SVG.adopt(node)
    })
  )
}

SVG.extend(SVG.Parent, {
  // Scoped select method
  select: function(query) {
    return SVG.select(query, this.node)
  }

})
function is(el, obj){
  return el instanceof obj
}

// tests if a given selector matches an element
function matches(el, selector) {
  return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);
}

// Convert dash-separated-string to camelCase
function camelCase(s) {
  return s.toLowerCase().replace(/-(.)/g, function(m, g) {
    return g.toUpperCase()
  })
}

// Capitalize first letter of a string
function capitalize(s) {
  return s.charAt(0).toUpperCase() + s.slice(1)
}

// Ensure to six-based hex
function fullHex(hex) {
  return hex.length == 4 ?
    [ '#',
      hex.substring(1, 2), hex.substring(1, 2)
    , hex.substring(2, 3), hex.substring(2, 3)
    , hex.substring(3, 4), hex.substring(3, 4)
    ].join('') : hex
}

// Component to hex value
function compToHex(comp) {
  var hex = comp.toString(16)
  return hex.length == 1 ? '0' + hex : hex
}

// Calculate proportional width and height values when necessary
function proportionalSize(element, width, height) {
  if (width == null || height == null) {
    var box = element.bbox()

    if (width == null)
      width = box.width / box.height * height
    else if (height == null)
      height = box.height / box.width * width
  }

  return {
    width:  width
  , height: height
  }
}

// Delta transform point
function deltaTransformPoint(matrix, x, y) {
  return {
    x: x * matrix.a + y * matrix.c + 0
  , y: x * matrix.b + y * matrix.d + 0
  }
}

// Map matrix array to object
function arrayToMatrix(a) {
  return { a: a[0], b: a[1], c: a[2], d: a[3], e: a[4], f: a[5] }
}

// Parse matrix if required
function parseMatrix(matrix) {
  if (!(matrix instanceof SVG.Matrix))
    matrix = new SVG.Matrix(matrix)

  return matrix
}

// Add centre point to transform object
function ensureCentre(o, target) {
  o.cx = o.cx == null ? target.bbox().cx : o.cx
  o.cy = o.cy == null ? target.bbox().cy : o.cy
}

// Convert string to matrix
function stringToMatrix(source) {
  // remove matrix wrapper and split to individual numbers
  source = source
    .replace(SVG.regex.whitespace, '')
    .replace(SVG.regex.matrix, '')
    .split(SVG.regex.matrixElements)

  // convert string values to floats and convert to a matrix-formatted object
  return arrayToMatrix(
    SVG.utils.map(source, function(n) {
      return parseFloat(n)
    })
  )
}

// Calculate position according to from and to
function at(o, pos) {
  // number recalculation (don't bother converting to SVG.Number for performance reasons)
  return typeof o.from == 'number' ?
    o.from + (o.to - o.from) * pos :

  // instance recalculation
  o instanceof SVG.Color || o instanceof SVG.Number || o instanceof SVG.Matrix ? o.at(pos) :

  // for all other values wait until pos has reached 1 to return the final value
  pos < 1 ? o.from : o.to
}

// PathArray Helpers
function arrayToString(a) {
  for (var i = 0, il = a.length, s = ''; i < il; i++) {
    s += a[i][0]

    if (a[i][1] != null) {
      s += a[i][1]

      if (a[i][2] != null) {
        s += ' '
        s += a[i][2]

        if (a[i][3] != null) {
          s += ' '
          s += a[i][3]
          s += ' '
          s += a[i][4]

          if (a[i][5] != null) {
            s += ' '
            s += a[i][5]
            s += ' '
            s += a[i][6]

            if (a[i][7] != null) {
              s += ' '
              s += a[i][7]
            }
          }
        }
      }
    }
  }

  return s + ' '
}

// Deep new id assignment
function assignNewId(node) {
  // do the same for SVG child nodes as well
  for (var i = node.childNodes.length - 1; i >= 0; i--)
    if (node.childNodes[i] instanceof SVGElement)
      assignNewId(node.childNodes[i])

  return SVG.adopt(node).id(SVG.eid(node.nodeName))
}

// Add more bounding box properties
function fullBox(b) {
  if (b.x == null) {
    b.x      = 0
    b.y      = 0
    b.width  = 0
    b.height = 0
  }

  b.w  = b.width
  b.h  = b.height
  b.x2 = b.x + b.width
  b.y2 = b.y + b.height
  b.cx = b.x + b.width / 2
  b.cy = b.y + b.height / 2

  return b
}

// Get id from reference string
function idFromReference(url) {
  var m = url.toString().match(SVG.regex.reference)

  if (m) return m[1]
}

// Create matrix array for looping
var abcdef = 'abcdef'.split('')
// Add CustomEvent to IE9 and IE10
if (typeof CustomEvent !== 'function') {
  // Code from: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent
  var CustomEvent = function(event, options) {
    options = options || { bubbles: false, cancelable: false, detail: undefined }
    var e = document.createEvent('CustomEvent')
    e.initCustomEvent(event, options.bubbles, options.cancelable, options.detail)
    return e
  }

  CustomEvent.prototype = window.Event.prototype

  window.CustomEvent = CustomEvent
}

// requestAnimationFrame / cancelAnimationFrame Polyfill with fallback based on Paul Irish
(function(w) {
  var lastTime = 0
  var vendors = ['moz', 'webkit']

  for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    w.requestAnimationFrame = w[vendors[x] + 'RequestAnimationFrame']
    w.cancelAnimationFrame  = w[vendors[x] + 'CancelAnimationFrame'] ||
                              w[vendors[x] + 'CancelRequestAnimationFrame']
  }

  w.requestAnimationFrame = w.requestAnimationFrame ||
    function(callback) {
      var currTime = new Date().getTime()
      var timeToCall = Math.max(0, 16 - (currTime - lastTime))

      var id = w.setTimeout(function() {
        callback(currTime + timeToCall)
      }, timeToCall)

      lastTime = currTime + timeToCall
      return id
    }

  w.cancelAnimationFrame = w.cancelAnimationFrame || w.clearTimeout;

}(window))

return SVG

}));
},{}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _fitCurve = require('fit-curve');

var _fitCurve2 = _interopRequireDefault(_fitCurve);

var _LevelCurve = require('../model/LevelCurve');

var _LevelCurve2 = _interopRequireDefault(_LevelCurve);

var _UIManagement = require('../model/UIManagement');

var UI = _interopRequireWildcard(_UIManagement);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var error = 100;

function PaintControl(pannel) {
	var rawPointData = [];
	var paintingPolyLine = undefined;

	this.start = function (point) {
		rawPointData.push(point);
		paintingPolyLine = pannel.polyline().fill('none').stroke({ width: 1 });
	};
	this.update = function (point) {
		rawPointData.push(point);
		updateLines(paintingPolyLine, rawPointData);
	};

	this.end = function () {
		var smoothBizer = (0, _fitCurve2.default)(rawPointData, error);
		if (smoothBizer.length == 0) {
			clearRawData();
			return;
		}
		var pathString = fittedCurveToPathString(smoothBizer);

		drawOnPannel(pannel, pathString);

		var lvCurve = new _LevelCurve2.default(smoothBizer, 1, UI.state.levelCurve);
		lvCurve.drawOn(pannel);

		clearRawData();
	};

	function updateLines(paintingPolyLine, rawPointData) {
		paintingPolyLine.plot(rawPointData);
	}
	function fittedCurveToPathString(fittedLineData) {
		var str = '';
		//bezier : [ [c0], [c1], [c2], [c3] ]
		fittedLineData.map(function (bezier, i) {
			if (i == 0) {
				str += 'M ' + bezier[0][0] + ' ' + bezier[0][1];
			}

			str += 'C ' + bezier[1][0] + ' ' + bezier[1][1] + ', ' + bezier[2][0] + ' ' + bezier[2][1] + ', ' + bezier[3][0] + ' ' + bezier[3][1] + ' ';
		});

		return str;
	}
	function drawOnPannel(pannel, pathString) {
		pannel.path(pathString).fill('none').stroke({ width: 3 }).stroke('#f06');
	}
	function clearRawData() {
		rawPointData.length = 0;
		paintingPolyLine.remove();
	}
}

exports.default = PaintControl;

},{"../model/LevelCurve":12,"../model/UIManagement":14,"fit-curve":5}],8:[function(require,module,exports){
'use strict';

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function webpackUniversalModuleDefinition(root, factory) {
	if ((typeof exports === 'undefined' ? 'undefined' : _typeof2(exports)) === 'object' && (typeof module === 'undefined' ? 'undefined' : _typeof2(module)) === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define([], factory);else if ((typeof exports === 'undefined' ? 'undefined' : _typeof2(exports)) === 'object') exports["dat"] = factory();else root["dat"] = factory();
})(undefined, function () {
	return (/******/function (modules) {
			// webpackBootstrap
			/******/ // The module cache
			/******/var installedModules = {};
			/******/
			/******/ // The require function
			/******/function __webpack_require__(moduleId) {
				/******/
				/******/ // Check if module is in cache
				/******/if (installedModules[moduleId])
					/******/return installedModules[moduleId].exports;
				/******/
				/******/ // Create a new module (and put it into the cache)
				/******/var module = installedModules[moduleId] = {
					/******/exports: {},
					/******/id: moduleId,
					/******/loaded: false
					/******/ };
				/******/
				/******/ // Execute the module function
				/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
				/******/
				/******/ // Flag the module as loaded
				/******/module.loaded = true;
				/******/
				/******/ // Return the exports of the module
				/******/return module.exports;
				/******/
			}
			/******/
			/******/
			/******/ // expose the modules object (__webpack_modules__)
			/******/__webpack_require__.m = modules;
			/******/
			/******/ // expose the module cache
			/******/__webpack_require__.c = installedModules;
			/******/
			/******/ // __webpack_public_path__
			/******/__webpack_require__.p = "";
			/******/
			/******/ // Load entry module and return exports
			/******/return __webpack_require__(0);
			/******/
		}(
		/************************************************************************/
		/******/[
		/* 0 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var _index = __webpack_require__(1);

			var _index2 = _interopRequireDefault(_index);

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}

			module.exports = _index2.default; /**
                                      * dat-gui JavaScript Controller Library
                                      * http://code.google.com/p/dat-gui
                                      *
                                      * Copyright 2011 Data Arts Team, Google Creative Lab
                                      *
                                      * Licensed under the Apache License, Version 2.0 (the "License");
                                      * you may not use this file except in compliance with the License.
                                      * You may obtain a copy of the License at
                                      *
                                      * http://www.apache.org/licenses/LICENSE-2.0
                                      */

			/***/
		},
		/* 1 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			exports.__esModule = true;

			var _Color = __webpack_require__(2);

			var _Color2 = _interopRequireDefault(_Color);

			var _math = __webpack_require__(6);

			var _math2 = _interopRequireDefault(_math);

			var _interpret = __webpack_require__(3);

			var _interpret2 = _interopRequireDefault(_interpret);

			var _Controller = __webpack_require__(7);

			var _Controller2 = _interopRequireDefault(_Controller);

			var _BooleanController = __webpack_require__(8);

			var _BooleanController2 = _interopRequireDefault(_BooleanController);

			var _OptionController = __webpack_require__(10);

			var _OptionController2 = _interopRequireDefault(_OptionController);

			var _StringController = __webpack_require__(11);

			var _StringController2 = _interopRequireDefault(_StringController);

			var _NumberController = __webpack_require__(12);

			var _NumberController2 = _interopRequireDefault(_NumberController);

			var _NumberControllerBox = __webpack_require__(13);

			var _NumberControllerBox2 = _interopRequireDefault(_NumberControllerBox);

			var _NumberControllerSlider = __webpack_require__(14);

			var _NumberControllerSlider2 = _interopRequireDefault(_NumberControllerSlider);

			var _FunctionController = __webpack_require__(15);

			var _FunctionController2 = _interopRequireDefault(_FunctionController);

			var _ColorController = __webpack_require__(16);

			var _ColorController2 = _interopRequireDefault(_ColorController);

			var _dom = __webpack_require__(9);

			var _dom2 = _interopRequireDefault(_dom);

			var _GUI = __webpack_require__(17);

			var _GUI2 = _interopRequireDefault(_GUI);

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}

			/**
    * dat-gui JavaScript Controller Library
    * http://code.google.com/p/dat-gui
    *
    * Copyright 2011 Data Arts Team, Google Creative Lab
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    */

			exports.default = {
				color: {
					Color: _Color2.default,
					math: _math2.default,
					interpret: _interpret2.default
				},

				controllers: {
					Controller: _Controller2.default,
					BooleanController: _BooleanController2.default,
					OptionController: _OptionController2.default,
					StringController: _StringController2.default,
					NumberController: _NumberController2.default,
					NumberControllerBox: _NumberControllerBox2.default,
					NumberControllerSlider: _NumberControllerSlider2.default,
					FunctionController: _FunctionController2.default,
					ColorController: _ColorController2.default
				},

				dom: {
					dom: _dom2.default
				},

				gui: {
					GUI: _GUI2.default
				},

				GUI: _GUI2.default
			};

			/***/
		},
		/* 2 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			exports.__esModule = true;

			var _interpret = __webpack_require__(3);

			var _interpret2 = _interopRequireDefault(_interpret);

			var _math = __webpack_require__(6);

			var _math2 = _interopRequireDefault(_math);

			var _toString = __webpack_require__(4);

			var _toString2 = _interopRequireDefault(_toString);

			var _common = __webpack_require__(5);

			var _common2 = _interopRequireDefault(_common);

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}

			function _classCallCheck(instance, Constructor) {
				if (!(instance instanceof Constructor)) {
					throw new TypeError("Cannot call a class as a function");
				}
			} /**
      * dat-gui JavaScript Controller Library
      * http://code.google.com/p/dat-gui
      *
      * Copyright 2011 Data Arts Team, Google Creative Lab
      *
      * Licensed under the Apache License, Version 2.0 (the "License");
      * you may not use this file except in compliance with the License.
      * You may obtain a copy of the License at
      *
      * http://www.apache.org/licenses/LICENSE-2.0
      */

			var Color = function () {
				function Color() {
					_classCallCheck(this, Color);

					this.__state = _interpret2.default.apply(this, arguments);

					if (this.__state === false) {
						throw new Error('Failed to interpret color arguments');
					}

					this.__state.a = this.__state.a || 1;
				}

				Color.prototype.toString = function toString() {
					return (0, _toString2.default)(this);
				};

				Color.prototype.toHexString = function toHexString() {
					return (0, _toString2.default)(this, true);
				};

				Color.prototype.toOriginal = function toOriginal() {
					return this.__state.conversion.write(this);
				};

				return Color;
			}();

			function defineRGBComponent(target, component, componentHexIndex) {
				Object.defineProperty(target, component, {
					get: function get() {
						if (this.__state.space === 'RGB') {
							return this.__state[component];
						}

						Color.recalculateRGB(this, component, componentHexIndex);

						return this.__state[component];
					},

					set: function set(v) {
						if (this.__state.space !== 'RGB') {
							Color.recalculateRGB(this, component, componentHexIndex);
							this.__state.space = 'RGB';
						}

						this.__state[component] = v;
					}
				});
			}

			function defineHSVComponent(target, component) {
				Object.defineProperty(target, component, {
					get: function get() {
						if (this.__state.space === 'HSV') {
							return this.__state[component];
						}

						Color.recalculateHSV(this);

						return this.__state[component];
					},

					set: function set(v) {
						if (this.__state.space !== 'HSV') {
							Color.recalculateHSV(this);
							this.__state.space = 'HSV';
						}

						this.__state[component] = v;
					}
				});
			}

			Color.recalculateRGB = function (color, component, componentHexIndex) {
				if (color.__state.space === 'HEX') {
					color.__state[component] = _math2.default.component_from_hex(color.__state.hex, componentHexIndex);
				} else if (color.__state.space === 'HSV') {
					_common2.default.extend(color.__state, _math2.default.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));
				} else {
					throw new Error('Corrupted color state');
				}
			};

			Color.recalculateHSV = function (color) {
				var result = _math2.default.rgb_to_hsv(color.r, color.g, color.b);

				_common2.default.extend(color.__state, {
					s: result.s,
					v: result.v
				});

				if (!_common2.default.isNaN(result.h)) {
					color.__state.h = result.h;
				} else if (_common2.default.isUndefined(color.__state.h)) {
					color.__state.h = 0;
				}
			};

			Color.COMPONENTS = ['r', 'g', 'b', 'h', 's', 'v', 'hex', 'a'];

			defineRGBComponent(Color.prototype, 'r', 2);
			defineRGBComponent(Color.prototype, 'g', 1);
			defineRGBComponent(Color.prototype, 'b', 0);

			defineHSVComponent(Color.prototype, 'h');
			defineHSVComponent(Color.prototype, 's');
			defineHSVComponent(Color.prototype, 'v');

			Object.defineProperty(Color.prototype, 'a', {
				get: function get() {
					return this.__state.a;
				},

				set: function set(v) {
					this.__state.a = v;
				}
			});

			Object.defineProperty(Color.prototype, 'hex', {
				get: function get() {
					if (!this.__state.space !== 'HEX') {
						this.__state.hex = _math2.default.rgb_to_hex(this.r, this.g, this.b);
					}

					return this.__state.hex;
				},

				set: function set(v) {
					this.__state.space = 'HEX';
					this.__state.hex = v;
				}
			});

			exports.default = Color;

			/***/
		},
		/* 3 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			exports.__esModule = true;

			var _toString = __webpack_require__(4);

			var _toString2 = _interopRequireDefault(_toString);

			var _common = __webpack_require__(5);

			var _common2 = _interopRequireDefault(_common);

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}

			/**
    * dat-gui JavaScript Controller Library
    * http://code.google.com/p/dat-gui
    *
    * Copyright 2011 Data Arts Team, Google Creative Lab
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    */

			var INTERPRETATIONS = [
			// Strings
			{
				litmus: _common2.default.isString,
				conversions: {
					THREE_CHAR_HEX: {
						read: function read(original) {
							var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
							if (test === null) {
								return false;
							}

							return {
								space: 'HEX',
								hex: parseInt('0x' + test[1].toString() + test[1].toString() + test[2].toString() + test[2].toString() + test[3].toString() + test[3].toString(), 0)
							};
						},

						write: _toString2.default
					},

					SIX_CHAR_HEX: {
						read: function read(original) {
							var test = original.match(/^#([A-F0-9]{6})$/i);
							if (test === null) {
								return false;
							}

							return {
								space: 'HEX',
								hex: parseInt('0x' + test[1].toString(), 0)
							};
						},

						write: _toString2.default
					},

					CSS_RGB: {
						read: function read(original) {
							var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
							if (test === null) {
								return false;
							}

							return {
								space: 'RGB',
								r: parseFloat(test[1]),
								g: parseFloat(test[2]),
								b: parseFloat(test[3])
							};
						},

						write: _toString2.default
					},

					CSS_RGBA: {
						read: function read(original) {
							var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
							if (test === null) {
								return false;
							}

							return {
								space: 'RGB',
								r: parseFloat(test[1]),
								g: parseFloat(test[2]),
								b: parseFloat(test[3]),
								a: parseFloat(test[4])
							};
						},

						write: _toString2.default
					}
				}
			},

			// Numbers
			{
				litmus: _common2.default.isNumber,

				conversions: {

					HEX: {
						read: function read(original) {
							return {
								space: 'HEX',
								hex: original,
								conversionName: 'HEX'
							};
						},

						write: function write(color) {
							return color.hex;
						}
					}

				}

			},

			// Arrays
			{
				litmus: _common2.default.isArray,
				conversions: {
					RGB_ARRAY: {
						read: function read(original) {
							if (original.length !== 3) {
								return false;
							}

							return {
								space: 'RGB',
								r: original[0],
								g: original[1],
								b: original[2]
							};
						},

						write: function write(color) {
							return [color.r, color.g, color.b];
						}
					},

					RGBA_ARRAY: {
						read: function read(original) {
							if (original.length !== 4) return false;
							return {
								space: 'RGB',
								r: original[0],
								g: original[1],
								b: original[2],
								a: original[3]
							};
						},

						write: function write(color) {
							return [color.r, color.g, color.b, color.a];
						}
					}
				}
			},

			// Objects
			{
				litmus: _common2.default.isObject,
				conversions: {

					RGBA_OBJ: {
						read: function read(original) {
							if (_common2.default.isNumber(original.r) && _common2.default.isNumber(original.g) && _common2.default.isNumber(original.b) && _common2.default.isNumber(original.a)) {
								return {
									space: 'RGB',
									r: original.r,
									g: original.g,
									b: original.b,
									a: original.a
								};
							}
							return false;
						},

						write: function write(color) {
							return {
								r: color.r,
								g: color.g,
								b: color.b,
								a: color.a
							};
						}
					},

					RGB_OBJ: {
						read: function read(original) {
							if (_common2.default.isNumber(original.r) && _common2.default.isNumber(original.g) && _common2.default.isNumber(original.b)) {
								return {
									space: 'RGB',
									r: original.r,
									g: original.g,
									b: original.b
								};
							}
							return false;
						},

						write: function write(color) {
							return {
								r: color.r,
								g: color.g,
								b: color.b
							};
						}
					},

					HSVA_OBJ: {
						read: function read(original) {
							if (_common2.default.isNumber(original.h) && _common2.default.isNumber(original.s) && _common2.default.isNumber(original.v) && _common2.default.isNumber(original.a)) {
								return {
									space: 'HSV',
									h: original.h,
									s: original.s,
									v: original.v,
									a: original.a
								};
							}
							return false;
						},

						write: function write(color) {
							return {
								h: color.h,
								s: color.s,
								v: color.v,
								a: color.a
							};
						}
					},

					HSV_OBJ: {
						read: function read(original) {
							if (_common2.default.isNumber(original.h) && _common2.default.isNumber(original.s) && _common2.default.isNumber(original.v)) {
								return {
									space: 'HSV',
									h: original.h,
									s: original.s,
									v: original.v
								};
							}
							return false;
						},

						write: function write(color) {
							return {
								h: color.h,
								s: color.s,
								v: color.v
							};
						}
					}
				}
			}];

			var result = void 0;
			var toReturn = void 0;

			var interpret = function interpret() {
				toReturn = false;

				var original = arguments.length > 1 ? _common2.default.toArray(arguments) : arguments[0];
				_common2.default.each(INTERPRETATIONS, function (family) {
					if (family.litmus(original)) {
						_common2.default.each(family.conversions, function (conversion, conversionName) {
							result = conversion.read(original);

							if (toReturn === false && result !== false) {
								toReturn = result;
								result.conversionName = conversionName;
								result.conversion = conversion;
								return _common2.default.BREAK;
							}
						});

						return _common2.default.BREAK;
					}
				});

				return toReturn;
			};

			exports.default = interpret;

			/***/
		},
		/* 4 */
		/***/function (module, exports) {

			'use strict';

			exports.__esModule = true;

			exports.default = function (color, forceCSSHex) {
				var colorFormat = color.__state.conversionName.toString();

				var r = Math.round(color.r);
				var g = Math.round(color.g);
				var b = Math.round(color.b);
				var a = color.a;
				var h = Math.round(color.h);
				var s = color.s.toFixed(1);
				var v = color.v.toFixed(1);

				if (forceCSSHex || colorFormat === 'THREE_CHAR_HEX' || colorFormat === 'SIX_CHAR_HEX') {
					var str = color.hex.toString(16);
					while (str.length < 6) {
						str = '0' + str;
					}
					return '#' + str;
				} else if (colorFormat === 'CSS_RGB') {
					return 'rgb(' + r + ',' + g + ',' + b + ')';
				} else if (colorFormat === 'CSS_RGBA') {
					return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
				} else if (colorFormat === 'HEX') {
					return '0x' + color.hex.toString(16);
				} else if (colorFormat === 'RGB_ARRAY') {
					return '[' + r + ',' + g + ',' + b + ']';
				} else if (colorFormat === 'RGBA_ARRAY') {
					return '[' + r + ',' + g + ',' + b + ',' + a + ']';
				} else if (colorFormat === 'RGB_OBJ') {
					return '{r:' + r + ',g:' + g + ',b:' + b + '}';
				} else if (colorFormat === 'RGBA_OBJ') {
					return '{r:' + r + ',g:' + g + ',b:' + b + ',a:' + a + '}';
				} else if (colorFormat === 'HSV_OBJ') {
					return '{h:' + h + ',s:' + s + ',v:' + v + '}';
				} else if (colorFormat === 'HSVA_OBJ') {
					return '{h:' + h + ',s:' + s + ',v:' + v + ',a:' + a + '}';
				}

				return 'unknown format';
			};

			/***/
		},
		/* 5 */
		/***/function (module, exports) {

			'use strict';

			exports.__esModule = true;
			/**
    * dat-gui JavaScript Controller Library
    * http://code.google.com/p/dat-gui
    *
    * Copyright 2011 Data Arts Team, Google Creative Lab
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    */

			var ARR_EACH = Array.prototype.forEach;
			var ARR_SLICE = Array.prototype.slice;

			/**
    * Band-aid methods for things that should be a lot easier in JavaScript.
    * Implementation and structure inspired by underscore.js
    * http://documentcloud.github.com/underscore/
    */

			var Common = {
				BREAK: {},

				extend: function extend(target) {
					this.each(ARR_SLICE.call(arguments, 1), function (obj) {
						var keys = this.isObject(obj) ? Object.keys(obj) : [];
						keys.forEach(function (key) {
							if (!this.isUndefined(obj[key])) {
								target[key] = obj[key];
							}
						}.bind(this));
					}, this);

					return target;
				},

				defaults: function defaults(target) {
					this.each(ARR_SLICE.call(arguments, 1), function (obj) {
						var keys = this.isObject(obj) ? Object.keys(obj) : [];
						keys.forEach(function (key) {
							if (this.isUndefined(target[key])) {
								target[key] = obj[key];
							}
						}.bind(this));
					}, this);

					return target;
				},

				compose: function compose() {
					var toCall = ARR_SLICE.call(arguments);
					return function () {
						var args = ARR_SLICE.call(arguments);
						for (var i = toCall.length - 1; i >= 0; i--) {
							args = [toCall[i].apply(this, args)];
						}
						return args[0];
					};
				},

				each: function each(obj, itr, scope) {
					if (!obj) {
						return;
					}

					if (ARR_EACH && obj.forEach && obj.forEach === ARR_EACH) {
						obj.forEach(itr, scope);
					} else if (obj.length === obj.length + 0) {
						// Is number but not NaN
						var key = void 0;
						var l = void 0;
						for (key = 0, l = obj.length; key < l; key++) {
							if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) {
								return;
							}
						}
					} else {
						for (var _key in obj) {
							if (itr.call(scope, obj[_key], _key) === this.BREAK) {
								return;
							}
						}
					}
				},

				defer: function defer(fnc) {
					setTimeout(fnc, 0);
				},

				// call the function immediately, but wait until threshold passes to allow it to be called again
				debounce: function debounce(func, threshold) {
					var timeout = void 0;

					return function () {
						var obj = this;
						var args = arguments;
						function delayed() {
							timeout = null;
						}

						var allowCall = !timeout;

						clearTimeout(timeout);
						timeout = setTimeout(delayed, threshold);

						if (allowCall) {
							func.apply(obj, args);
						}
					};
				},

				toArray: function toArray(obj) {
					if (obj.toArray) return obj.toArray();
					return ARR_SLICE.call(obj);
				},

				isUndefined: function isUndefined(obj) {
					return obj === undefined;
				},

				isNull: function isNull(obj) {
					return obj === null;
				},

				isNaN: function (_isNaN) {
					function isNaN(_x) {
						return _isNaN.apply(this, arguments);
					}

					isNaN.toString = function () {
						return _isNaN.toString();
					};

					return isNaN;
				}(function (obj) {
					return isNaN(obj);
				}),

				isArray: Array.isArray || function (obj) {
					return obj.constructor === Array;
				},

				isObject: function isObject(obj) {
					return obj === Object(obj);
				},

				isNumber: function isNumber(obj) {
					return obj === obj + 0;
				},

				isString: function isString(obj) {
					return obj === obj + '';
				},

				isBoolean: function isBoolean(obj) {
					return obj === false || obj === true;
				},

				isFunction: function isFunction(obj) {
					return Object.prototype.toString.call(obj) === '[object Function]';
				}

			};

			exports.default = Common;

			/***/
		},
		/* 6 */
		/***/function (module, exports) {

			"use strict";

			exports.__esModule = true;
			/**
    * dat-gui JavaScript Controller Library
    * http://code.google.com/p/dat-gui
    *
    * Copyright 2011 Data Arts Team, Google Creative Lab
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    */

			var tmpComponent = void 0;

			var ColorMath = {
				hsv_to_rgb: function hsv_to_rgb(h, s, v) {
					var hi = Math.floor(h / 60) % 6;

					var f = h / 60 - Math.floor(h / 60);
					var p = v * (1.0 - s);
					var q = v * (1.0 - f * s);
					var t = v * (1.0 - (1.0 - f) * s);

					var c = [[v, t, p], [q, v, p], [p, v, t], [p, q, v], [t, p, v], [v, p, q]][hi];

					return {
						r: c[0] * 255,
						g: c[1] * 255,
						b: c[2] * 255
					};
				},

				rgb_to_hsv: function rgb_to_hsv(r, g, b) {
					var min = Math.min(r, g, b);
					var max = Math.max(r, g, b);
					var delta = max - min;
					var h = void 0;
					var s = void 0;

					if (max !== 0) {
						s = delta / max;
					} else {
						return {
							h: NaN,
							s: 0,
							v: 0
						};
					}

					if (r === max) {
						h = (g - b) / delta;
					} else if (g === max) {
						h = 2 + (b - r) / delta;
					} else {
						h = 4 + (r - g) / delta;
					}
					h /= 6;
					if (h < 0) {
						h += 1;
					}

					return {
						h: h * 360,
						s: s,
						v: max / 255
					};
				},

				rgb_to_hex: function rgb_to_hex(r, g, b) {
					var hex = this.hex_with_component(0, 2, r);
					hex = this.hex_with_component(hex, 1, g);
					hex = this.hex_with_component(hex, 0, b);
					return hex;
				},

				component_from_hex: function component_from_hex(hex, componentIndex) {
					return hex >> componentIndex * 8 & 0xFF;
				},

				hex_with_component: function hex_with_component(hex, componentIndex, value) {
					return value << (tmpComponent = componentIndex * 8) | hex & ~(0xFF << tmpComponent);
				}
			};

			exports.default = ColorMath;

			/***/
		},
		/* 7 */
		/***/function (module, exports) {

			'use strict';

			exports.__esModule = true;

			function _classCallCheck(instance, Constructor) {
				if (!(instance instanceof Constructor)) {
					throw new TypeError("Cannot call a class as a function");
				}
			}

			/**
    * dat-gui JavaScript Controller Library
    * http://code.google.com/p/dat-gui
    *
    * Copyright 2011 Data Arts Team, Google Creative Lab
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    */

			/**
    * @class An "abstract" class that represents a given property of an object.
    *
    * @param {Object} object The object to be manipulated
    * @param {string} property The name of the property to be manipulated
    *
    * @member dat.controllers
    */
			var Controller = function () {
				function Controller(object, property) {
					_classCallCheck(this, Controller);

					this.initialValue = object[property];

					/**
      * Those who extend this class will put their DOM elements in here.
      * @type {DOMElement}
      */
					this.domElement = document.createElement('div');

					/**
      * The object to manipulate
      * @type {Object}
      */
					this.object = object;

					/**
      * The name of the property to manipulate
      * @type {String}
      */
					this.property = property;

					/**
      * The function to be called on change.
      * @type {Function}
      * @ignore
      */
					this.__onChange = undefined;

					/**
      * The function to be called on finishing change.
      * @type {Function}
      * @ignore
      */
					this.__onFinishChange = undefined;
				}

				/**
     * Specify that a function fire every time someone changes the value with
     * this Controller.
     *
     * @param {Function} fnc This function will be called whenever the value
     * is modified via this Controller.
     * @returns {Controller} this
     */

				Controller.prototype.onChange = function onChange(fnc) {
					this.__onChange = fnc;
					return this;
				};

				/**
     * Specify that a function fire every time someone "finishes" changing
     * the value wih this Controller. Useful for values that change
     * incrementally like numbers or strings.
     *
     * @param {Function} fnc This function will be called whenever
     * someone "finishes" changing the value via this Controller.
     * @returns {Controller} this
     */

				Controller.prototype.onFinishChange = function onFinishChange(fnc) {
					this.__onFinishChange = fnc;
					return this;
				};

				/**
     * Change the value of <code>object[property]</code>
     *
     * @param {Object} newValue The new value of <code>object[property]</code>
     */

				Controller.prototype.setValue = function setValue(newValue) {
					this.object[this.property] = newValue;
					if (this.__onChange) {
						this.__onChange.call(this, newValue);
					}

					this.updateDisplay();
					return this;
				};

				/**
     * Gets the value of <code>object[property]</code>
     *
     * @returns {Object} The current value of <code>object[property]</code>
     */

				Controller.prototype.getValue = function getValue() {
					return this.object[this.property];
				};

				/**
     * Refreshes the visual display of a Controller in order to keep sync
     * with the object's current value.
     * @returns {Controller} this
     */

				Controller.prototype.updateDisplay = function updateDisplay() {
					return this;
				};

				/**
     * @returns {Boolean} true if the value has deviated from initialValue
     */

				Controller.prototype.isModified = function isModified() {
					return this.initialValue !== this.getValue();
				};

				return Controller;
			}();

			exports.default = Controller;

			/***/
		},
		/* 8 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			exports.__esModule = true;

			var _Controller2 = __webpack_require__(7);

			var _Controller3 = _interopRequireDefault(_Controller2);

			var _dom = __webpack_require__(9);

			var _dom2 = _interopRequireDefault(_dom);

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}

			function _classCallCheck(instance, Constructor) {
				if (!(instance instanceof Constructor)) {
					throw new TypeError("Cannot call a class as a function");
				}
			}

			function _possibleConstructorReturn(self, call) {
				if (!self) {
					throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
				}return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
			}

			function _inherits(subClass, superClass) {
				if (typeof superClass !== "function" && superClass !== null) {
					throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass)));
				}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
			} /**
      * dat-gui JavaScript Controller Library
      * http://code.google.com/p/dat-gui
      *
      * Copyright 2011 Data Arts Team, Google Creative Lab
      *
      * Licensed under the Apache License, Version 2.0 (the "License");
      * you may not use this file except in compliance with the License.
      * You may obtain a copy of the License at
      *
      * http://www.apache.org/licenses/LICENSE-2.0
      */

			/**
    * @class Provides a checkbox input to alter the boolean property of an object.
    * @extends dat.controllers.Controller
    *
    * @param {Object} object The object to be manipulated
    * @param {string} property The name of the property to be manipulated
    *
    * @member dat.controllers
    */
			var BooleanController = function (_Controller) {
				_inherits(BooleanController, _Controller);

				function BooleanController(object, property) {
					_classCallCheck(this, BooleanController);

					var _this2 = _possibleConstructorReturn(this, _Controller.call(this, object, property));

					var _this = _this2;
					_this2.__prev = _this2.getValue();

					_this2.__checkbox = document.createElement('input');
					_this2.__checkbox.setAttribute('type', 'checkbox');

					function onChange() {
						_this.setValue(!_this.__prev);
					}

					_dom2.default.bind(_this2.__checkbox, 'change', onChange, false);

					_this2.domElement.appendChild(_this2.__checkbox);

					// Match original value
					_this2.updateDisplay();
					return _this2;
				}

				BooleanController.prototype.setValue = function setValue(v) {
					var toReturn = _Controller.prototype.setValue.call(this, v);
					if (this.__onFinishChange) {
						this.__onFinishChange.call(this, this.getValue());
					}
					this.__prev = this.getValue();
					return toReturn;
				};

				BooleanController.prototype.updateDisplay = function updateDisplay() {
					if (this.getValue() === true) {
						this.__checkbox.setAttribute('checked', 'checked');
						this.__checkbox.checked = true;
					} else {
						this.__checkbox.checked = false;
					}

					return _Controller.prototype.updateDisplay.call(this);
				};

				return BooleanController;
			}(_Controller3.default);

			exports.default = BooleanController;

			/***/
		},
		/* 9 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			exports.__esModule = true;

			var _common = __webpack_require__(5);

			var _common2 = _interopRequireDefault(_common);

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}

			var EVENT_MAP = {
				HTMLEvents: ['change'],
				MouseEvents: ['click', 'mousemove', 'mousedown', 'mouseup', 'mouseover'],
				KeyboardEvents: ['keydown']
			}; /**
       * dat-gui JavaScript Controller Library
       * http://code.google.com/p/dat-gui
       *
       * Copyright 2011 Data Arts Team, Google Creative Lab
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       * http://www.apache.org/licenses/LICENSE-2.0
       */

			var EVENT_MAP_INV = {};
			_common2.default.each(EVENT_MAP, function (v, k) {
				_common2.default.each(v, function (e) {
					EVENT_MAP_INV[e] = k;
				});
			});

			var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;

			function cssValueToPixels(val) {
				if (val === '0' || _common2.default.isUndefined(val)) {
					return 0;
				}

				var match = val.match(CSS_VALUE_PIXELS);

				if (!_common2.default.isNull(match)) {
					return parseFloat(match[1]);
				}

				// TODO ...ems? %?

				return 0;
			}

			/**
    * @namespace
    * @member dat.dom
    */
			var dom = {

				/**
     *
     * @param elem
     * @param selectable
     */
				makeSelectable: function makeSelectable(elem, selectable) {
					if (elem === undefined || elem.style === undefined) return;

					elem.onselectstart = selectable ? function () {
						return false;
					} : function () {};

					elem.style.MozUserSelect = selectable ? 'auto' : 'none';
					elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
					elem.unselectable = selectable ? 'on' : 'off';
				},

				/**
     *
     * @param elem
     * @param horizontal
     * @param vert
     */
				makeFullscreen: function makeFullscreen(elem, hor, vert) {
					var vertical = vert;
					var horizontal = hor;

					if (_common2.default.isUndefined(horizontal)) {
						horizontal = true;
					}

					if (_common2.default.isUndefined(vertical)) {
						vertical = true;
					}

					elem.style.position = 'absolute';

					if (horizontal) {
						elem.style.left = 0;
						elem.style.right = 0;
					}
					if (vertical) {
						elem.style.top = 0;
						elem.style.bottom = 0;
					}
				},

				/**
     *
     * @param elem
     * @param eventType
     * @param params
     */
				fakeEvent: function fakeEvent(elem, eventType, pars, aux) {
					var params = pars || {};
					var className = EVENT_MAP_INV[eventType];
					if (!className) {
						throw new Error('Event type ' + eventType + ' not supported.');
					}
					var evt = document.createEvent(className);
					switch (className) {
						case 'MouseEvents':
							{
								var clientX = params.x || params.clientX || 0;
								var clientY = params.y || params.clientY || 0;
								evt.initMouseEvent(eventType, params.bubbles || false, params.cancelable || true, window, params.clickCount || 1, 0, // screen X
								0, // screen Y
								clientX, // client X
								clientY, // client Y
								false, false, false, false, 0, null);
								break;
							}
						case 'KeyboardEvents':
							{
								var init = evt.initKeyboardEvent || evt.initKeyEvent; // webkit || moz
								_common2.default.defaults(params, {
									cancelable: true,
									ctrlKey: false,
									altKey: false,
									shiftKey: false,
									metaKey: false,
									keyCode: undefined,
									charCode: undefined
								});
								init(eventType, params.bubbles || false, params.cancelable, window, params.ctrlKey, params.altKey, params.shiftKey, params.metaKey, params.keyCode, params.charCode);
								break;
							}
						default:
							{
								evt.initEvent(eventType, params.bubbles || false, params.cancelable || true);
								break;
							}
					}
					_common2.default.defaults(evt, aux);
					elem.dispatchEvent(evt);
				},

				/**
     *
     * @param elem
     * @param event
     * @param func
     * @param bool
     */
				bind: function bind(elem, event, func, newBool) {
					var bool = newBool || false;
					if (elem.addEventListener) {
						elem.addEventListener(event, func, bool);
					} else if (elem.attachEvent) {
						elem.attachEvent('on' + event, func);
					}
					return dom;
				},

				/**
     *
     * @param elem
     * @param event
     * @param func
     * @param bool
     */
				unbind: function unbind(elem, event, func, newBool) {
					var bool = newBool || false;
					if (elem.removeEventListener) {
						elem.removeEventListener(event, func, bool);
					} else if (elem.detachEvent) {
						elem.detachEvent('on' + event, func);
					}
					return dom;
				},

				/**
     *
     * @param elem
     * @param className
     */
				addClass: function addClass(elem, className) {
					if (elem.className === undefined) {
						elem.className = className;
					} else if (elem.className !== className) {
						var classes = elem.className.split(/ +/);
						if (classes.indexOf(className) === -1) {
							classes.push(className);
							elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
						}
					}
					return dom;
				},

				/**
     *
     * @param elem
     * @param className
     */
				removeClass: function removeClass(elem, className) {
					if (className) {
						if (elem.className === className) {
							elem.removeAttribute('class');
						} else {
							var classes = elem.className.split(/ +/);
							var index = classes.indexOf(className);
							if (index !== -1) {
								classes.splice(index, 1);
								elem.className = classes.join(' ');
							}
						}
					} else {
						elem.className = undefined;
					}
					return dom;
				},

				hasClass: function hasClass(elem, className) {
					return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
				},

				/**
     *
     * @param elem
     */
				getWidth: function getWidth(elem) {
					var style = getComputedStyle(elem);

					return cssValueToPixels(style['border-left-width']) + cssValueToPixels(style['border-right-width']) + cssValueToPixels(style['padding-left']) + cssValueToPixels(style['padding-right']) + cssValueToPixels(style.width);
				},

				/**
     *
     * @param elem
     */
				getHeight: function getHeight(elem) {
					var style = getComputedStyle(elem);

					return cssValueToPixels(style['border-top-width']) + cssValueToPixels(style['border-bottom-width']) + cssValueToPixels(style['padding-top']) + cssValueToPixels(style['padding-bottom']) + cssValueToPixels(style.height);
				},

				/**
     *
     * @param el
     */
				getOffset: function getOffset(el) {
					var elem = el;
					var offset = { left: 0, top: 0 };
					if (elem.offsetParent) {
						do {
							offset.left += elem.offsetLeft;
							offset.top += elem.offsetTop;
							elem = elem.offsetParent;
						} while (elem);
					}
					return offset;
				},

				// http://stackoverflow.com/posts/2684561/revisions
				/**
     *
     * @param elem
     */
				isActive: function isActive(elem) {
					return elem === document.activeElement && (elem.type || elem.href);
				}

			};

			exports.default = dom;

			/***/
		},
		/* 10 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			exports.__esModule = true;

			var _Controller2 = __webpack_require__(7);

			var _Controller3 = _interopRequireDefault(_Controller2);

			var _dom = __webpack_require__(9);

			var _dom2 = _interopRequireDefault(_dom);

			var _common = __webpack_require__(5);

			var _common2 = _interopRequireDefault(_common);

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}

			function _classCallCheck(instance, Constructor) {
				if (!(instance instanceof Constructor)) {
					throw new TypeError("Cannot call a class as a function");
				}
			}

			function _possibleConstructorReturn(self, call) {
				if (!self) {
					throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
				}return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
			}

			function _inherits(subClass, superClass) {
				if (typeof superClass !== "function" && superClass !== null) {
					throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass)));
				}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
			} /**
      * dat-gui JavaScript Controller Library
      * http://code.google.com/p/dat-gui
      *
      * Copyright 2011 Data Arts Team, Google Creative Lab
      *
      * Licensed under the Apache License, Version 2.0 (the "License");
      * you may not use this file except in compliance with the License.
      * You may obtain a copy of the License at
      *
      * http://www.apache.org/licenses/LICENSE-2.0
      */

			/**
    * @class Provides a select input to alter the property of an object, using a
    * list of accepted values.
    *
    * @extends dat.controllers.Controller
    *
    * @param {Object} object The object to be manipulated
    * @param {string} property The name of the property to be manipulated
    * @param {Object|string[]} options A map of labels to acceptable values, or
    * a list of acceptable string values.
    *
    * @member dat.controllers
    */
			var OptionController = function (_Controller) {
				_inherits(OptionController, _Controller);

				function OptionController(object, property, opts) {
					_classCallCheck(this, OptionController);

					var _this2 = _possibleConstructorReturn(this, _Controller.call(this, object, property));

					var options = opts;

					var _this = _this2;

					/**
      * The drop down menu
      * @ignore
      */
					_this2.__select = document.createElement('select');

					if (_common2.default.isArray(options)) {
						(function () {
							var map = {};
							_common2.default.each(options, function (element) {
								map[element] = element;
							});
							options = map;
						})();
					}

					_common2.default.each(options, function (value, key) {
						var opt = document.createElement('option');
						opt.innerHTML = key;
						opt.setAttribute('value', value);
						_this.__select.appendChild(opt);
					});

					// Acknowledge original value
					_this2.updateDisplay();

					_dom2.default.bind(_this2.__select, 'change', function () {
						var desiredValue = this.options[this.selectedIndex].value;
						_this.setValue(desiredValue);
					});

					_this2.domElement.appendChild(_this2.__select);
					return _this2;
				}

				OptionController.prototype.setValue = function setValue(v) {
					var toReturn = _Controller.prototype.setValue.call(this, v);

					if (this.__onFinishChange) {
						this.__onFinishChange.call(this, this.getValue());
					}
					return toReturn;
				};

				OptionController.prototype.updateDisplay = function updateDisplay() {
					if (_dom2.default.isActive(this.__select)) return this; // prevent number from updating if user is trying to manually update
					this.__select.value = this.getValue();
					return _Controller.prototype.updateDisplay.call(this);
				};

				return OptionController;
			}(_Controller3.default);

			exports.default = OptionController;

			/***/
		},
		/* 11 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			exports.__esModule = true;

			var _Controller2 = __webpack_require__(7);

			var _Controller3 = _interopRequireDefault(_Controller2);

			var _dom = __webpack_require__(9);

			var _dom2 = _interopRequireDefault(_dom);

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}

			function _classCallCheck(instance, Constructor) {
				if (!(instance instanceof Constructor)) {
					throw new TypeError("Cannot call a class as a function");
				}
			}

			function _possibleConstructorReturn(self, call) {
				if (!self) {
					throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
				}return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
			}

			function _inherits(subClass, superClass) {
				if (typeof superClass !== "function" && superClass !== null) {
					throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass)));
				}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
			} /**
      * dat-gui JavaScript Controller Library
      * http://code.google.com/p/dat-gui
      *
      * Copyright 2011 Data Arts Team, Google Creative Lab
      *
      * Licensed under the Apache License, Version 2.0 (the "License");
      * you may not use this file except in compliance with the License.
      * You may obtain a copy of the License at
      *
      * http://www.apache.org/licenses/LICENSE-2.0
      */

			/**
    * @class Provides a text input to alter the string property of an object.
    *
    * @extends dat.controllers.Controller
    *
    * @param {Object} object The object to be manipulated
    * @param {string} property The name of the property to be manipulated
    *
    * @member dat.controllers
    */
			var StringController = function (_Controller) {
				_inherits(StringController, _Controller);

				function StringController(object, property) {
					_classCallCheck(this, StringController);

					var _this2 = _possibleConstructorReturn(this, _Controller.call(this, object, property));

					var _this = _this2;

					function onChange() {
						_this.setValue(_this.__input.value);
					}

					function onBlur() {
						if (_this.__onFinishChange) {
							_this.__onFinishChange.call(_this, _this.getValue());
						}
					}

					_this2.__input = document.createElement('input');
					_this2.__input.setAttribute('type', 'text');

					_dom2.default.bind(_this2.__input, 'keyup', onChange);
					_dom2.default.bind(_this2.__input, 'change', onChange);
					_dom2.default.bind(_this2.__input, 'blur', onBlur);
					_dom2.default.bind(_this2.__input, 'keydown', function (e) {
						if (e.keyCode === 13) {
							this.blur();
						}
					});

					_this2.updateDisplay();

					_this2.domElement.appendChild(_this2.__input);
					return _this2;
				}

				StringController.prototype.updateDisplay = function updateDisplay() {
					// Stops the caret from moving on account of:
					// keyup -> setValue -> updateDisplay
					if (!_dom2.default.isActive(this.__input)) {
						this.__input.value = this.getValue();
					}
					return _Controller.prototype.updateDisplay.call(this);
				};

				return StringController;
			}(_Controller3.default);

			exports.default = StringController;

			/***/
		},
		/* 12 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			exports.__esModule = true;

			var _Controller2 = __webpack_require__(7);

			var _Controller3 = _interopRequireDefault(_Controller2);

			var _common = __webpack_require__(5);

			var _common2 = _interopRequireDefault(_common);

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}

			function _classCallCheck(instance, Constructor) {
				if (!(instance instanceof Constructor)) {
					throw new TypeError("Cannot call a class as a function");
				}
			}

			function _possibleConstructorReturn(self, call) {
				if (!self) {
					throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
				}return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
			}

			function _inherits(subClass, superClass) {
				if (typeof superClass !== "function" && superClass !== null) {
					throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass)));
				}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
			} /**
      * dat-gui JavaScript Controller Library
      * http://code.google.com/p/dat-gui
      *
      * Copyright 2011 Data Arts Team, Google Creative Lab
      *
      * Licensed under the Apache License, Version 2.0 (the "License");
      * you may not use this file except in compliance with the License.
      * You may obtain a copy of the License at
      *
      * http://www.apache.org/licenses/LICENSE-2.0
      */

			function numDecimals(x) {
				var _x = x.toString();
				if (_x.indexOf('.') > -1) {
					return _x.length - _x.indexOf('.') - 1;
				}

				return 0;
			}

			/**
    * @class Represents a given property of an object that is a number.
    *
    * @extends dat.controllers.Controller
    *
    * @param {Object} object The object to be manipulated
    * @param {string} property The name of the property to be manipulated
    * @param {Object} [params] Optional parameters
    * @param {Number} [params.min] Minimum allowed value
    * @param {Number} [params.max] Maximum allowed value
    * @param {Number} [params.step] Increment by which to change value
    *
    * @member dat.controllers
    */

			var NumberController = function (_Controller) {
				_inherits(NumberController, _Controller);

				function NumberController(object, property, params) {
					_classCallCheck(this, NumberController);

					var _this = _possibleConstructorReturn(this, _Controller.call(this, object, property));

					var _params = params || {};

					_this.__min = _params.min;
					_this.__max = _params.max;
					_this.__step = _params.step;

					if (_common2.default.isUndefined(_this.__step)) {
						if (_this.initialValue === 0) {
							_this.__impliedStep = 1; // What are we, psychics?
						} else {
							// Hey Doug, check this out.
							_this.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(_this.initialValue)) / Math.LN10)) / 10;
						}
					} else {
						_this.__impliedStep = _this.__step;
					}

					_this.__precision = numDecimals(_this.__impliedStep);
					return _this;
				}

				NumberController.prototype.setValue = function setValue(v) {
					var _v = v;

					if (this.__min !== undefined && _v < this.__min) {
						_v = this.__min;
					} else if (this.__max !== undefined && _v > this.__max) {
						_v = this.__max;
					}

					if (this.__step !== undefined && _v % this.__step !== 0) {
						_v = Math.round(_v / this.__step) * this.__step;
					}

					return _Controller.prototype.setValue.call(this, _v);
				};

				/**
     * Specify a minimum value for <code>object[property]</code>.
     *
     * @param {Number} minValue The minimum value for
     * <code>object[property]</code>
     * @returns {dat.controllers.NumberController} this
     */

				NumberController.prototype.min = function min(v) {
					this.__min = v;
					return this;
				};

				/**
     * Specify a maximum value for <code>object[property]</code>.
     *
     * @param {Number} maxValue The maximum value for
     * <code>object[property]</code>
     * @returns {dat.controllers.NumberController} this
     */

				NumberController.prototype.max = function max(v) {
					this.__max = v;
					return this;
				};

				/**
     * Specify a step value that dat.controllers.NumberController
     * increments by.
     *
     * @param {Number} stepValue The step value for
     * dat.controllers.NumberController
     * @default if minimum and maximum specified increment is 1% of the
     * difference otherwise stepValue is 1
     * @returns {dat.controllers.NumberController} this
     */

				NumberController.prototype.step = function step(v) {
					this.__step = v;
					this.__impliedStep = v;
					this.__precision = numDecimals(v);
					return this;
				};

				return NumberController;
			}(_Controller3.default);

			exports.default = NumberController;

			/***/
		},
		/* 13 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			exports.__esModule = true;

			var _NumberController2 = __webpack_require__(12);

			var _NumberController3 = _interopRequireDefault(_NumberController2);

			var _dom = __webpack_require__(9);

			var _dom2 = _interopRequireDefault(_dom);

			var _common = __webpack_require__(5);

			var _common2 = _interopRequireDefault(_common);

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}

			function _classCallCheck(instance, Constructor) {
				if (!(instance instanceof Constructor)) {
					throw new TypeError("Cannot call a class as a function");
				}
			}

			function _possibleConstructorReturn(self, call) {
				if (!self) {
					throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
				}return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
			}

			function _inherits(subClass, superClass) {
				if (typeof superClass !== "function" && superClass !== null) {
					throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass)));
				}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
			} /**
      * dat-gui JavaScript Controller Library
      * http://code.google.com/p/dat-gui
      *
      * Copyright 2011 Data Arts Team, Google Creative Lab
      *
      * Licensed under the Apache License, Version 2.0 (the "License");
      * you may not use this file except in compliance with the License.
      * You may obtain a copy of the License at
      *
      * http://www.apache.org/licenses/LICENSE-2.0
      */

			function roundToDecimal(value, decimals) {
				var tenTo = Math.pow(10, decimals);
				return Math.round(value * tenTo) / tenTo;
			}

			/**
    * @class Represents a given property of an object that is a number and
    * provides an input element with which to manipulate it.
    *
    * @extends dat.controllers.Controller
    * @extends dat.controllers.NumberController
    *
    * @param {Object} object The object to be manipulated
    * @param {string} property The name of the property to be manipulated
    * @param {Object} [params] Optional parameters
    * @param {Number} [params.min] Minimum allowed value
    * @param {Number} [params.max] Maximum allowed value
    * @param {Number} [params.step] Increment by which to change value
    *
    * @member dat.controllers
    */

			var NumberControllerBox = function (_NumberController) {
				_inherits(NumberControllerBox, _NumberController);

				function NumberControllerBox(object, property, params) {
					_classCallCheck(this, NumberControllerBox);

					var _this2 = _possibleConstructorReturn(this, _NumberController.call(this, object, property, params));

					_this2.__truncationSuspended = false;

					var _this = _this2;

					/**
      * {Number} Previous mouse y position
      * @ignore
      */
					var prevY = void 0;

					function onChange() {
						var attempted = parseFloat(_this.__input.value);
						if (!_common2.default.isNaN(attempted)) {
							_this.setValue(attempted);
						}
					}

					function onFinish() {
						if (_this.__onFinishChange) {
							_this.__onFinishChange.call(_this, _this.getValue());
						}
					}

					function onBlur() {
						onFinish();
					}

					function onMouseDrag(e) {
						var diff = prevY - e.clientY;
						_this.setValue(_this.getValue() + diff * _this.__impliedStep);

						prevY = e.clientY;
					}

					function onMouseUp() {
						_dom2.default.unbind(window, 'mousemove', onMouseDrag);
						_dom2.default.unbind(window, 'mouseup', onMouseUp);
						onFinish();
					}

					function onMouseDown(e) {
						_dom2.default.bind(window, 'mousemove', onMouseDrag);
						_dom2.default.bind(window, 'mouseup', onMouseUp);
						prevY = e.clientY;
					}

					_this2.__input = document.createElement('input');
					_this2.__input.setAttribute('type', 'text');

					// Makes it so manually specified values are not truncated.

					_dom2.default.bind(_this2.__input, 'change', onChange);
					_dom2.default.bind(_this2.__input, 'blur', onBlur);
					_dom2.default.bind(_this2.__input, 'mousedown', onMouseDown);
					_dom2.default.bind(_this2.__input, 'keydown', function (e) {
						// When pressing enter, you can be as precise as you want.
						if (e.keyCode === 13) {
							_this.__truncationSuspended = true;
							this.blur();
							_this.__truncationSuspended = false;
							onFinish();
						}
					});

					_this2.updateDisplay();

					_this2.domElement.appendChild(_this2.__input);
					return _this2;
				}

				NumberControllerBox.prototype.updateDisplay = function updateDisplay() {
					this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
					return _NumberController.prototype.updateDisplay.call(this);
				};

				return NumberControllerBox;
			}(_NumberController3.default);

			exports.default = NumberControllerBox;

			/***/
		},
		/* 14 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			exports.__esModule = true;

			var _NumberController2 = __webpack_require__(12);

			var _NumberController3 = _interopRequireDefault(_NumberController2);

			var _dom = __webpack_require__(9);

			var _dom2 = _interopRequireDefault(_dom);

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}

			function _classCallCheck(instance, Constructor) {
				if (!(instance instanceof Constructor)) {
					throw new TypeError("Cannot call a class as a function");
				}
			}

			function _possibleConstructorReturn(self, call) {
				if (!self) {
					throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
				}return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
			}

			function _inherits(subClass, superClass) {
				if (typeof superClass !== "function" && superClass !== null) {
					throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass)));
				}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
			} /**
      * dat-gui JavaScript Controller Library
      * http://code.google.com/p/dat-gui
      *
      * Copyright 2011 Data Arts Team, Google Creative Lab
      *
      * Licensed under the Apache License, Version 2.0 (the "License");
      * you may not use this file except in compliance with the License.
      * You may obtain a copy of the License at
      *
      * http://www.apache.org/licenses/LICENSE-2.0
      */

			function map(v, i1, i2, o1, o2) {
				return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
			}

			/**
    * @class Represents a given property of an object that is a number, contains
    * a minimum and maximum, and provides a slider element with which to
    * manipulate it. It should be noted that the slider element is made up of
    * <code>&lt;div&gt;</code> tags, <strong>not</strong> the html5
    * <code>&lt;slider&gt;</code> element.
    *
    * @extends dat.controllers.Controller
    * @extends dat.controllers.NumberController
    *
    * @param {Object} object The object to be manipulated
    * @param {string} property The name of the property to be manipulated
    * @param {Number} minValue Minimum allowed value
    * @param {Number} maxValue Maximum allowed value
    * @param {Number} stepValue Increment by which to change value
    *
    * @member dat.controllers
    */

			var NumberControllerSlider = function (_NumberController) {
				_inherits(NumberControllerSlider, _NumberController);

				function NumberControllerSlider(object, property, min, max, step) {
					_classCallCheck(this, NumberControllerSlider);

					var _this2 = _possibleConstructorReturn(this, _NumberController.call(this, object, property, { min: min, max: max, step: step }));

					var _this = _this2;

					_this2.__background = document.createElement('div');
					_this2.__foreground = document.createElement('div');

					_dom2.default.bind(_this2.__background, 'mousedown', onMouseDown);

					_dom2.default.addClass(_this2.__background, 'slider');
					_dom2.default.addClass(_this2.__foreground, 'slider-fg');

					function onMouseDown(e) {
						document.activeElement.blur();

						_dom2.default.bind(window, 'mousemove', onMouseDrag);
						_dom2.default.bind(window, 'mouseup', onMouseUp);

						onMouseDrag(e);
					}

					function onMouseDrag(e) {
						e.preventDefault();

						var bgRect = _this.__background.getBoundingClientRect();

						_this.setValue(map(e.clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));

						return false;
					}

					function onMouseUp() {
						_dom2.default.unbind(window, 'mousemove', onMouseDrag);
						_dom2.default.unbind(window, 'mouseup', onMouseUp);
						if (_this.__onFinishChange) {
							_this.__onFinishChange.call(_this, _this.getValue());
						}
					}

					_this2.updateDisplay();

					_this2.__background.appendChild(_this2.__foreground);
					_this2.domElement.appendChild(_this2.__background);
					return _this2;
				}

				NumberControllerSlider.prototype.updateDisplay = function updateDisplay() {
					var pct = (this.getValue() - this.__min) / (this.__max - this.__min);
					this.__foreground.style.width = pct * 100 + '%';
					return _NumberController.prototype.updateDisplay.call(this);
				};

				return NumberControllerSlider;
			}(_NumberController3.default);

			exports.default = NumberControllerSlider;

			/***/
		},
		/* 15 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			exports.__esModule = true;

			var _Controller2 = __webpack_require__(7);

			var _Controller3 = _interopRequireDefault(_Controller2);

			var _dom = __webpack_require__(9);

			var _dom2 = _interopRequireDefault(_dom);

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}

			function _classCallCheck(instance, Constructor) {
				if (!(instance instanceof Constructor)) {
					throw new TypeError("Cannot call a class as a function");
				}
			}

			function _possibleConstructorReturn(self, call) {
				if (!self) {
					throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
				}return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
			}

			function _inherits(subClass, superClass) {
				if (typeof superClass !== "function" && superClass !== null) {
					throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass)));
				}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
			} /**
      * dat-gui JavaScript Controller Library
      * http://code.google.com/p/dat-gui
      *
      * Copyright 2011 Data Arts Team, Google Creative Lab
      *
      * Licensed under the Apache License, Version 2.0 (the "License");
      * you may not use this file except in compliance with the License.
      * You may obtain a copy of the License at
      *
      * http://www.apache.org/licenses/LICENSE-2.0
      */

			/**
    * @class Provides a GUI interface to fire a specified method, a property of an object.
    *
    * @extends dat.controllers.Controller
    *
    * @param {Object} object The object to be manipulated
    * @param {string} property The name of the property to be manipulated
    *
    * @member dat.controllers
    */
			var FunctionController = function (_Controller) {
				_inherits(FunctionController, _Controller);

				function FunctionController(object, property, text) {
					_classCallCheck(this, FunctionController);

					var _this2 = _possibleConstructorReturn(this, _Controller.call(this, object, property));

					var _this = _this2;

					_this2.__button = document.createElement('div');
					_this2.__button.innerHTML = text === undefined ? 'Fire' : text;

					_dom2.default.bind(_this2.__button, 'click', function (e) {
						e.preventDefault();
						_this.fire();
						return false;
					});

					_dom2.default.addClass(_this2.__button, 'button');

					_this2.domElement.appendChild(_this2.__button);
					return _this2;
				}

				FunctionController.prototype.fire = function fire() {
					if (this.__onChange) {
						this.__onChange.call(this);
					}
					this.getValue().call(this.object);
					if (this.__onFinishChange) {
						this.__onFinishChange.call(this, this.getValue());
					}
				};

				return FunctionController;
			}(_Controller3.default);

			exports.default = FunctionController;

			/***/
		},
		/* 16 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			exports.__esModule = true;

			var _Controller2 = __webpack_require__(7);

			var _Controller3 = _interopRequireDefault(_Controller2);

			var _dom = __webpack_require__(9);

			var _dom2 = _interopRequireDefault(_dom);

			var _Color = __webpack_require__(2);

			var _Color2 = _interopRequireDefault(_Color);

			var _interpret = __webpack_require__(3);

			var _interpret2 = _interopRequireDefault(_interpret);

			var _common = __webpack_require__(5);

			var _common2 = _interopRequireDefault(_common);

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}

			function _classCallCheck(instance, Constructor) {
				if (!(instance instanceof Constructor)) {
					throw new TypeError("Cannot call a class as a function");
				}
			}

			function _possibleConstructorReturn(self, call) {
				if (!self) {
					throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
				}return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
			}

			function _inherits(subClass, superClass) {
				if (typeof superClass !== "function" && superClass !== null) {
					throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass)));
				}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
			} /**
      * dat-gui JavaScript Controller Library
      * http://code.google.com/p/dat-gui
      *
      * Copyright 2011 Data Arts Team, Google Creative Lab
      *
      * Licensed under the Apache License, Version 2.0 (the "License");
      * you may not use this file except in compliance with the License.
      * You may obtain a copy of the License at
      *
      * http://www.apache.org/licenses/LICENSE-2.0
      */

			var ColorController = function (_Controller) {
				_inherits(ColorController, _Controller);

				function ColorController(object, property) {
					_classCallCheck(this, ColorController);

					var _this2 = _possibleConstructorReturn(this, _Controller.call(this, object, property));

					_this2.__color = new _Color2.default(_this2.getValue());
					_this2.__temp = new _Color2.default(0);

					var _this = _this2;

					_this2.domElement = document.createElement('div');

					_dom2.default.makeSelectable(_this2.domElement, false);

					_this2.__selector = document.createElement('div');
					_this2.__selector.className = 'selector';

					_this2.__saturation_field = document.createElement('div');
					_this2.__saturation_field.className = 'saturation-field';

					_this2.__field_knob = document.createElement('div');
					_this2.__field_knob.className = 'field-knob';
					_this2.__field_knob_border = '2px solid ';

					_this2.__hue_knob = document.createElement('div');
					_this2.__hue_knob.className = 'hue-knob';

					_this2.__hue_field = document.createElement('div');
					_this2.__hue_field.className = 'hue-field';

					_this2.__input = document.createElement('input');
					_this2.__input.type = 'text';
					_this2.__input_textShadow = '0 1px 1px ';

					_dom2.default.bind(_this2.__input, 'keydown', function (e) {
						if (e.keyCode === 13) {
							// on enter
							onBlur.call(this);
						}
					});

					_dom2.default.bind(_this2.__input, 'blur', onBlur);

					_dom2.default.bind(_this2.__selector, 'mousedown', function () /* e */{
						_dom2.default.addClass(this, 'drag').bind(window, 'mouseup', function () /* e */{
							_dom2.default.removeClass(_this.__selector, 'drag');
						});
					});

					var valueField = document.createElement('div');

					_common2.default.extend(_this2.__selector.style, {
						width: '122px',
						height: '102px',
						padding: '3px',
						backgroundColor: '#222',
						boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
					});

					_common2.default.extend(_this2.__field_knob.style, {
						position: 'absolute',
						width: '12px',
						height: '12px',
						border: _this2.__field_knob_border + (_this2.__color.v < 0.5 ? '#fff' : '#000'),
						boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
						borderRadius: '12px',
						zIndex: 1
					});

					_common2.default.extend(_this2.__hue_knob.style, {
						position: 'absolute',
						width: '15px',
						height: '2px',
						borderRight: '4px solid #fff',
						zIndex: 1
					});

					_common2.default.extend(_this2.__saturation_field.style, {
						width: '100px',
						height: '100px',
						border: '1px solid #555',
						marginRight: '3px',
						display: 'inline-block',
						cursor: 'pointer'
					});

					_common2.default.extend(valueField.style, {
						width: '100%',
						height: '100%',
						background: 'none'
					});

					linearGradient(valueField, 'top', 'rgba(0,0,0,0)', '#000');

					_common2.default.extend(_this2.__hue_field.style, {
						width: '15px',
						height: '100px',
						border: '1px solid #555',
						cursor: 'ns-resize',
						position: 'absolute',
						top: '3px',
						right: '3px'
					});

					hueGradient(_this2.__hue_field);

					_common2.default.extend(_this2.__input.style, {
						outline: 'none',
						//      width: '120px',
						textAlign: 'center',
						//      padding: '4px',
						//      marginBottom: '6px',
						color: '#fff',
						border: 0,
						fontWeight: 'bold',
						textShadow: _this2.__input_textShadow + 'rgba(0,0,0,0.7)'
					});

					_dom2.default.bind(_this2.__saturation_field, 'mousedown', fieldDown);
					_dom2.default.bind(_this2.__field_knob, 'mousedown', fieldDown);

					_dom2.default.bind(_this2.__hue_field, 'mousedown', function (e) {
						setH(e);
						_dom2.default.bind(window, 'mousemove', setH);
						_dom2.default.bind(window, 'mouseup', fieldUpH);
					});

					function fieldDown(e) {
						setSV(e);
						// document.body.style.cursor = 'none';
						_dom2.default.bind(window, 'mousemove', setSV);
						_dom2.default.bind(window, 'mouseup', fieldUpSV);
					}

					function fieldUpSV() {
						_dom2.default.unbind(window, 'mousemove', setSV);
						_dom2.default.unbind(window, 'mouseup', fieldUpSV);
						// document.body.style.cursor = 'default';
						onFinish();
					}

					function onBlur() {
						var i = (0, _interpret2.default)(this.value);
						if (i !== false) {
							_this.__color.__state = i;
							_this.setValue(_this.__color.toOriginal());
						} else {
							this.value = _this.__color.toString();
						}
					}

					function fieldUpH() {
						_dom2.default.unbind(window, 'mousemove', setH);
						_dom2.default.unbind(window, 'mouseup', fieldUpH);
						onFinish();
					}

					function onFinish() {
						if (_this.__onFinishChange) {
							_this.__onFinishChange.call(_this, _this.__color.toOriginal());
						}
					}

					_this2.__saturation_field.appendChild(valueField);
					_this2.__selector.appendChild(_this2.__field_knob);
					_this2.__selector.appendChild(_this2.__saturation_field);
					_this2.__selector.appendChild(_this2.__hue_field);
					_this2.__hue_field.appendChild(_this2.__hue_knob);

					_this2.domElement.appendChild(_this2.__input);
					_this2.domElement.appendChild(_this2.__selector);

					_this2.updateDisplay();

					function setSV(e) {
						e.preventDefault();

						var fieldRect = _this.__saturation_field.getBoundingClientRect();
						var s = (e.clientX - fieldRect.left) / (fieldRect.right - fieldRect.left);
						var v = 1 - (e.clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);

						if (v > 1) {
							v = 1;
						} else if (v < 0) {
							v = 0;
						}

						if (s > 1) {
							s = 1;
						} else if (s < 0) {
							s = 0;
						}

						_this.__color.v = v;
						_this.__color.s = s;

						_this.setValue(_this.__color.toOriginal());

						return false;
					}

					function setH(e) {
						e.preventDefault();

						var fieldRect = _this.__hue_field.getBoundingClientRect();
						var h = 1 - (e.clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);

						if (h > 1) {
							h = 1;
						} else if (h < 0) {
							h = 0;
						}

						_this.__color.h = h * 360;

						_this.setValue(_this.__color.toOriginal());

						return false;
					}
					return _this2;
				}

				ColorController.prototype.updateDisplay = function updateDisplay() {
					var i = (0, _interpret2.default)(this.getValue());

					if (i !== false) {
						var mismatch = false;

						// Check for mismatch on the interpreted value.

						_common2.default.each(_Color2.default.COMPONENTS, function (component) {
							if (!_common2.default.isUndefined(i[component]) && !_common2.default.isUndefined(this.__color.__state[component]) && i[component] !== this.__color.__state[component]) {
								mismatch = true;
								return {}; // break
							}
						}, this);

						// If nothing diverges, we keep our previous values
						// for statefulness, otherwise we recalculate fresh
						if (mismatch) {
							_common2.default.extend(this.__color.__state, i);
						}
					}

					_common2.default.extend(this.__temp.__state, this.__color.__state);

					this.__temp.a = 1;

					var flip = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0;
					var _flip = 255 - flip;

					_common2.default.extend(this.__field_knob.style, {
						marginLeft: 100 * this.__color.s - 7 + 'px',
						marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
						backgroundColor: this.__temp.toHexString(),
						border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip + ')'
					});

					this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px';

					this.__temp.s = 1;
					this.__temp.v = 1;

					linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toHexString());

					this.__input.value = this.__color.toString();

					_common2.default.extend(this.__input.style, {
						backgroundColor: this.__color.toHexString(),
						color: 'rgb(' + flip + ',' + flip + ',' + flip + ')',
						textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip + ',.7)'
					});
				};

				return ColorController;
			}(_Controller3.default);

			var vendors = ['-moz-', '-o-', '-webkit-', '-ms-', ''];

			function linearGradient(elem, x, a, b) {
				elem.style.background = '';
				_common2.default.each(vendors, function (vendor) {
					elem.style.cssText += 'background: ' + vendor + 'linear-gradient(' + x + ', ' + a + ' 0%, ' + b + ' 100%); ';
				});
			}

			function hueGradient(elem) {
				elem.style.background = '';
				elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);';
				elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
				elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
				elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
				elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
			}

			exports.default = ColorController;

			/***/
		},
		/* 17 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
				return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
			} : function (obj) {
				return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
			}; /**
       * dat-gui JavaScript Controller Library
       * http://code.google.com/p/dat-gui
       *
       * Copyright 2011 Data Arts Team, Google Creative Lab
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       * http://www.apache.org/licenses/LICENSE-2.0
       */

			var _css = __webpack_require__(18);

			var _css2 = _interopRequireDefault(_css);

			var _saveDialogue = __webpack_require__(19);

			var _saveDialogue2 = _interopRequireDefault(_saveDialogue);

			var _ControllerFactory = __webpack_require__(20);

			var _ControllerFactory2 = _interopRequireDefault(_ControllerFactory);

			var _Controller = __webpack_require__(7);

			var _Controller2 = _interopRequireDefault(_Controller);

			var _BooleanController = __webpack_require__(8);

			var _BooleanController2 = _interopRequireDefault(_BooleanController);

			var _FunctionController = __webpack_require__(15);

			var _FunctionController2 = _interopRequireDefault(_FunctionController);

			var _NumberControllerBox = __webpack_require__(13);

			var _NumberControllerBox2 = _interopRequireDefault(_NumberControllerBox);

			var _NumberControllerSlider = __webpack_require__(14);

			var _NumberControllerSlider2 = _interopRequireDefault(_NumberControllerSlider);

			var _ColorController = __webpack_require__(16);

			var _ColorController2 = _interopRequireDefault(_ColorController);

			var _requestAnimationFrame = __webpack_require__(21);

			var _requestAnimationFrame2 = _interopRequireDefault(_requestAnimationFrame);

			var _CenteredDiv = __webpack_require__(22);

			var _CenteredDiv2 = _interopRequireDefault(_CenteredDiv);

			var _dom = __webpack_require__(9);

			var _dom2 = _interopRequireDefault(_dom);

			var _common = __webpack_require__(5);

			var _common2 = _interopRequireDefault(_common);

			var _style = __webpack_require__(23);

			var _style2 = _interopRequireDefault(_style);

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}

			// CSS to embed in build

			_css2.default.inject(_style2.default);

			/** Outer-most className for GUI's */
			var CSS_NAMESPACE = 'dg';

			var HIDE_KEY_CODE = 72;

			/** The only value shared between the JS and SCSS. Use caution. */
			var CLOSE_BUTTON_HEIGHT = 20;

			var DEFAULT_DEFAULT_PRESET_NAME = 'Default';

			var SUPPORTS_LOCAL_STORAGE = function () {
				try {
					return 'localStorage' in window && window.localStorage !== null;
				} catch (e) {
					return false;
				}
			}();

			var SAVE_DIALOGUE = void 0;

			/** Have we yet to create an autoPlace GUI? */
			var autoPlaceVirgin = true;

			/** Fixed position div that auto place GUI's go inside */
			var autoPlaceContainer = void 0;

			/** Are we hiding the GUI's ? */
			var hide = false;

			/** GUI's which should be hidden */
			var hideableGuis = [];

			/**
    * A lightweight controller library for JavaScript. It allows you to easily
    * manipulate variables and fire functions on the fly.
    * @class
    *
    * @member dat.gui
    *
    * @param {Object} [params]
    * @param {String} [params.name] The name of this GUI.
    * @param {Object} [params.load] JSON object representing the saved state of
    * this GUI.
    * @param {Boolean} [params.auto=true]
    * @param {dat.gui.GUI} [params.parent] The GUI I'm nested in.
    * @param {Boolean} [params.closed] If true, starts closed
    */
			var GUI = function GUI(pars) {
				var _this = this;

				var params = pars || {};

				/**
     * Outermost DOM Element
     * @type DOMElement
     */
				this.domElement = document.createElement('div');
				this.__ul = document.createElement('ul');
				this.domElement.appendChild(this.__ul);

				_dom2.default.addClass(this.domElement, CSS_NAMESPACE);

				/**
     * Nested GUI's by name
     * @ignore
     */
				this.__folders = {};

				this.__controllers = [];

				/**
     * List of objects I'm remembering for save, only used in top level GUI
     * @ignore
     */
				this.__rememberedObjects = [];

				/**
     * Maps the index of remembered objects to a map of controllers, only used
     * in top level GUI.
     *
     * @private
     * @ignore
     *
     * @example
     * [
     *  {
       *    propertyName: Controller,
       *    anotherPropertyName: Controller
       *  },
     *  {
       *    propertyName: Controller
       *  }
     * ]
     */
				this.__rememberedObjectIndecesToControllers = [];

				this.__listening = [];

				// Default parameters
				params = _common2.default.defaults(params, {
					autoPlace: true,
					width: GUI.DEFAULT_WIDTH
				});

				params = _common2.default.defaults(params, {
					resizable: params.autoPlace,
					hideable: params.autoPlace
				});

				if (!_common2.default.isUndefined(params.load)) {
					// Explicit preset
					if (params.preset) {
						params.load.preset = params.preset;
					}
				} else {
					params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };
				}

				if (_common2.default.isUndefined(params.parent) && params.hideable) {
					hideableGuis.push(this);
				}

				// Only root level GUI's are resizable.
				params.resizable = _common2.default.isUndefined(params.parent) && params.resizable;

				if (params.autoPlace && _common2.default.isUndefined(params.scrollable)) {
					params.scrollable = true;
				}
				//    params.scrollable = common.isUndefined(params.parent) && params.scrollable === true;

				// Not part of params because I don't want people passing this in via
				// constructor. Should be a 'remembered' value.
				var useLocalStorage = SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';

				var saveToLocalStorage = void 0;

				Object.defineProperties(this,
				/** @lends dat.gui.GUI.prototype */
				{
					/**
      * The parent <code>GUI</code>
      * @type dat.gui.GUI
      */
					parent: {
						get: function get() {
							return params.parent;
						}
					},

					scrollable: {
						get: function get() {
							return params.scrollable;
						}
					},

					/**
      * Handles <code>GUI</code>'s element placement for you
      * @type Boolean
      */
					autoPlace: {
						get: function get() {
							return params.autoPlace;
						}
					},

					/**
      * The identifier for a set of saved values
      * @type String
      */
					preset: {
						get: function get() {
							if (_this.parent) {
								return _this.getRoot().preset;
							}

							return params.load.preset;
						},

						set: function set(v) {
							if (_this.parent) {
								_this.getRoot().preset = v;
							} else {
								params.load.preset = v;
							}
							setPresetSelectIndex(this);
							_this.revert();
						}
					},

					/**
      * The width of <code>GUI</code> element
      * @type Number
      */
					width: {
						get: function get() {
							return params.width;
						},
						set: function set(v) {
							params.width = v;
							setWidth(_this, v);
						}
					},

					/**
      * The name of <code>GUI</code>. Used for folders. i.e
      * a folder's name
      * @type String
      */
					name: {
						get: function get() {
							return params.name;
						},
						set: function set(v) {
							// TODO Check for collisions among sibling folders
							params.name = v;
							if (titleRowName) {
								titleRowName.innerHTML = params.name;
							}
						}
					},

					/**
      * Whether the <code>GUI</code> is collapsed or not
      * @type Boolean
      */
					closed: {
						get: function get() {
							return params.closed;
						},
						set: function set(v) {
							params.closed = v;
							if (params.closed) {
								_dom2.default.addClass(_this.__ul, GUI.CLASS_CLOSED);
							} else {
								_dom2.default.removeClass(_this.__ul, GUI.CLASS_CLOSED);
							}
							// For browsers that aren't going to respect the CSS transition,
							// Lets just check our height against the window height right off
							// the bat.
							this.onResize();

							if (_this.__closeButton) {
								_this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
							}
						}
					},

					/**
      * Contains all presets
      * @type Object
      */
					load: {
						get: function get() {
							return params.load;
						}
					},

					/**
      * Determines whether or not to use <a href="https://developer.mozilla.org/en/DOM/Storage#localStorage">localStorage</a> as the means for
      * <code>remember</code>ing
      * @type Boolean
      */
					useLocalStorage: {

						get: function get() {
							return useLocalStorage;
						},
						set: function set(bool) {
							if (SUPPORTS_LOCAL_STORAGE) {
								useLocalStorage = bool;
								if (bool) {
									_dom2.default.bind(window, 'unload', saveToLocalStorage);
								} else {
									_dom2.default.unbind(window, 'unload', saveToLocalStorage);
								}
								localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
							}
						}
					}
				});

				// Are we a root level GUI?
				if (_common2.default.isUndefined(params.parent)) {
					params.closed = false;

					_dom2.default.addClass(this.domElement, GUI.CLASS_MAIN);
					_dom2.default.makeSelectable(this.domElement, false);

					// Are we supposed to be loading locally?
					if (SUPPORTS_LOCAL_STORAGE) {
						if (useLocalStorage) {
							_this.useLocalStorage = true;

							var savedGui = localStorage.getItem(getLocalStorageHash(this, 'gui'));

							if (savedGui) {
								params.load = JSON.parse(savedGui);
							}
						}
					}

					this.__closeButton = document.createElement('div');
					this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
					_dom2.default.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);
					this.domElement.appendChild(this.__closeButton);

					_dom2.default.bind(this.__closeButton, 'click', function () {
						_this.closed = !_this.closed;
					});
					// Oh, you're a nested GUI!
				} else {
					if (params.closed === undefined) {
						params.closed = true;
					}

					var _titleRowName = document.createTextNode(params.name);
					_dom2.default.addClass(_titleRowName, 'controller-name');

					var titleRow = addRow(_this, _titleRowName);

					var onClickTitle = function onClickTitle(e) {
						e.preventDefault();
						_this.closed = !_this.closed;
						return false;
					};

					_dom2.default.addClass(this.__ul, GUI.CLASS_CLOSED);

					_dom2.default.addClass(titleRow, 'title');
					_dom2.default.bind(titleRow, 'click', onClickTitle);

					if (!params.closed) {
						this.closed = false;
					}
				}

				if (params.autoPlace) {
					if (_common2.default.isUndefined(params.parent)) {
						if (autoPlaceVirgin) {
							autoPlaceContainer = document.createElement('div');
							_dom2.default.addClass(autoPlaceContainer, CSS_NAMESPACE);
							_dom2.default.addClass(autoPlaceContainer, GUI.CLASS_AUTO_PLACE_CONTAINER);
							document.body.appendChild(autoPlaceContainer);
							autoPlaceVirgin = false;
						}

						// Put it in the dom for you.
						autoPlaceContainer.appendChild(this.domElement);

						// Apply the auto styles
						_dom2.default.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);
					}

					// Make it not elastic.
					if (!this.parent) {
						setWidth(_this, params.width);
					}
				}

				this.__resizeHandler = function () {
					_this.onResizeDebounced();
				};

				_dom2.default.bind(window, 'resize', this.__resizeHandler);
				_dom2.default.bind(this.__ul, 'webkitTransitionEnd', this.__resizeHandler);
				_dom2.default.bind(this.__ul, 'transitionend', this.__resizeHandler);
				_dom2.default.bind(this.__ul, 'oTransitionEnd', this.__resizeHandler);
				this.onResize();

				if (params.resizable) {
					addResizeHandle(this);
				}

				saveToLocalStorage = function saveToLocalStorage() {
					if (SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(_this, 'isLocal')) === 'true') {
						localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
					}
				};

				// expose this method publicly
				this.saveToLocalStorageIfPossible = saveToLocalStorage;

				function resetWidth() {
					var root = _this.getRoot();
					root.width += 1;
					_common2.default.defer(function () {
						root.width -= 1;
					});
				}

				if (!params.parent) {
					resetWidth();
				}
			};

			GUI.toggleHide = function () {
				hide = !hide;
				_common2.default.each(hideableGuis, function (gui) {
					gui.domElement.style.display = hide ? 'none' : '';
				});
			};

			GUI.CLASS_AUTO_PLACE = 'a';
			GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
			GUI.CLASS_MAIN = 'main';
			GUI.CLASS_CONTROLLER_ROW = 'cr';
			GUI.CLASS_TOO_TALL = 'taller-than-window';
			GUI.CLASS_CLOSED = 'closed';
			GUI.CLASS_CLOSE_BUTTON = 'close-button';
			GUI.CLASS_DRAG = 'drag';

			GUI.DEFAULT_WIDTH = 245;
			GUI.TEXT_CLOSED = 'Close Controls';
			GUI.TEXT_OPEN = 'Open Controls';

			GUI._keydownHandler = function (e) {
				if (document.activeElement.type !== 'text' && (e.which === HIDE_KEY_CODE || e.keyCode === HIDE_KEY_CODE)) {
					GUI.toggleHide();
				}
			};
			_dom2.default.bind(window, 'keydown', GUI._keydownHandler, false);

			_common2.default.extend(GUI.prototype,

			/** @lends dat.gui.GUI */
			{

				/**
     * @param object
     * @param property
     * @returns {dat.controllers.Controller} The new controller that was added.
     * @instance
     */
				add: function add(object, property) {
					return _add(this, object, property, {
						factoryArgs: Array.prototype.slice.call(arguments, 2)
					});
				},

				/**
     * @param object
     * @param property
     * @returns {dat.controllers.ColorController} The new controller that was added.
     * @instance
     */
				addColor: function addColor(object, property) {
					return _add(this, object, property, {
						color: true
					});
				},

				/**
     * @param controller
     * @instance
     */
				remove: function remove(controller) {
					// TODO listening?
					this.__ul.removeChild(controller.__li);
					this.__controllers.splice(this.__controllers.indexOf(controller), 1);
					var _this = this;
					_common2.default.defer(function () {
						_this.onResize();
					});
				},

				destroy: function destroy() {
					if (this.autoPlace) {
						autoPlaceContainer.removeChild(this.domElement);
					}

					_dom2.default.unbind(window, 'keydown', GUI._keydownHandler, false);
					_dom2.default.unbind(window, 'resize', this.__resizeHandler);

					if (this.saveToLocalStorageIfPossible) {
						_dom2.default.unbind(window, 'unload', this.saveToLocalStorageIfPossible);
					}
				},

				/**
     * @param name
     * @returns {dat.gui.GUI} The new folder.
     * @throws {Error} if this GUI already has a folder by the specified
     * name
     * @instance
     */
				addFolder: function addFolder(name) {
					// We have to prevent collisions on names in order to have a key
					// by which to remember saved values
					if (this.__folders[name] !== undefined) {
						throw new Error('You already have a folder in this GUI by the' + ' name "' + name + '"');
					}

					var newGuiParams = { name: name, parent: this };

					// We need to pass down the autoPlace trait so that we can
					// attach event listeners to open/close folder actions to
					// ensure that a scrollbar appears if the window is too short.
					newGuiParams.autoPlace = this.autoPlace;

					// Do we have saved appearance data for this folder?
					if (this.load && // Anything loaded?
					this.load.folders && // Was my parent a dead-end?
					this.load.folders[name]) {
						// Did daddy remember me?
						// Start me closed if I was closed
						newGuiParams.closed = this.load.folders[name].closed;

						// Pass down the loaded data
						newGuiParams.load = this.load.folders[name];
					}

					var gui = new GUI(newGuiParams);
					this.__folders[name] = gui;

					var li = addRow(this, gui.domElement);
					_dom2.default.addClass(li, 'folder');
					return gui;
				},

				open: function open() {
					this.closed = false;
				},

				close: function close() {
					this.closed = true;
				},

				onResize: function onResize() {
					// we debounce this function to prevent performance issues when rotating on tablet/mobile
					var root = this.getRoot();
					if (root.scrollable) {
						var top = _dom2.default.getOffset(root.__ul).top;
						var h = 0;

						_common2.default.each(root.__ul.childNodes, function (node) {
							if (!(root.autoPlace && node === root.__save_row)) {
								h += _dom2.default.getHeight(node);
							}
						});

						if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
							_dom2.default.addClass(root.domElement, GUI.CLASS_TOO_TALL);
							root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
						} else {
							_dom2.default.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
							root.__ul.style.height = 'auto';
						}
					}

					if (root.__resize_handle) {
						_common2.default.defer(function () {
							root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
						});
					}

					if (root.__closeButton) {
						root.__closeButton.style.width = root.width + 'px';
					}
				},

				onResizeDebounced: _common2.default.debounce(function () {
					this.onResize();
				}, 200),

				/**
     * Mark objects for saving. The order of these objects cannot change as
     * the GUI grows. When remembering new objects, append them to the end
     * of the list.
     *
     * @param {Object...} objects
     * @throws {Error} if not called on a top level GUI.
     * @instance
     */
				remember: function remember() {
					if (_common2.default.isUndefined(SAVE_DIALOGUE)) {
						SAVE_DIALOGUE = new _CenteredDiv2.default();
						SAVE_DIALOGUE.domElement.innerHTML = _saveDialogue2.default;
					}

					if (this.parent) {
						throw new Error('You can only call remember on a top level GUI.');
					}

					var _this = this;

					_common2.default.each(Array.prototype.slice.call(arguments), function (object) {
						if (_this.__rememberedObjects.length === 0) {
							addSaveMenu(_this);
						}
						if (_this.__rememberedObjects.indexOf(object) === -1) {
							_this.__rememberedObjects.push(object);
						}
					});

					if (this.autoPlace) {
						// Set save row width
						setWidth(this, this.width);
					}
				},

				/**
     * @returns {dat.gui.GUI} the topmost parent GUI of a nested GUI.
     * @instance
     */
				getRoot: function getRoot() {
					var gui = this;
					while (gui.parent) {
						gui = gui.parent;
					}
					return gui;
				},

				/**
     * @returns {Object} a JSON object representing the current state of
     * this GUI as well as its remembered properties.
     * @instance
     */
				getSaveObject: function getSaveObject() {
					var toReturn = this.load;
					toReturn.closed = this.closed;

					// Am I remembering any values?
					if (this.__rememberedObjects.length > 0) {
						toReturn.preset = this.preset;

						if (!toReturn.remembered) {
							toReturn.remembered = {};
						}

						toReturn.remembered[this.preset] = getCurrentPreset(this);
					}

					toReturn.folders = {};
					_common2.default.each(this.__folders, function (element, key) {
						toReturn.folders[key] = element.getSaveObject();
					});

					return toReturn;
				},

				save: function save() {
					if (!this.load.remembered) {
						this.load.remembered = {};
					}

					this.load.remembered[this.preset] = getCurrentPreset(this);
					markPresetModified(this, false);
					this.saveToLocalStorageIfPossible();
				},

				saveAs: function saveAs(presetName) {
					if (!this.load.remembered) {
						// Retain default values upon first save
						this.load.remembered = {};
						this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);
					}

					this.load.remembered[presetName] = getCurrentPreset(this);
					this.preset = presetName;
					addPresetOption(this, presetName, true);
					this.saveToLocalStorageIfPossible();
				},

				revert: function revert(gui) {
					_common2.default.each(this.__controllers, function (controller) {
						// Make revert work on Default.
						if (!this.getRoot().load.remembered) {
							controller.setValue(controller.initialValue);
						} else {
							recallSavedValue(gui || this.getRoot(), controller);
						}

						// fire onFinishChange callback
						if (controller.__onFinishChange) {
							controller.__onFinishChange.call(controller, controller.getValue());
						}
					}, this);

					_common2.default.each(this.__folders, function (folder) {
						folder.revert(folder);
					});

					if (!gui) {
						markPresetModified(this.getRoot(), false);
					}
				},

				listen: function listen(controller) {
					var init = this.__listening.length === 0;
					this.__listening.push(controller);
					if (init) {
						updateDisplays(this.__listening);
					}
				},

				updateDisplay: function updateDisplay() {
					_common2.default.each(this.__controllers, function (controller) {
						controller.updateDisplay();
					});
					_common2.default.each(this.__folders, function (folder) {
						folder.updateDisplay();
					});
				}
			});

			/**
    * Add a row to the end of the GUI or before another row.
    *
    * @param gui
    * @param [newDom] If specified, inserts the dom content in the new row
    * @param [liBefore] If specified, places the new row before another row
    */
			function addRow(gui, newDom, liBefore) {
				var li = document.createElement('li');
				if (newDom) {
					li.appendChild(newDom);
				}

				if (liBefore) {
					gui.__ul.insertBefore(li, liBefore);
				} else {
					gui.__ul.appendChild(li);
				}
				gui.onResize();
				return li;
			}

			function markPresetModified(gui, modified) {
				var opt = gui.__preset_select[gui.__preset_select.selectedIndex];

				// console.log('mark', modified, opt);
				if (modified) {
					opt.innerHTML = opt.value + '*';
				} else {
					opt.innerHTML = opt.value;
				}
			}

			function augmentController(gui, li, controller) {
				controller.__li = li;
				controller.__gui = gui;

				_common2.default.extend(controller, {
					options: function options(_options) {
						if (arguments.length > 1) {
							var nextSibling = controller.__li.nextElementSibling;
							controller.remove();

							return _add(gui, controller.object, controller.property, {
								before: nextSibling,
								factoryArgs: [_common2.default.toArray(arguments)]
							});
						}

						if (_common2.default.isArray(_options) || _common2.default.isObject(_options)) {
							var _nextSibling = controller.__li.nextElementSibling;
							controller.remove();

							return _add(gui, controller.object, controller.property, {
								before: _nextSibling,
								factoryArgs: [_options]
							});
						}
					},

					name: function name(v) {
						controller.__li.firstElementChild.firstElementChild.innerHTML = v;
						return controller;
					},

					listen: function listen() {
						controller.__gui.listen(controller);
						return controller;
					},

					remove: function remove() {
						controller.__gui.remove(controller);
						return controller;
					}
				});

				// All sliders should be accompanied by a box.
				if (controller instanceof _NumberControllerSlider2.default) {
					(function () {
						var box = new _NumberControllerBox2.default(controller.object, controller.property, { min: controller.__min, max: controller.__max, step: controller.__step });

						_common2.default.each(['updateDisplay', 'onChange', 'onFinishChange', 'step'], function (method) {
							var pc = controller[method];
							var pb = box[method];
							controller[method] = box[method] = function () {
								var args = Array.prototype.slice.call(arguments);
								pb.apply(box, args);
								return pc.apply(controller, args);
							};
						});

						_dom2.default.addClass(li, 'has-slider');
						controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);
					})();
				} else if (controller instanceof _NumberControllerBox2.default) {
					var r = function r(returned) {
						// Have we defined both boundaries?
						if (_common2.default.isNumber(controller.__min) && _common2.default.isNumber(controller.__max)) {
							// Well, then lets just replace this with a slider.

							// lets remember if the old controller had a specific name or was listening
							var oldName = controller.__li.firstElementChild.firstElementChild.innerHTML;
							var wasListening = controller.__gui.__listening.indexOf(controller) > -1;

							controller.remove();
							var newController = _add(gui, controller.object, controller.property, {
								before: controller.__li.nextElementSibling,
								factoryArgs: [controller.__min, controller.__max, controller.__step]
							});

							newController.name(oldName);
							if (wasListening) newController.listen();

							return newController;
						}

						return returned;
					};

					controller.min = _common2.default.compose(r, controller.min);
					controller.max = _common2.default.compose(r, controller.max);
				} else if (controller instanceof _BooleanController2.default) {
					_dom2.default.bind(li, 'click', function () {
						_dom2.default.fakeEvent(controller.__checkbox, 'click');
					});

					_dom2.default.bind(controller.__checkbox, 'click', function (e) {
						e.stopPropagation(); // Prevents double-toggle
					});
				} else if (controller instanceof _FunctionController2.default) {
					_dom2.default.bind(li, 'click', function () {
						_dom2.default.fakeEvent(controller.__button, 'click');
					});

					_dom2.default.bind(li, 'mouseover', function () {
						_dom2.default.addClass(controller.__button, 'hover');
					});

					_dom2.default.bind(li, 'mouseout', function () {
						_dom2.default.removeClass(controller.__button, 'hover');
					});
				} else if (controller instanceof _ColorController2.default) {
					_dom2.default.addClass(li, 'color');
					controller.updateDisplay = _common2.default.compose(function (val) {
						li.style.borderLeftColor = controller.__color.toString();
						return val;
					}, controller.updateDisplay);

					controller.updateDisplay();
				}

				controller.setValue = _common2.default.compose(function (val) {
					if (gui.getRoot().__preset_select && controller.isModified()) {
						markPresetModified(gui.getRoot(), true);
					}

					return val;
				}, controller.setValue);
			}

			function recallSavedValue(gui, controller) {
				// Find the topmost GUI, that's where remembered objects live.
				var root = gui.getRoot();

				// Does the object we're controlling match anything we've been told to
				// remember?
				var matchedIndex = root.__rememberedObjects.indexOf(controller.object);

				// Why yes, it does!
				if (matchedIndex !== -1) {
					// Let me fetch a map of controllers for thcommon.isObject.
					var controllerMap = root.__rememberedObjectIndecesToControllers[matchedIndex];

					// Ohp, I believe this is the first controller we've created for this
					// object. Lets make the map fresh.
					if (controllerMap === undefined) {
						controllerMap = {};
						root.__rememberedObjectIndecesToControllers[matchedIndex] = controllerMap;
					}

					// Keep track of this controller
					controllerMap[controller.property] = controller;

					// Okay, now have we saved any values for this controller?
					if (root.load && root.load.remembered) {
						var presetMap = root.load.remembered;

						// Which preset are we trying to load?
						var preset = void 0;

						if (presetMap[gui.preset]) {
							preset = presetMap[gui.preset];
						} else if (presetMap[DEFAULT_DEFAULT_PRESET_NAME]) {
							// Uhh, you can have the default instead?
							preset = presetMap[DEFAULT_DEFAULT_PRESET_NAME];
						} else {
							// Nada.
							return;
						}

						// Did the loaded object remember thcommon.isObject? &&  Did we remember this particular property?
						if (preset[matchedIndex] && preset[matchedIndex][controller.property] !== undefined) {
							// We did remember something for this guy ...
							var value = preset[matchedIndex][controller.property];

							// And that's what it is.
							controller.initialValue = value;
							controller.setValue(value);
						}
					}
				}
			}

			function _add(gui, object, property, params) {
				if (object[property] === undefined) {
					throw new Error('Object "' + object + '" has no property "' + property + '"');
				}

				var controller = void 0;

				if (params.color) {
					controller = new _ColorController2.default(object, property);
				} else {
					var factoryArgs = [object, property].concat(params.factoryArgs);
					controller = _ControllerFactory2.default.apply(gui, factoryArgs);
				}

				if (params.before instanceof _Controller2.default) {
					params.before = params.before.__li;
				}

				recallSavedValue(gui, controller);

				_dom2.default.addClass(controller.domElement, 'c');

				var name = document.createElement('span');
				_dom2.default.addClass(name, 'property-name');
				name.innerHTML = controller.property;

				var container = document.createElement('div');
				container.appendChild(name);
				container.appendChild(controller.domElement);

				var li = addRow(gui, container, params.before);

				_dom2.default.addClass(li, GUI.CLASS_CONTROLLER_ROW);
				if (controller instanceof _ColorController2.default) {
					_dom2.default.addClass(li, 'color');
				} else {
					_dom2.default.addClass(li, _typeof(controller.getValue()));
				}

				augmentController(gui, li, controller);

				gui.__controllers.push(controller);

				return controller;
			}

			function getLocalStorageHash(gui, key) {
				// TODO how does this deal with multiple GUI's?
				return document.location.href + '.' + key;
			}

			function addPresetOption(gui, name, setSelected) {
				var opt = document.createElement('option');
				opt.innerHTML = name;
				opt.value = name;
				gui.__preset_select.appendChild(opt);
				if (setSelected) {
					gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
				}
			}

			function showHideExplain(gui, explain) {
				explain.style.display = gui.useLocalStorage ? 'block' : 'none';
			}

			function addSaveMenu(gui) {
				var div = gui.__save_row = document.createElement('li');

				_dom2.default.addClass(gui.domElement, 'has-save');

				gui.__ul.insertBefore(div, gui.__ul.firstChild);

				_dom2.default.addClass(div, 'save-row');

				var gears = document.createElement('span');
				gears.innerHTML = '&nbsp;';
				_dom2.default.addClass(gears, 'button gears');

				// TODO replace with FunctionController
				var button = document.createElement('span');
				button.innerHTML = 'Save';
				_dom2.default.addClass(button, 'button');
				_dom2.default.addClass(button, 'save');

				var button2 = document.createElement('span');
				button2.innerHTML = 'New';
				_dom2.default.addClass(button2, 'button');
				_dom2.default.addClass(button2, 'save-as');

				var button3 = document.createElement('span');
				button3.innerHTML = 'Revert';
				_dom2.default.addClass(button3, 'button');
				_dom2.default.addClass(button3, 'revert');

				var select = gui.__preset_select = document.createElement('select');

				if (gui.load && gui.load.remembered) {
					_common2.default.each(gui.load.remembered, function (value, key) {
						addPresetOption(gui, key, key === gui.preset);
					});
				} else {
					addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
				}

				_dom2.default.bind(select, 'change', function () {
					for (var index = 0; index < gui.__preset_select.length; index++) {
						gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
					}

					gui.preset = this.value;
				});

				div.appendChild(select);
				div.appendChild(gears);
				div.appendChild(button);
				div.appendChild(button2);
				div.appendChild(button3);

				if (SUPPORTS_LOCAL_STORAGE) {
					(function () {
						var explain = document.getElementById('dg-local-explain');
						var localStorageCheckBox = document.getElementById('dg-local-storage');
						var saveLocally = document.getElementById('dg-save-locally');

						saveLocally.style.display = 'block';

						if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
							localStorageCheckBox.setAttribute('checked', 'checked');
						}

						showHideExplain(gui, explain);

						// TODO: Use a boolean controller, fool!
						_dom2.default.bind(localStorageCheckBox, 'change', function () {
							gui.useLocalStorage = !gui.useLocalStorage;
							showHideExplain(gui, explain);
						});
					})();
				}

				var newConstructorTextArea = document.getElementById('dg-new-constructor');

				_dom2.default.bind(newConstructorTextArea, 'keydown', function (e) {
					if (e.metaKey && (e.which === 67 || e.keyCode === 67)) {
						SAVE_DIALOGUE.hide();
					}
				});

				_dom2.default.bind(gears, 'click', function () {
					newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
					SAVE_DIALOGUE.show();
					newConstructorTextArea.focus();
					newConstructorTextArea.select();
				});

				_dom2.default.bind(button, 'click', function () {
					gui.save();
				});

				_dom2.default.bind(button2, 'click', function () {
					var presetName = prompt('Enter a new preset name.');
					if (presetName) {
						gui.saveAs(presetName);
					}
				});

				_dom2.default.bind(button3, 'click', function () {
					gui.revert();
				});

				// div.appendChild(button2);
			}

			function addResizeHandle(gui) {
				var pmouseX = void 0;

				gui.__resize_handle = document.createElement('div');

				_common2.default.extend(gui.__resize_handle.style, {

					width: '6px',
					marginLeft: '-3px',
					height: '200px',
					cursor: 'ew-resize',
					position: 'absolute'
					// border: '1px solid blue'

				});

				function drag(e) {
					e.preventDefault();

					gui.width += pmouseX - e.clientX;
					gui.onResize();
					pmouseX = e.clientX;

					return false;
				}

				function dragStop() {
					_dom2.default.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
					_dom2.default.unbind(window, 'mousemove', drag);
					_dom2.default.unbind(window, 'mouseup', dragStop);
				}

				function dragStart(e) {
					e.preventDefault();

					pmouseX = e.clientX;

					_dom2.default.addClass(gui.__closeButton, GUI.CLASS_DRAG);
					_dom2.default.bind(window, 'mousemove', drag);
					_dom2.default.bind(window, 'mouseup', dragStop);

					return false;
				}

				_dom2.default.bind(gui.__resize_handle, 'mousedown', dragStart);
				_dom2.default.bind(gui.__closeButton, 'mousedown', dragStart);

				gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);
			}

			function setWidth(gui, w) {
				gui.domElement.style.width = w + 'px';
				// Auto placed save-rows are position fixed, so we have to
				// set the width manually if we want it to bleed to the edge
				if (gui.__save_row && gui.autoPlace) {
					gui.__save_row.style.width = w + 'px';
				}
				if (gui.__closeButton) {
					gui.__closeButton.style.width = w + 'px';
				}
			}

			function getCurrentPreset(gui, useInitialValues) {
				var toReturn = {};

				// For each object I'm remembering
				_common2.default.each(gui.__rememberedObjects, function (val, index) {
					var savedValues = {};

					// The controllers I've made for thcommon.isObject by property
					var controllerMap = gui.__rememberedObjectIndecesToControllers[index];

					// Remember each value for each property
					_common2.default.each(controllerMap, function (controller, property) {
						savedValues[property] = useInitialValues ? controller.initialValue : controller.getValue();
					});

					// Save the values for thcommon.isObject
					toReturn[index] = savedValues;
				});

				return toReturn;
			}

			function setPresetSelectIndex(gui) {
				for (var index = 0; index < gui.__preset_select.length; index++) {
					if (gui.__preset_select[index].value === gui.preset) {
						gui.__preset_select.selectedIndex = index;
					}
				}
			}

			function updateDisplays(controllerArray) {
				if (controllerArray.length !== 0) {
					_requestAnimationFrame2.default.call(window, function () {
						updateDisplays(controllerArray);
					});
				}

				_common2.default.each(controllerArray, function (c) {
					c.updateDisplay();
				});
			}

			module.exports = GUI;

			/***/
		},
		/* 18 */
		/***/function (module, exports) {

			'use strict';

			/**
    * dat-gui JavaScript Controller Library
    * http://code.google.com/p/dat-gui
    *
    * Copyright 2011 Data Arts Team, Google Creative Lab
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    */

			module.exports = {
				load: function load(url, indoc) {
					var doc = indoc || document;
					var link = doc.createElement('link');
					link.type = 'text/css';
					link.rel = 'stylesheet';
					link.href = url;
					doc.getElementsByTagName('head')[0].appendChild(link);
				},

				inject: function inject(css, indoc) {
					var doc = indoc || document;
					var injected = document.createElement('style');
					injected.type = 'text/css';
					injected.innerHTML = css;
					var head = doc.getElementsByTagName('head')[0];
					try {
						head.appendChild(injected);
					} catch (e) {// Unable to inject CSS, probably because of a Content Security Policy
					}
				}
			};

			/***/
		},
		/* 19 */
		/***/function (module, exports) {

			module.exports = "<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>";

			/***/
		},
		/* 20 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			exports.__esModule = true;

			var _OptionController = __webpack_require__(10);

			var _OptionController2 = _interopRequireDefault(_OptionController);

			var _NumberControllerBox = __webpack_require__(13);

			var _NumberControllerBox2 = _interopRequireDefault(_NumberControllerBox);

			var _NumberControllerSlider = __webpack_require__(14);

			var _NumberControllerSlider2 = _interopRequireDefault(_NumberControllerSlider);

			var _StringController = __webpack_require__(11);

			var _StringController2 = _interopRequireDefault(_StringController);

			var _FunctionController = __webpack_require__(15);

			var _FunctionController2 = _interopRequireDefault(_FunctionController);

			var _BooleanController = __webpack_require__(8);

			var _BooleanController2 = _interopRequireDefault(_BooleanController);

			var _common = __webpack_require__(5);

			var _common2 = _interopRequireDefault(_common);

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}

			var ControllerFactory = function ControllerFactory(object, property) {
				var initialValue = object[property];

				// Providing options?
				if (_common2.default.isArray(arguments[2]) || _common2.default.isObject(arguments[2])) {
					return new _OptionController2.default(object, property, arguments[2]);
				}

				// Providing a map?
				if (_common2.default.isNumber(initialValue)) {
					// Has min and max? (slider)
					if (_common2.default.isNumber(arguments[2]) && _common2.default.isNumber(arguments[3])) {
						// has step?
						if (_common2.default.isNumber(arguments[4])) {
							return new _NumberControllerSlider2.default(object, property, arguments[2], arguments[3], arguments[4]);
						}

						return new _NumberControllerSlider2.default(object, property, arguments[2], arguments[3]);
					}

					// number box
					if (_common2.default.isNumber(arguments[4])) {
						// has step
						return new _NumberControllerBox2.default(object, property, { min: arguments[2], max: arguments[3], step: arguments[4] });
					}
					return new _NumberControllerBox2.default(object, property, { min: arguments[2], max: arguments[3] });
				}

				if (_common2.default.isString(initialValue)) {
					return new _StringController2.default(object, property);
				}

				if (_common2.default.isFunction(initialValue)) {
					return new _FunctionController2.default(object, property, '');
				}

				if (_common2.default.isBoolean(initialValue)) {
					return new _BooleanController2.default(object, property);
				}

				return null;
			}; /**
       * dat-gui JavaScript Controller Library
       * http://code.google.com/p/dat-gui
       *
       * Copyright 2011 Data Arts Team, Google Creative Lab
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       * http://www.apache.org/licenses/LICENSE-2.0
       */

			exports.default = ControllerFactory;

			/***/
		},
		/* 21 */
		/***/function (module, exports) {

			"use strict";

			exports.__esModule = true;
			/**
    * dat-gui JavaScript Controller Library
    * http://code.google.com/p/dat-gui
    *
    * Copyright 2011 Data Arts Team, Google Creative Lab
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    */

			function requestAnimationFrame(callback) {
				setTimeout(callback, 1000 / 60);
			}

			exports.default = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || requestAnimationFrame;

			/***/
		},
		/* 22 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			exports.__esModule = true;

			var _dom = __webpack_require__(9);

			var _dom2 = _interopRequireDefault(_dom);

			var _common = __webpack_require__(5);

			var _common2 = _interopRequireDefault(_common);

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}

			function _classCallCheck(instance, Constructor) {
				if (!(instance instanceof Constructor)) {
					throw new TypeError("Cannot call a class as a function");
				}
			} /**
      * dat-gui JavaScript Controller Library
      * http://code.google.com/p/dat-gui
      *
      * Copyright 2011 Data Arts Team, Google Creative Lab
      *
      * Licensed under the Apache License, Version 2.0 (the "License");
      * you may not use this file except in compliance with the License.
      * You may obtain a copy of the License at
      *
      * http://www.apache.org/licenses/LICENSE-2.0
      */

			var CenteredDiv = function () {
				function CenteredDiv() {
					_classCallCheck(this, CenteredDiv);

					this.backgroundElement = document.createElement('div');
					_common2.default.extend(this.backgroundElement.style, {
						backgroundColor: 'rgba(0,0,0,0.8)',
						top: 0,
						left: 0,
						display: 'none',
						zIndex: '1000',
						opacity: 0,
						WebkitTransition: 'opacity 0.2s linear',
						transition: 'opacity 0.2s linear'
					});

					_dom2.default.makeFullscreen(this.backgroundElement);
					this.backgroundElement.style.position = 'fixed';

					this.domElement = document.createElement('div');
					_common2.default.extend(this.domElement.style, {
						position: 'fixed',
						display: 'none',
						zIndex: '1001',
						opacity: 0,
						WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear',
						transition: 'transform 0.2s ease-out, opacity 0.2s linear'
					});

					document.body.appendChild(this.backgroundElement);
					document.body.appendChild(this.domElement);

					var _this = this;
					_dom2.default.bind(this.backgroundElement, 'click', function () {
						_this.hide();
					});
				}

				CenteredDiv.prototype.show = function show() {
					var _this = this;

					this.backgroundElement.style.display = 'block';

					this.domElement.style.display = 'block';
					this.domElement.style.opacity = 0;
					//    this.domElement.style.top = '52%';
					this.domElement.style.webkitTransform = 'scale(1.1)';

					this.layout();

					_common2.default.defer(function () {
						_this.backgroundElement.style.opacity = 1;
						_this.domElement.style.opacity = 1;
						_this.domElement.style.webkitTransform = 'scale(1)';
					});
				};

				/**
     * Hide centered div
     */

				CenteredDiv.prototype.hide = function hide() {
					var _this = this;

					var hide = function hide() {
						_this.domElement.style.display = 'none';
						_this.backgroundElement.style.display = 'none';

						_dom2.default.unbind(_this.domElement, 'webkitTransitionEnd', hide);
						_dom2.default.unbind(_this.domElement, 'transitionend', hide);
						_dom2.default.unbind(_this.domElement, 'oTransitionEnd', hide);
					};

					_dom2.default.bind(this.domElement, 'webkitTransitionEnd', hide);
					_dom2.default.bind(this.domElement, 'transitionend', hide);
					_dom2.default.bind(this.domElement, 'oTransitionEnd', hide);

					this.backgroundElement.style.opacity = 0;
					//    this.domElement.style.top = '48%';
					this.domElement.style.opacity = 0;
					this.domElement.style.webkitTransform = 'scale(1.1)';
				};

				CenteredDiv.prototype.layout = function layout() {
					this.domElement.style.left = window.innerWidth / 2 - _dom2.default.getWidth(this.domElement) / 2 + 'px';
					this.domElement.style.top = window.innerHeight / 2 - _dom2.default.getHeight(this.domElement) / 2 + 'px';
				};

				return CenteredDiv;
			}();

			exports.default = CenteredDiv;

			/***/
		},
		/* 23 */
		/***/function (module, exports, __webpack_require__) {

			exports = module.exports = __webpack_require__(24)();
			// imports


			// module
			exports.push([module.id, ".dg {\n  /** Clear list styles */\n  /* Auto-place container */\n  /* Auto-placed GUI's */\n  /* Line items that don't contain folders. */\n  /** Folder names */\n  /** Hides closed items */\n  /** Controller row */\n  /** Name-half (left) */\n  /** Controller-half (right) */\n  /** Controller placement */\n  /** Shorter number boxes when slider is present. */\n  /** Ensure the entire boolean and function row shows a hand */ }\n  .dg ul {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    width: 100%;\n    clear: both; }\n  .dg.ac {\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    height: 0;\n    z-index: 0; }\n  .dg:not(.ac) .main {\n    /** Exclude mains in ac so that we don't hide close button */\n    overflow: hidden; }\n  .dg.main {\n    -webkit-transition: opacity 0.1s linear;\n    -o-transition: opacity 0.1s linear;\n    -moz-transition: opacity 0.1s linear;\n    transition: opacity 0.1s linear; }\n    .dg.main.taller-than-window {\n      overflow-y: auto; }\n      .dg.main.taller-than-window .close-button {\n        opacity: 1;\n        /* TODO, these are style notes */\n        margin-top: -1px;\n        border-top: 1px solid #2c2c2c; }\n    .dg.main ul.closed .close-button {\n      opacity: 1 !important; }\n    .dg.main:hover .close-button,\n    .dg.main .close-button.drag {\n      opacity: 1; }\n    .dg.main .close-button {\n      /*opacity: 0;*/\n      -webkit-transition: opacity 0.1s linear;\n      -o-transition: opacity 0.1s linear;\n      -moz-transition: opacity 0.1s linear;\n      transition: opacity 0.1s linear;\n      border: 0;\n      position: absolute;\n      line-height: 19px;\n      height: 20px;\n      /* TODO, these are style notes */\n      cursor: pointer;\n      text-align: center;\n      background-color: #000; }\n      .dg.main .close-button:hover {\n        background-color: #111; }\n  .dg.a {\n    float: right;\n    margin-right: 15px;\n    overflow-x: hidden; }\n    .dg.a.has-save > ul {\n      margin-top: 27px; }\n      .dg.a.has-save > ul.closed {\n        margin-top: 0; }\n    .dg.a .save-row {\n      position: fixed;\n      top: 0;\n      z-index: 1002; }\n  .dg li {\n    -webkit-transition: height 0.1s ease-out;\n    -o-transition: height 0.1s ease-out;\n    -moz-transition: height 0.1s ease-out;\n    transition: height 0.1s ease-out; }\n  .dg li:not(.folder) {\n    cursor: auto;\n    height: 27px;\n    line-height: 27px;\n    overflow: hidden;\n    padding: 0 4px 0 5px; }\n  .dg li.folder {\n    padding: 0;\n    border-left: 4px solid transparent; }\n  .dg li.title {\n    cursor: pointer;\n    margin-left: -4px; }\n  .dg .closed li:not(.title),\n  .dg .closed ul li,\n  .dg .closed ul li > * {\n    height: 0;\n    overflow: hidden;\n    border: 0; }\n  .dg .cr {\n    clear: both;\n    padding-left: 3px;\n    height: 27px; }\n  .dg .property-name {\n    cursor: default;\n    float: left;\n    clear: left;\n    width: 40%;\n    overflow: hidden;\n    text-overflow: ellipsis; }\n  .dg .c {\n    float: left;\n    width: 60%; }\n  .dg .c input[type=text] {\n    border: 0;\n    margin-top: 4px;\n    padding: 3px;\n    width: 100%;\n    float: right; }\n  .dg .has-slider input[type=text] {\n    width: 30%;\n    /*display: none;*/\n    margin-left: 0; }\n  .dg .slider {\n    float: left;\n    width: 66%;\n    margin-left: -5px;\n    margin-right: 0;\n    height: 19px;\n    margin-top: 4px; }\n  .dg .slider-fg {\n    height: 100%; }\n  .dg .c input[type=checkbox] {\n    margin-top: 9px; }\n  .dg .c select {\n    margin-top: 5px; }\n  .dg .cr.function,\n  .dg .cr.function .property-name,\n  .dg .cr.function *,\n  .dg .cr.boolean,\n  .dg .cr.boolean * {\n    cursor: pointer; }\n  .dg .selector {\n    display: none;\n    position: absolute;\n    margin-left: -9px;\n    margin-top: 23px;\n    z-index: 10; }\n  .dg .c:hover .selector,\n  .dg .selector.drag {\n    display: block; }\n  .dg li.save-row {\n    padding: 0; }\n    .dg li.save-row .button {\n      display: inline-block;\n      padding: 0px 6px; }\n  .dg.dialogue {\n    background-color: #222;\n    width: 460px;\n    padding: 15px;\n    font-size: 13px;\n    line-height: 15px; }\n\n/* TODO Separate style and structure */\n#dg-new-constructor {\n  padding: 10px;\n  color: #222;\n  font-family: Monaco, monospace;\n  font-size: 10px;\n  border: 0;\n  resize: none;\n  box-shadow: inset 1px 1px 1px #888;\n  word-wrap: break-word;\n  margin: 12px 0;\n  display: block;\n  width: 440px;\n  overflow-y: scroll;\n  height: 100px;\n  position: relative; }\n\n#dg-local-explain {\n  display: none;\n  font-size: 11px;\n  line-height: 17px;\n  border-radius: 3px;\n  background-color: #333;\n  padding: 8px;\n  margin-top: 10px; }\n  #dg-local-explain code {\n    font-size: 10px; }\n\n#dat-gui-save-locally {\n  display: none; }\n\n/** Main type */\n.dg {\n  color: #eee;\n  font: 11px 'Lucida Grande', sans-serif;\n  text-shadow: 0 -1px 0 #111;\n  /** Auto place */\n  /* Controller row, <li> */\n  /** Controllers */ }\n  .dg.main {\n    /** Scrollbar */ }\n    .dg.main::-webkit-scrollbar {\n      width: 5px;\n      background: #1a1a1a; }\n    .dg.main::-webkit-scrollbar-corner {\n      height: 0;\n      display: none; }\n    .dg.main::-webkit-scrollbar-thumb {\n      border-radius: 5px;\n      background: #676767; }\n  .dg li:not(.folder) {\n    background: #1a1a1a;\n    border-bottom: 1px solid #2c2c2c; }\n  .dg li.save-row {\n    line-height: 25px;\n    background: #dad5cb;\n    border: 0; }\n    .dg li.save-row select {\n      margin-left: 5px;\n      width: 108px; }\n    .dg li.save-row .button {\n      margin-left: 5px;\n      margin-top: 1px;\n      border-radius: 2px;\n      font-size: 9px;\n      line-height: 7px;\n      padding: 4px 4px 5px 4px;\n      background: #c5bdad;\n      color: #fff;\n      text-shadow: 0 1px 0 #b0a58f;\n      box-shadow: 0 -1px 0 #b0a58f;\n      cursor: pointer; }\n      .dg li.save-row .button.gears {\n        background: #c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;\n        height: 7px;\n        width: 8px; }\n      .dg li.save-row .button:hover {\n        background-color: #bab19e;\n        box-shadow: 0 -1px 0 #b0a58f; }\n  .dg li.folder {\n    border-bottom: 0; }\n  .dg li.title {\n    padding-left: 16px;\n    background: #000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;\n    cursor: pointer;\n    border-bottom: 1px solid rgba(255, 255, 255, 0.2); }\n  .dg .closed li.title {\n    background-image: url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==); }\n  .dg .cr.boolean {\n    border-left: 3px solid #806787; }\n  .dg .cr.color {\n    border-left: 3px solid; }\n  .dg .cr.function {\n    border-left: 3px solid #e61d5f; }\n  .dg .cr.number {\n    border-left: 3px solid #2FA1D6; }\n    .dg .cr.number input[type=text] {\n      color: #2FA1D6; }\n  .dg .cr.string {\n    border-left: 3px solid #1ed36f; }\n    .dg .cr.string input[type=text] {\n      color: #1ed36f; }\n  .dg .cr.function:hover, .dg .cr.boolean:hover {\n    background: #111; }\n  .dg .c input[type=text] {\n    background: #303030;\n    outline: none; }\n    .dg .c input[type=text]:hover {\n      background: #3c3c3c; }\n    .dg .c input[type=text]:focus {\n      background: #494949;\n      color: #fff; }\n  .dg .c .slider {\n    background: #303030;\n    cursor: ew-resize; }\n  .dg .c .slider-fg {\n    background: #2FA1D6;\n    max-width: 100%; }\n  .dg .c .slider:hover {\n    background: #3c3c3c; }\n    .dg .c .slider:hover .slider-fg {\n      background: #44abda; }\n", ""]);

			// exports


			/***/
		},
		/* 24 */
		/***/function (module, exports) {

			/*
   	MIT License http://www.opensource.org/licenses/mit-license.php
   	Author Tobias Koppers @sokra
   */
			// css base code, injected by the css-loader
			module.exports = function () {
				var list = [];

				// return the list of modules as css string
				list.toString = function toString() {
					var result = [];
					for (var i = 0; i < this.length; i++) {
						var item = this[i];
						if (item[2]) {
							result.push("@media " + item[2] + "{" + item[1] + "}");
						} else {
							result.push(item[1]);
						}
					}
					return result.join("");
				};

				// import a list of modules into the list
				list.i = function (modules, mediaQuery) {
					if (typeof modules === "string") modules = [[null, modules, ""]];
					var alreadyImportedModules = {};
					for (var i = 0; i < this.length; i++) {
						var id = this[i][0];
						if (typeof id === "number") alreadyImportedModules[id] = true;
					}
					for (i = 0; i < modules.length; i++) {
						var item = modules[i];
						// skip already imported module
						// this implementation is not 100% perfect for weird media query combinations
						//  when a module is imported multiple times with different media queries.
						//  I hope this will never occur (Hey this way we have smaller bundles)
						if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
							if (mediaQuery && !item[2]) {
								item[2] = mediaQuery;
							} else if (mediaQuery) {
								item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
							}
							list.push(item);
						}
					}
				};
				return list;
			};

			/***/
		}
		/******/])
	);
});
;


},{}],9:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//download.js v4.2, by dandavis; 2008-2016. [CCBY2] see http://danml.com/download.html for tests/usage
// v1 landed a FF+Chrome compat way of downloading strings to local un-named files, upgraded to use a hidden frame and optional mime
// v2 added named files via a[download], msSaveBlob, IE (10+) support, and window.URL support for larger+faster saves than dataURLs
// v3 added dataURL and Blob Input, bind-toggle arity, and legacy dataURL fallback was improved with force-download mime and base64 support. 3.1 improved safari handling.
// v4 adds AMD/UMD, commonJS, and plain browser support
// v4.1 adds url download capability via solo URL argument (same domain/CORS only)
// v4.2 adds semantic variable names, long (over 2MB) dataURL support, and hidden by default temp anchors
// https://github.com/rndme/download

(function (root, factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define([], factory);
	} else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
		// Node. Does not work with strict CommonJS, but
		// only CommonJS-like environments that support module.exports,
		// like Node.
		module.exports = factory();
	} else {
		// Browser globals (root is window)
		root.download = factory();
	}
})(undefined, function () {

	return function download(data, strFileName, strMimeType) {

		var self = window,
		    // this script is only for browsers anyway...
		defaultMime = "application/octet-stream",
		    // this default mime also triggers iframe downloads
		mimeType = strMimeType || defaultMime,
		    payload = data,
		    url = !strFileName && !strMimeType && payload,
		    anchor = document.createElement("a"),
		    toString = function toString(a) {
			return String(a);
		},
		    myBlob = self.Blob || self.MozBlob || self.WebKitBlob || toString,
		    fileName = strFileName || "download",
		    blob,
		    reader;
		myBlob = myBlob.call ? myBlob.bind(self) : Blob;

		if (String(this) === "true") {
			//reverse arguments, allowing download.bind(true, "text/xml", "export.xml") to act as a callback
			payload = [payload, mimeType];
			mimeType = payload[0];
			payload = payload[1];
		}

		if (url && url.length < 2048) {
			// if no filename and no mime, assume a url was passed as the only argument
			fileName = url.split("/").pop().split("?")[0];
			anchor.href = url; // assign href prop to temp anchor
			if (anchor.href.indexOf(url) !== -1) {
				// if the browser determines that it's a potentially valid url path:
				var ajax = new XMLHttpRequest();
				ajax.open("GET", url, true);
				ajax.responseType = 'blob';
				ajax.onload = function (e) {
					download(e.target.response, fileName, defaultMime);
				};
				setTimeout(function () {
					ajax.send();
				}, 0); // allows setting custom ajax headers using the return:
				return ajax;
			} // end if valid url?
		} // end if url?


		//go ahead and download dataURLs right away
		if (/^data\:[\w+\-]+\/[\w+\-]+[,;]/.test(payload)) {

			if (payload.length > 1024 * 1024 * 1.999 && myBlob !== toString) {
				payload = dataUrlToBlob(payload);
				mimeType = payload.type || defaultMime;
			} else {
				return navigator.msSaveBlob ? // IE10 can't do a[download], only Blobs:
				navigator.msSaveBlob(dataUrlToBlob(payload), fileName) : saver(payload); // everyone else can save dataURLs un-processed
			}
		} //end if dataURL passed?

		blob = payload instanceof myBlob ? payload : new myBlob([payload], { type: mimeType });

		function dataUrlToBlob(strUrl) {
			var parts = strUrl.split(/[:;,]/),
			    type = parts[1],
			    decoder = parts[2] == "base64" ? atob : decodeURIComponent,
			    binData = decoder(parts.pop()),
			    mx = binData.length,
			    i = 0,
			    uiArr = new Uint8Array(mx);

			for (i; i < mx; ++i) {
				uiArr[i] = binData.charCodeAt(i);
			}return new myBlob([uiArr], { type: type });
		}

		function saver(url, winMode) {

			if ('download' in anchor) {
				//html5 A[download]
				anchor.href = url;
				anchor.setAttribute("download", fileName);
				anchor.className = "download-js-link";
				anchor.innerHTML = "downloading...";
				anchor.style.display = "none";
				document.body.appendChild(anchor);
				setTimeout(function () {
					anchor.click();
					document.body.removeChild(anchor);
					if (winMode === true) {
						setTimeout(function () {
							self.URL.revokeObjectURL(anchor.href);
						}, 250);
					}
				}, 66);
				return true;
			}

			// handle non-a[download] safari as best we can:
			if (/(Version)\/(\d+)\.(\d+)(?:\.(\d+))?.*Safari\//.test(navigator.userAgent)) {
				url = url.replace(/^data:([\w\/\-\+]+)/, defaultMime);
				if (!window.open(url)) {
					// popup blocked, offer direct download:
					if (confirm("Displaying New Document\n\nUse Save As... to download, then click back to return to this page.")) {
						location.href = url;
					}
				}
				return true;
			}

			//do iframe dataURL download (old ch+FF):
			var f = document.createElement("iframe");
			document.body.appendChild(f);

			if (!winMode) {
				// force a mime that will download:
				url = "data:" + url.replace(/^data:([\w\/\-\+]+)/, defaultMime);
			}
			f.src = url;
			setTimeout(function () {
				document.body.removeChild(f);
			}, 333);
		} //end saver


		if (navigator.msSaveBlob) {
			// IE10+ : (has Blob, but not a[download] or URL)
			return navigator.msSaveBlob(blob, fileName);
		}

		if (self.URL) {
			// simple fast and modern way using Blob and URL:
			saver(self.URL.createObjectURL(blob), true);
		} else {
			// handle non-Blob()+non-URL browsers:
			if (typeof blob === "string" || blob.constructor === toString) {
				try {
					return saver("data:" + mimeType + ";base64," + self.btoa(blob));
				} catch (y) {
					return saver("data:" + mimeType + "," + encodeURIComponent(blob));
				}
			}

			// Blob but not URL support:
			reader = new FileReader();
			reader.onload = function (e) {
				saver(this.result);
			};
			reader.readAsDataURL(blob);
		}
		return true;
	}; /* end download() */
});

},{}],10:[function(require,module,exports){
'use strict';

var _PaintControl = require('./Controls/PaintControl');

var _PaintControl2 = _interopRequireDefault(_PaintControl);

var _svg = require('svg.js');

var _svg2 = _interopRequireDefault(_svg);

var _UIManagement = require('./model/UIManagement');

var UI = _interopRequireWildcard(_UIManagement);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(function () {
	var draw = (0, _svg2.default)('drawing').size(1000, 1000);
	UI.setGUI();
	setControl(draw);
})();

function setControl(_container) {
	var isMouseDown = false;
	var currnetControl = new _PaintControl2.default(_container);
	var top = _container.node.getBoundingClientRect().top;
	var left = _container.node.getBoundingClientRect().left;

	_container.on('mousedown', function (e) {
		var point = [e.clientX - top, e.clientY - left];
		isMouseDown = true;
		currnetControl.start(point);
	});
	_container.on('mouseup', function () {
		isMouseDown = false;
		currnetControl.end();
	});
	_container.on('mousemove', function (e) {
		var x = e.offsetX;
		var y = e.offsetY;
		if (isMouseDown) {
			currnetControl.update([x, y]);
		}
	});
}

},{"./Controls/PaintControl":7,"./model/UIManagement":14,"svg.js":6}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = {
	selectedCurve: []
};

},{}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _bezierJs = require('bezier-js');

var _bezierJs2 = _interopRequireDefault(_bezierJs);

var _MagneticCurve = require('../model/MagneticCurve');

var _MagneticCurve2 = _interopRequireDefault(_MagneticCurve);

var _CurveManagement = require('./CurveManagement');

var _CurveManagement2 = _interopRequireDefault(_CurveManagement);

var _UIManagement = require('../model/UIManagement');

var UI = _interopRequireWildcard(_UIManagement);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LevelCurve = function () {
	/**
 	@param levelParam : array
 	length : number
 	alpha : number
 	branches : number
 */
	function LevelCurve(basePath, trunkWidth, levelParam) {
		_classCallCheck(this, LevelCurve);

		this.basePath = basePath;
		this.trunkWidth = trunkWidth;
		this.levelParam = levelParam;
		this.curveGroup = undefined;
	}

	_createClass(LevelCurve, [{
		key: 'drawLevelCurve',
		value: function drawLevelCurve(beziers, level) {
			var _this = this;

			if (!beziers) return;
			var sign = 1;

			var Bs = beziers.map(function (b) {
				return new _bezierJs2.default(b[0][0], b[0][1], b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]);
			});

			var totalLength = Bs.reduce(function (length, B) {
				return B.length() + length;
			}, 0);

			this.branchPosition(level).forEach(function (i) {
				if (totalLength === 0) return;

				var bezierIndex = 0;

				var pos = totalLength * i;
				while (pos >= Bs[bezierIndex].length()) {
					pos -= Bs[bezierIndex].length();
					bezierIndex++;
				}

				var posOnSinglebezier = pos / Bs[bezierIndex].length();

				_this.drawAt(posOnSinglebezier, Bs[bezierIndex], sign, level);

				sign *= -1;
			});
		}
	}, {
		key: 'drawAt',
		value: function drawAt(t, b, sign, level) {
			var start = b.get(t);
			var v = b.derivative(t);
			var mag = new _MagneticCurve2.default({
				startX: start.x,
				startY: start.y,
				vx: v.x,
				vy: v.y,
				T: this.levelParam[level].length,
				alpha: this.levelParam[level].alpha,
				sign: sign
			});
			mag.drawOn(this.curveGroup);
			if (level < this.levelParam.length - 1) this.drawLevelCurve(mag.points, level + 1);
		}
	}, {
		key: 'drawOn',
		value: function drawOn(pannel) {
			this.pannel = pannel;
			this.curveGroup = pannel.group();
			pannel.add(this.curveGroup);
			_CurveManagement2.default[this.curveGroup.node.id] = this;
			this.curveGroup.on('click', function (e) {
				console.log('clecked');

				var curve_id = e.target.parentElement.id;
				var lvCurve = _CurveManagement2.default[curve_id];
				_CurveManagement2.default.selectedCurve.length = 0;
				_CurveManagement2.default.selectedCurve.push(lvCurve);
			});

			this.drawLevelCurve(this.basePath, 0);
			this.drawStem(UI.state.trunkWidth);
			this.drawStem(UI.state.trunkWidth / 3);
		}
	}, {
		key: 'drawStem',
		value: function drawStem(width, color) {
			var _this2 = this;

			var basePath = this.basePath.map(function (c) {
				return new _bezierJs2.default(c[0][0], c[0][1], c[1][0], c[1][1], c[2][0], c[2][1], c[3][0], c[3][1]);
			});

			var totalLength = basePath.reduce(function (length, B) {
				return B.length() + length;
			}, 0);

			var l = 0;
			var w = width;

			var outline = basePath.map(function (b) {
				var d1 = w * l / totalLength;
				l += b.length();
				var d2 = w * l / totalLength;
				if (d1 === 0) d1 = 1;
				return b.outline(d1, d1, d2, d2);
			});
			outline.forEach(function (b) {
				var pathString = fittedCurveToPathString(b);
				drawOnPannel(_this2.curveGroup, pathString, color);
			});
		}
	}, {
		key: 'redraw',
		value: function redraw() {
			if (this.pannel === undefined) {
				console.error('can not redraw!');
				return;
			}
			this.curveGroup.remove();
			this.drawOn(this.pannel);
		}
	}, {
		key: 'branchPosition',
		value: function branchPosition(level) {
			var branches = [];
			var branch = this.levelParam[level].branches;

			var pos = 1 / (branch + 1);
			for (var i = 1; i <= branch; i++) {
				branches.push(pos * i);
			}

			return branches;
		}
	}]);

	return LevelCurve;
}();

exports.default = LevelCurve;

function fittedCurveToPathString(fittedLineData) {
	var str = '';
	//bezier : [ [c0], [c1], [c2], [c3] ]
	fittedLineData.curves.map(function (bezier, i) {
		if (i == 0) {
			str += 'M ' + bezier.points[0].x + ' ' + bezier.points[0].y;
		}

		str += 'C ' + bezier.points[1].x + ' ' + bezier.points[1].y + ', ' + bezier.points[2].x + ' ' + bezier.points[2].y + ', ' + bezier.points[3].x + ' ' + bezier.points[3].y + ' ';
	});

	return str;
}
function drawOnPannel(pannel, pathString, color) {
	pannel.path(pathString).fill(color).stroke({ width: 0 });
}

},{"../model/MagneticCurve":13,"../model/UIManagement":14,"./CurveManagement":11,"bezier-js":1}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _fitCurve = require('fit-curve');

var _fitCurve2 = _interopRequireDefault(_fitCurve);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var error = 1;

var MagneticCurve = function () {
	function MagneticCurve(param) {
		_classCallCheck(this, MagneticCurve);

		/*
  startX, startY : 初始點
  vx, vy : 初始速度
  T : 總點數
  alpha : 等角螺線參數
  sign : 電荷正負
  */
		this.param = param;
	}

	_createClass(MagneticCurve, [{
		key: 'makeCurve',
		value: function makeCurve() {
			var points = [];

			var sign = this.param.sign || 1;
			var x = this.param.startX;
			var y = this.param.startY;

			var _normalize = normalize([this.param.vx, this.param.vy]),
			    _normalize2 = _slicedToArray(_normalize, 2),
			    vx = _normalize2[0],
			    vy = _normalize2[1];

			var T = this.param.T;
			var t = 0;
			var dt = 1;

			while (t < T) {
				points.push([x, y]);
				var q = sign * Math.pow(T - t, -1 * this.param.alpha);
				x += vx * dt;
				y += vy * dt;

				var ax = -1 * vy * q;
				var ay = vx * q;

				vx += ax * dt;
				vy += ay * dt;

				t += dt;
			}

			return points;
		}
	}, {
		key: 'drawOn',
		value: function drawOn(pannel) {
			var mag = this.makeCurve();
			var smoothBizer = (0, _fitCurve2.default)(mag, error);
			this.points = smoothBizer;

			var pathString = fittedCurveToPathString(smoothBizer);

			pannel.path(pathString).fill('none').stroke({ width: 3 }).stroke('#f00');
		}
	}]);

	return MagneticCurve;
}();

exports.default = MagneticCurve;

function fittedCurveToPathString(fittedLineData) {
	var str = '';
	//bezier : [ [c0], [c1], [c2], [c3] ]
	fittedLineData.forEach(function (bezier, i) {
		if (i == 0) {
			str += 'M ' + bezier[0][0] + ' ' + bezier[0][1];
		}

		str += 'C ' + bezier[1][0] + ' ' + bezier[1][1] + ', ' + bezier[2][0] + ' ' + bezier[2][1] + ', ' + bezier[3][0] + ' ' + bezier[3][1] + ' ';
	});

	return str;
}

function normalize(vector) {
	var x = vector[0];
	var y = vector[1];
	var length = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));

	return [x / length, y / length];
}

},{"fit-curve":5}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.state = undefined;
exports.setGUI = setGUI;

var _dat = require('../lib/dat.gui');

var dat = _interopRequireWildcard(_dat);

var _download2 = require('../lib/download');

var _download3 = _interopRequireDefault(_download2);

var _CurveManagement = require('./CurveManagement');

var _CurveManagement2 = _interopRequireDefault(_CurveManagement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var gui = void 0,
    folders = [];
var controls = [];
var state = exports.state = {
	trunkWidth: 15,
	intersect: false,
	levelCurve: [{
		length: 100,
		alpha: 0.9,
		branches: 5
	}, {
		length: 20,
		alpha: 0.8,
		branches: 5
	}]
};

var features = {
	download: function download() {
		var svg = document.getElementsByTagName('svg')[0];
		(0, _download3.default)(svg.outerHTML, 'file.svg', 'text/plain');
	}
};

function setGUI() {
	gui = new dat.GUI();

	var c = gui.add(state, 'trunkWidth', 1, 20);
	controls.push(c);
	//gui.add(state, 'intersect');

	levelFolder(0);
	levelFolder(1);
	setOnChange(controls);

	gui.add(features, 'download');
}

function levelFolder(index) {
	var folder = gui.addFolder('Level ' + index);
	controls.push(folder.add(state.levelCurve[index], 'length'));
	controls.push(folder.add(state.levelCurve[index], 'alpha'));
	controls.push(folder.add(state.levelCurve[index], 'branches').step(1));
	folders.push(folder);
}

function setOnChange(controls) {
	controls.forEach(function (c) {
		c.onChange(function () {
			if (_CurveManagement2.default.selectedCurve.length === 1) {
				_CurveManagement2.default.selectedCurve[0].redraw();
			}
		});
	});
}

},{"../lib/dat.gui":8,"../lib/download":9,"./CurveManagement":11}]},{},[10])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmV6aWVyLWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jlemllci1qcy9saWIvYmV6aWVyLmpzIiwibm9kZV9tb2R1bGVzL2Jlemllci1qcy9saWIvcG9seS1iZXppZXIuanMiLCJub2RlX21vZHVsZXMvYmV6aWVyLWpzL2xpYi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9maXQtY3VydmUvc3JjL2ZpdC1jdXJ2ZS5qcyIsIm5vZGVfbW9kdWxlcy9zdmcuanMvZGlzdC9zdmcuanMiLCJzcmMvQ29udHJvbHMvUGFpbnRDb250cm9sLmpzIiwic3JjL2xpYi9kYXQuZ3VpLmpzIiwic3JjL2xpYi9kb3dubG9hZC5qcyIsInNyYy9tYWluLmpzIiwic3JjL21vZGVsL0N1cnZlTWFuYWdlbWVudC5qcyIsInNyYy9tb2RlbC9MZXZlbEN1cnZlLmpzIiwic3JjL21vZGVsL01hZ25ldGljQ3VydmUuanMiLCJzcmMvbW9kZWwvVUlNYW5hZ2VtZW50LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaDFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUVBOztBQUVELFNBQVMsV0FBVCxDQUFxQixLQUFyQixFQUEyQjtBQUMxQixLQUFJLFNBQVMsSUFBSSxTQUFKLFlBQXVCLEtBQXZCLENBQWI7QUFDQSxVQUFTLElBQVQsQ0FBZSxPQUFPLEdBQVAsQ0FBVyxNQUFNLFVBQU4sQ0FBaUIsS0FBakIsQ0FBWCxFQUFvQyxRQUFwQyxDQUFmO0FBQ0EsVUFBUyxJQUFULENBQWUsT0FBTyxHQUFQLENBQVcsTUFBTSxVQUFOLENBQWlCLEtBQWpCLENBQVgsRUFBb0MsT0FBcEMsQ0FBZjtBQUNBLFVBQVMsSUFBVCxDQUFlLE9BQU8sR0FBUCxDQUFXLE1BQU0sVUFBTixDQUFpQixLQUFqQixDQUFYLEVBQW9DLFVBQXBDLEVBQWdELElBQWhELENBQXFELENBQXJELENBQWY7QUFDQSxTQUFRLElBQVIsQ0FBYSxNQUFiO0FBQ0E7O0FBRUQsU0FBUyxXQUFULENBQXFCLFFBQXJCLEVBQThCO0FBQzdCLFVBQVMsT0FBVCxDQUFrQixhQUFLO0FBQ3RCLElBQUUsUUFBRixDQUFZLFlBQU07QUFDakIsT0FBSSwwQkFBZ0IsYUFBaEIsQ0FBOEIsTUFBOUIsS0FBeUMsQ0FBN0MsRUFBZ0Q7QUFDL0MsOEJBQWdCLGFBQWhCLENBQThCLENBQTlCLEVBQWlDLE1BQWpDO0FBQ0E7QUFDRCxHQUpEO0FBS0EsRUFORDtBQU9BIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvYmV6aWVyJyk7XG4iLCIvKipcbiAgQSBqYXZhc2NyaXB0IEJlemllciBjdXJ2ZSBsaWJyYXJ5IGJ5IFBvbWF4LlxuXG4gIEJhc2VkIG9uIGh0dHA6Ly9wb21heC5naXRodWIuaW8vYmV6aWVyaW5mb1xuXG4gIFRoaXMgY29kZSBpcyBNSVQgbGljZW5zZWQuXG4qKi9cbihmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgLy8gbWF0aC1pbmxpbmluZy5cbiAgdmFyIGFicyA9IE1hdGguYWJzLFxuICAgICAgbWluID0gTWF0aC5taW4sXG4gICAgICBtYXggPSBNYXRoLm1heCxcbiAgICAgIGFjb3MgPSBNYXRoLmFjb3MsXG4gICAgICBzcXJ0ID0gTWF0aC5zcXJ0LFxuICAgICAgcGkgPSBNYXRoLlBJLFxuICAgICAgLy8gYSB6ZXJvIGNvb3JkaW5hdGUsIHdoaWNoIGlzIHN1cnByaXNpbmdseSB1c2VmdWxcbiAgICAgIFpFUk8gPSB7eDowLHk6MCx6OjB9O1xuXG4gIC8vIHF1aXRlIG5lZWRlZFxuICB2YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzLmpzJyk7XG5cbiAgLy8gbm90IHF1aXRlIG5lZWRlZCwgYnV0IGV2ZW50dWFsbHkgdGhpcydsbCBiZSB1c2VmdWwuLi5cbiAgdmFyIFBvbHlCZXppZXIgPSByZXF1aXJlKCcuL3BvbHktYmV6aWVyLmpzJyk7XG5cbiAgLyoqXG4gICAqIEJlemllciBjdXJ2ZSBjb25zdHJ1Y3Rvci4gVGhlIGNvbnN0cnVjdG9yIGFyZ3VtZW50IGNhbiBiZSBvbmUgb2YgdGhyZWUgdGhpbmdzOlxuICAgKlxuICAgKiAxLiBhcnJheS80IG9mIHt4Oi4uLiwgeTouLi4sIHo6Li4ufSwgeiBvcHRpb25hbFxuICAgKiAyLiBudW1lcmljYWwgYXJyYXkvOCBvcmRlcmVkIHgxLHkxLHgyLHkyLHgzLHkzLHg0LHk0XG4gICAqIDMuIG51bWVyaWNhbCBhcnJheS8xMiBvcmRlcmVkIHgxLHkxLHoxLHgyLHkyLHoyLHgzLHkzLHozLHg0LHk0LHo0XG4gICAqXG4gICAqL1xuICB2YXIgQmV6aWVyID0gZnVuY3Rpb24oY29vcmRzKSB7XG4gICAgdmFyIGFyZ3MgPSAoY29vcmRzICYmIGNvb3Jkcy5mb3JFYWNoKSA/IGNvb3JkcyA6IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgY29vcmRsZW4gPSBmYWxzZTtcbiAgICBpZih0eXBlb2YgYXJnc1swXSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29vcmRsZW4gPSBhcmdzLmxlbmd0aDtcbiAgICAgIHZhciBuZXdhcmdzID0gW107XG4gICAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgWyd4JywneScsJ3onXS5mb3JFYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICBpZih0eXBlb2YgcG9pbnRbZF0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIG5ld2FyZ3MucHVzaChwb2ludFtkXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgYXJncyA9IG5ld2FyZ3M7XG4gICAgfVxuICAgIHZhciBoaWdoZXIgPSBmYWxzZTtcbiAgICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gICAgaWYgKGNvb3JkbGVuKSB7XG4gICAgICBpZihjb29yZGxlbj40KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBuZXcgQmV6aWVyKHBvaW50W10pIGlzIGFjY2VwdGVkIGZvciA0dGggYW5kIGhpZ2hlciBvcmRlciBjdXJ2ZXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgaGlnaGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYobGVuIT09NiAmJiBsZW4hPT04ICYmIGxlbiE9PTkgJiYgbGVuIT09MTIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG5ldyBCZXppZXIocG9pbnRbXSkgaXMgYWNjZXB0ZWQgZm9yIDR0aCBhbmQgaGlnaGVyIG9yZGVyIGN1cnZlc1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgXzNkID0gKCFoaWdoZXIgJiYgKGxlbiA9PT0gOSB8fCBsZW4gPT09IDEyKSkgfHwgKGNvb3JkcyAmJiBjb29yZHNbMF0gJiYgdHlwZW9mIGNvb3Jkc1swXS56ICE9PSBcInVuZGVmaW5lZFwiKTtcbiAgICB0aGlzLl8zZCA9IF8zZDtcbiAgICB2YXIgcG9pbnRzID0gW107XG4gICAgZm9yKHZhciBpZHg9MCwgc3RlcD0oXzNkID8gMyA6IDIpOyBpZHg8bGVuOyBpZHgrPXN0ZXApIHtcbiAgICAgIHZhciBwb2ludCA9IHtcbiAgICAgICAgeDogYXJnc1tpZHhdLFxuICAgICAgICB5OiBhcmdzW2lkeCsxXVxuICAgICAgfTtcbiAgICAgIGlmKF8zZCkgeyBwb2ludC56ID0gYXJnc1tpZHgrMl0gfTtcbiAgICAgIHBvaW50cy5wdXNoKHBvaW50KTtcbiAgICB9XG4gICAgdGhpcy5vcmRlciA9IHBvaW50cy5sZW5ndGggLSAxO1xuICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xuICAgIHZhciBkaW1zID0gWyd4JywneSddO1xuICAgIGlmKF8zZCkgZGltcy5wdXNoKCd6Jyk7XG4gICAgdGhpcy5kaW1zID0gZGltcztcbiAgICB0aGlzLmRpbWxlbiA9IGRpbXMubGVuZ3RoO1xuXG4gICAgKGZ1bmN0aW9uKGN1cnZlKSB7XG4gICAgICB2YXIgb3JkZXIgPSBjdXJ2ZS5vcmRlcjtcbiAgICAgIHZhciBwb2ludHMgPSBjdXJ2ZS5wb2ludHM7XG4gICAgICB2YXIgYSA9IHV0aWxzLmFsaWduKHBvaW50cywge3AxOnBvaW50c1swXSwgcDI6cG9pbnRzW29yZGVyXX0pO1xuICAgICAgZm9yKHZhciBpPTA7IGk8YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZihhYnMoYVtpXS55KSA+IDAuMDAwMSkge1xuICAgICAgICAgIGN1cnZlLl9saW5lYXIgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN1cnZlLl9saW5lYXIgPSB0cnVlO1xuICAgIH0odGhpcykpO1xuXG4gICAgdGhpcy5fdDEgPSAwO1xuICAgIHRoaXMuX3QyID0gMTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9O1xuXG4gIEJlemllci5mcm9tU1ZHID0gZnVuY3Rpb24oc3ZnU3RyaW5nKSB7XG4gICAgdmFyIGxpc3QgPSBzdmdTdHJpbmcubWF0Y2goL1stK10/XFxkKlxcLj9cXGQrKD86W2VFXVstK10/XFxkKyk/L2cpLm1hcChwYXJzZUZsb2F0KTtcbiAgICB2YXIgcmVsYXRpdmUgPSAvW2NxXS8udGVzdChzdmdTdHJpbmcpO1xuICAgIGlmKCFyZWxhdGl2ZSkgcmV0dXJuIG5ldyBCZXppZXIobGlzdCk7XG4gICAgbGlzdCA9IGxpc3QubWFwKGZ1bmN0aW9uKHYsaSkge1xuICAgICAgcmV0dXJuIGkgPCAyID8gdiA6IHYgKyBsaXN0W2kgJSAyXTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IEJlemllcihsaXN0KTtcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRBQkMobixTLEIsRSx0KSB7XG4gICAgaWYodHlwZW9mIHQgPT09IFwidW5kZWZpbmVkXCIpIHsgdCA9IDAuNTsgfVxuICAgIHZhciB1ID0gdXRpbHMucHJvamVjdGlvbnJhdGlvKHQsbiksXG4gICAgICAgIHVtID0gMS11LFxuICAgICAgICBDID0ge1xuICAgICAgICAgIHg6IHUqUy54ICsgdW0qRS54LFxuICAgICAgICAgIHk6IHUqUy55ICsgdW0qRS55XG4gICAgICAgIH0sXG4gICAgICAgIHMgPSB1dGlscy5hYmNyYXRpbyh0LG4pLFxuICAgICAgICBBID0ge1xuICAgICAgICAgIHg6IEIueCArIChCLngtQy54KS9zLFxuICAgICAgICAgIHk6IEIueSArIChCLnktQy55KS9zXG4gICAgICAgIH07XG4gICAgcmV0dXJuIHsgQTpBLCBCOkIsIEM6QyB9O1xuICB9XG5cbiAgQmV6aWVyLnF1YWRyYXRpY0Zyb21Qb2ludHMgPSBmdW5jdGlvbihwMSxwMixwMywgdCkge1xuICAgIGlmKHR5cGVvZiB0ID09PSBcInVuZGVmaW5lZFwiKSB7IHQgPSAwLjU7IH1cbiAgICAvLyBzaG9ydGN1dHMsIGFsdGhvdWdoIHRoZXkncmUgcmVhbGx5IGR1bWJcbiAgICBpZih0PT09MCkgeyByZXR1cm4gbmV3IEJlemllcihwMixwMixwMyk7IH1cbiAgICBpZih0PT09MSkgeyByZXR1cm4gbmV3IEJlemllcihwMSxwMixwMik7IH1cbiAgICAvLyByZWFsIGZpdHRpbmcuXG4gICAgdmFyIGFiYyA9IGdldEFCQygyLHAxLHAyLHAzLHQpO1xuICAgIHJldHVybiBuZXcgQmV6aWVyKHAxLCBhYmMuQSwgcDMpO1xuICB9O1xuXG4gIEJlemllci5jdWJpY0Zyb21Qb2ludHMgPSBmdW5jdGlvbihTLEIsRSwgdCxkMSkge1xuICAgIGlmKHR5cGVvZiB0ID09PSBcInVuZGVmaW5lZFwiKSB7IHQgPSAwLjU7IH1cbiAgICB2YXIgYWJjID0gZ2V0QUJDKDMsUyxCLEUsdCk7XG4gICAgaWYodHlwZW9mIGQxID09PSBcInVuZGVmaW5lZFwiKSB7IGQxID0gdXRpbHMuZGlzdChCLGFiYy5DKTsgfVxuICAgIHZhciBkMiA9IGQxICogKDEtdCkvdDtcblxuICAgIHZhciBzZWxlbiA9IHV0aWxzLmRpc3QoUyxFKSxcbiAgICAgICAgbHggPSAoRS54LVMueCkvc2VsZW4sXG4gICAgICAgIGx5ID0gKEUueS1TLnkpL3NlbGVuLFxuICAgICAgICBieDEgPSBkMSAqIGx4LFxuICAgICAgICBieTEgPSBkMSAqIGx5LFxuICAgICAgICBieDIgPSBkMiAqIGx4LFxuICAgICAgICBieTIgPSBkMiAqIGx5O1xuICAgIC8vIGRlcml2YXRpb24gb2YgbmV3IGh1bGwgY29vcmRpbmF0ZXNcbiAgICB2YXIgZTEgID0geyB4OiBCLnggLSBieDEsIHk6IEIueSAtIGJ5MSB9LFxuICAgICAgICBlMiAgPSB7IHg6IEIueCArIGJ4MiwgeTogQi55ICsgYnkyIH0sXG4gICAgICAgIEEgPSBhYmMuQSxcbiAgICAgICAgdjEgID0geyB4OiBBLnggKyAoZTEueC1BLngpLygxLXQpLCB5OiBBLnkgKyAoZTEueS1BLnkpLygxLXQpIH0sXG4gICAgICAgIHYyICA9IHsgeDogQS54ICsgKGUyLngtQS54KS8odCksIHk6IEEueSArIChlMi55LUEueSkvKHQpIH0sXG4gICAgICAgIG5jMSA9IHsgeDogUy54ICsgKHYxLngtUy54KS8odCksIHk6IFMueSArICh2MS55LVMueSkvKHQpIH0sXG4gICAgICAgIG5jMiA9IHsgeDogRS54ICsgKHYyLngtRS54KS8oMS10KSwgeTogRS55ICsgKHYyLnktRS55KS8oMS10KSB9O1xuICAgIC8vIC4uLmRvbmVcbiAgICByZXR1cm4gbmV3IEJlemllcihTLG5jMSxuYzIsRSk7XG4gIH07XG5cbiAgdmFyIGdldFV0aWxzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHV0aWxzO1xuICB9O1xuXG4gIEJlemllci5nZXRVdGlscyA9IGdldFV0aWxzO1xuXG4gIEJlemllci5wcm90b3R5cGUgPSB7XG4gICAgZ2V0VXRpbHM6IGdldFV0aWxzLFxuICAgIHZhbHVlT2Y6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgICB9LFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB1dGlscy5wb2ludHNUb1N0cmluZyh0aGlzLnBvaW50cyk7XG4gICAgfSxcbiAgICB0b1NWRzogZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgICAgIGlmKHRoaXMuXzNkKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgcCA9IHRoaXMucG9pbnRzLFxuICAgICAgICAgIHggPSBwWzBdLngsXG4gICAgICAgICAgeSA9IHBbMF0ueSxcbiAgICAgICAgICBzID0gW1wiTVwiLCB4LCB5LCAodGhpcy5vcmRlcj09PTIgPyBcIlFcIjpcIkNcIildO1xuICAgICAgZm9yKHZhciBpPTEsIGxhc3Q9cC5sZW5ndGg7IGk8bGFzdDsgaSsrKSB7XG4gICAgICAgIHMucHVzaChwW2ldLngpO1xuICAgICAgICBzLnB1c2gocFtpXS55KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzLmpvaW4oXCIgXCIpO1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIG9uZS10aW1lIGNvbXB1dGUgZGVyaXZhdGl2ZSBjb29yZGluYXRlc1xuICAgICAgdGhpcy5kcG9pbnRzID0gW107XG4gICAgICBmb3IodmFyIHA9dGhpcy5wb2ludHMsIGQ9cC5sZW5ndGgsIGM9ZC0xOyBkPjE7IGQtLSwgYy0tKSB7XG4gICAgICAgIHZhciBsaXN0ID0gW107XG4gICAgICAgIGZvcih2YXIgaj0wLCBkcHQ7IGo8YzsgaisrKSB7XG4gICAgICAgICAgZHB0ID0ge1xuICAgICAgICAgICAgeDogYyAqIChwW2orMV0ueCAtIHBbal0ueCksXG4gICAgICAgICAgICB5OiBjICogKHBbaisxXS55IC0gcFtqXS55KVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYodGhpcy5fM2QpIHtcbiAgICAgICAgICAgIGRwdC56ID0gYyAqIChwW2orMV0ueiAtIHBbal0ueik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxpc3QucHVzaChkcHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHBvaW50cy5wdXNoKGxpc3QpO1xuICAgICAgICBwID0gbGlzdDtcbiAgICAgIH07XG4gICAgICB0aGlzLmNvbXB1dGVkaXJlY3Rpb24oKTtcbiAgICB9LFxuICAgIGNvbXB1dGVkaXJlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgICAgdmFyIGFuZ2xlID0gdXRpbHMuYW5nbGUocG9pbnRzWzBdLCBwb2ludHNbdGhpcy5vcmRlcl0sIHBvaW50c1sxXSk7XG4gICAgICB0aGlzLmNsb2Nrd2lzZSA9IGFuZ2xlID4gMDtcbiAgICB9LFxuICAgIGxlbmd0aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdXRpbHMubGVuZ3RoKHRoaXMuZGVyaXZhdGl2ZS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuICAgIF9sdXQ6IFtdLFxuICAgIGdldExVVDogZnVuY3Rpb24oc3RlcHMpIHtcbiAgICAgIHN0ZXBzID0gc3RlcHMgfHwgMTAwO1xuICAgICAgaWYgKHRoaXMuX2x1dC5sZW5ndGggPT09IHN0ZXBzKSB7IHJldHVybiB0aGlzLl9sdXQ7IH1cbiAgICAgIHRoaXMuX2x1dCA9IFtdO1xuICAgICAgZm9yKHZhciB0PTA7IHQ8PXN0ZXBzOyB0KyspIHtcbiAgICAgICAgdGhpcy5fbHV0LnB1c2godGhpcy5jb21wdXRlKHQvc3RlcHMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9sdXQ7XG4gICAgfSxcbiAgICBvbjogZnVuY3Rpb24ocG9pbnQsIGVycm9yKSB7XG4gICAgICBlcnJvciA9IGVycm9yIHx8IDU7XG4gICAgICB2YXIgbHV0ID0gdGhpcy5nZXRMVVQoKSwgaGl0cyA9IFtdLCBjLCB0PTA7XG4gICAgICBmb3IodmFyIGk9MDsgaTxsdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYyA9IGx1dFtpXTtcbiAgICAgICAgaWYgKHV0aWxzLmRpc3QoYyxwb2ludCkgPCBlcnJvcikge1xuICAgICAgICAgIGhpdHMucHVzaChjKVxuICAgICAgICAgIHQgKz0gaSAvIGx1dC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKCFoaXRzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHQgLz0gaGl0cy5sZW5ndGg7XG4gICAgfSxcbiAgICBwcm9qZWN0OiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgLy8gc3RlcCAxOiBjb2Fyc2UgY2hlY2tcbiAgICAgIHZhciBMVVQgPSB0aGlzLmdldExVVCgpLCBsID0gTFVULmxlbmd0aC0xLFxuICAgICAgICAgIGNsb3Nlc3QgPSB1dGlscy5jbG9zZXN0KExVVCwgcG9pbnQpLFxuICAgICAgICAgIG1kaXN0ID0gY2xvc2VzdC5tZGlzdCxcbiAgICAgICAgICBtcG9zID0gY2xvc2VzdC5tcG9zO1xuICAgICAgaWYgKG1wb3M9PT0wIHx8IG1wb3M9PT1sKSB7XG4gICAgICAgIHZhciB0ID0gbXBvcy9sLCBwdCA9IHRoaXMuY29tcHV0ZSh0KTtcbiAgICAgICAgcHQudCA9IHQ7XG4gICAgICAgIHB0LmQgPSBtZGlzdDtcbiAgICAgICAgcmV0dXJuIHB0O1xuICAgICAgfVxuXG4gICAgICAvLyBzdGVwIDI6IGZpbmUgY2hlY2tcbiAgICAgIHZhciBmdCwgdCwgcCwgZCxcbiAgICAgICAgICB0MSA9IChtcG9zLTEpL2wsXG4gICAgICAgICAgdDIgPSAobXBvcysxKS9sLFxuICAgICAgICAgIHN0ZXAgPSAwLjEvbDtcbiAgICAgIG1kaXN0ICs9IDE7XG4gICAgICBmb3IodD10MSxmdD10OyB0PHQyK3N0ZXA7IHQrPXN0ZXApIHtcbiAgICAgICAgcCA9IHRoaXMuY29tcHV0ZSh0KTtcbiAgICAgICAgZCA9IHV0aWxzLmRpc3QocG9pbnQsIHApO1xuICAgICAgICBpZiAoZDxtZGlzdCkge1xuICAgICAgICAgIG1kaXN0ID0gZDtcbiAgICAgICAgICBmdCA9IHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHAgPSB0aGlzLmNvbXB1dGUoZnQpO1xuICAgICAgcC50ID0gZnQ7XG4gICAgICBwLmQgPSBtZGlzdDtcbiAgICAgIHJldHVybiBwO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21wdXRlKHQpO1xuICAgIH0sXG4gICAgcG9pbnQ6IGZ1bmN0aW9uKGlkeCkge1xuICAgICAgcmV0dXJuIHRoaXMucG9pbnRzW2lkeF07XG4gICAgfSxcbiAgICBjb21wdXRlOiBmdW5jdGlvbih0KSB7XG4gICAgICAvLyBzaG9ydGN1dHNcbiAgICAgIGlmKHQ9PT0wKSB7IHJldHVybiB0aGlzLnBvaW50c1swXTsgfVxuICAgICAgaWYodD09PTEpIHsgcmV0dXJuIHRoaXMucG9pbnRzW3RoaXMub3JkZXJdOyB9XG5cbiAgICAgIHZhciBwID0gdGhpcy5wb2ludHM7XG4gICAgICB2YXIgbXQgPSAxLXQ7XG5cbiAgICAgIC8vIGxpbmVhcj9cbiAgICAgIGlmKHRoaXMub3JkZXI9PT0xKSB7XG4gICAgICAgIHJldCA9IHtcbiAgICAgICAgICB4OiBtdCpwWzBdLnggKyB0KnBbMV0ueCxcbiAgICAgICAgICB5OiBtdCpwWzBdLnkgKyB0KnBbMV0ueVxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5fM2QpIHsgcmV0LnogPSBtdCpwWzBdLnogKyB0KnBbMV0uejsgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuXG4gICAgICAvLyBxdWFkcmF0aWMvY3ViaWMgY3VydmU/XG4gICAgICBpZih0aGlzLm9yZGVyPDQpIHtcbiAgICAgICAgdmFyIG10MiA9IG10Km10LFxuICAgICAgICAgICAgdDIgPSB0KnQsXG4gICAgICAgICAgICBhLGIsYyxkID0gMDtcbiAgICAgICAgaWYodGhpcy5vcmRlcj09PTIpIHtcbiAgICAgICAgICBwID0gW3BbMF0sIHBbMV0sIHBbMl0sIFpFUk9dO1xuICAgICAgICAgIGEgPSBtdDI7XG4gICAgICAgICAgYiA9IG10KnQqMjtcbiAgICAgICAgICBjID0gdDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZih0aGlzLm9yZGVyPT09Mykge1xuICAgICAgICAgIGEgPSBtdDIqbXQ7XG4gICAgICAgICAgYiA9IG10Mip0KjM7XG4gICAgICAgICAgYyA9IG10KnQyKjM7XG4gICAgICAgICAgZCA9IHQqdDI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgICB4OiBhKnBbMF0ueCArIGIqcFsxXS54ICsgYypwWzJdLnggKyBkKnBbM10ueCxcbiAgICAgICAgICB5OiBhKnBbMF0ueSArIGIqcFsxXS55ICsgYypwWzJdLnkgKyBkKnBbM10ueVxuICAgICAgICB9O1xuICAgICAgICBpZih0aGlzLl8zZCkge1xuICAgICAgICAgIHJldC56ID0gYSpwWzBdLnogKyBiKnBbMV0ueiArIGMqcFsyXS56ICsgZCpwWzNdLno7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cblxuICAgICAgLy8gaGlnaGVyIG9yZGVyIGN1cnZlczogdXNlIGRlIENhc3RlbGphdSdzIGNvbXB1dGF0aW9uXG4gICAgICB2YXIgZENwdHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMucG9pbnRzKSk7XG4gICAgICB3aGlsZShkQ3B0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxkQ3B0cy5sZW5ndGgtMTsgaSsrKSB7XG4gICAgICAgICAgZENwdHNbaV0gPSB7XG4gICAgICAgICAgICB4OiBkQ3B0c1tpXS54ICsgKGRDcHRzW2krMV0ueCAtIGRDcHRzW2ldLngpICogdCxcbiAgICAgICAgICAgIHk6IGRDcHRzW2ldLnkgKyAoZENwdHNbaSsxXS55IC0gZENwdHNbaV0ueSkgKiB0XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAodHlwZW9mIGRDcHRzW2ldLnogIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGRDcHRzW2ldID0gZENwdHNbaV0ueiArIChkQ3B0c1tpKzFdLnogLSBkQ3B0c1tpXS56KSAqIHRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZENwdHMuc3BsaWNlKGRDcHRzLmxlbmd0aC0xLCAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkQ3B0c1swXTtcbiAgICB9LFxuICAgIHJhaXNlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwID0gdGhpcy5wb2ludHMsIG5wID0gW3BbMF1dLCBpLCBrPXAubGVuZ3RoLCBwaSwgcGltO1xuICAgICAgZm9yICh2YXIgaT0xOyBpPGs7IGkrKykge1xuICAgICAgICBwaSA9IHBbaV07XG4gICAgICAgIHBpbSA9IHBbaS0xXTtcbiAgICAgICAgbnBbaV0gPSB7XG4gICAgICAgICAgeDogKGstaSkvayAqIHBpLnggKyBpL2sgKiBwaW0ueCxcbiAgICAgICAgICB5OiAoay1pKS9rICogcGkueSArIGkvayAqIHBpbS55XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBucFtrXSA9IHBbay0xXTtcbiAgICAgIHJldHVybiBuZXcgQmV6aWVyKG5wKTtcbiAgICB9LFxuICAgIGRlcml2YXRpdmU6IGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBtdCA9IDEtdCxcbiAgICAgICAgICBhLGIsYz0wLFxuICAgICAgICAgIHAgPSB0aGlzLmRwb2ludHNbMF07XG4gICAgICBpZih0aGlzLm9yZGVyPT09MikgeyBwID0gW3BbMF0sIHBbMV0sIFpFUk9dOyBhID0gbXQ7IGIgPSB0OyB9XG4gICAgICBpZih0aGlzLm9yZGVyPT09MykgeyBhID0gbXQqbXQ7IGIgPSBtdCp0KjI7IGMgPSB0KnQ7IH1cbiAgICAgIHZhciByZXQgPSB7XG4gICAgICAgIHg6IGEqcFswXS54ICsgYipwWzFdLnggKyBjKnBbMl0ueCxcbiAgICAgICAgeTogYSpwWzBdLnkgKyBiKnBbMV0ueSArIGMqcFsyXS55XG4gICAgICB9O1xuICAgICAgaWYodGhpcy5fM2QpIHtcbiAgICAgICAgcmV0LnogPSBhKnBbMF0ueiArIGIqcFsxXS56ICsgYypwWzJdLno7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG4gICAgaW5mbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHV0aWxzLmluZmxlY3Rpb25zKHRoaXMucG9pbnRzKTtcbiAgICB9LFxuICAgIG5vcm1hbDogZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIHRoaXMuXzNkID8gdGhpcy5fX25vcm1hbDModCkgOiB0aGlzLl9fbm9ybWFsMih0KTtcbiAgICB9LFxuICAgIF9fbm9ybWFsMjogZnVuY3Rpb24odCkge1xuICAgICAgdmFyIGQgPSB0aGlzLmRlcml2YXRpdmUodCk7XG4gICAgICB2YXIgcSA9IHNxcnQoZC54KmQueCArIGQueSpkLnkpXG4gICAgICByZXR1cm4geyB4OiAtZC55L3EsIHk6IGQueC9xIH07XG4gICAgfSxcbiAgICBfX25vcm1hbDM6IGZ1bmN0aW9uKHQpIHtcbiAgICAgIC8vIHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI1NDUzMTU5XG4gICAgICB2YXIgcjEgPSB0aGlzLmRlcml2YXRpdmUodCksXG4gICAgICAgICAgcjIgPSB0aGlzLmRlcml2YXRpdmUodCswLjAxKSxcbiAgICAgICAgICBxMSA9IHNxcnQocjEueCpyMS54ICsgcjEueSpyMS55ICsgcjEueipyMS56KSxcbiAgICAgICAgICBxMiA9IHNxcnQocjIueCpyMi54ICsgcjIueSpyMi55ICsgcjIueipyMi56KTtcbiAgICAgIHIxLnggLz0gcTE7IHIxLnkgLz0gcTE7IHIxLnogLz0gcTE7XG4gICAgICByMi54IC89IHEyOyByMi55IC89IHEyOyByMi56IC89IHEyO1xuICAgICAgLy8gY3Jvc3MgcHJvZHVjdFxuICAgICAgdmFyIGMgPSB7XG4gICAgICAgIHg6IHIyLnkqcjEueiAtIHIyLnoqcjEueSxcbiAgICAgICAgeTogcjIueipyMS54IC0gcjIueCpyMS56LFxuICAgICAgICB6OiByMi54KnIxLnkgLSByMi55KnIxLnhcbiAgICAgIH07XG4gICAgICB2YXIgbSA9IHNxcnQoYy54KmMueCArIGMueSpjLnkgKyBjLnoqYy56KTtcbiAgICAgIGMueCAvPSBtOyBjLnkgLz0gbTsgYy56IC89IG07XG4gICAgICAvLyByb3RhdGlvbiBtYXRyaXhcbiAgICAgIHZhciBSID0gWyAgIGMueCpjLngsICAgYy54KmMueS1jLnosIGMueCpjLnorYy55LFxuICAgICAgICAgICAgICAgIGMueCpjLnkrYy56LCAgIGMueSpjLnksICAgYy55KmMuei1jLngsXG4gICAgICAgICAgICAgICAgYy54KmMuei1jLnksIGMueSpjLnorYy54LCAgIGMueipjLnogICAgXTtcbiAgICAgIC8vIG5vcm1hbCB2ZWN0b3I6XG4gICAgICB2YXIgbiA9IHtcbiAgICAgICAgeDogUlswXSAqIHIxLnggKyBSWzFdICogcjEueSArIFJbMl0gKiByMS56LFxuICAgICAgICB5OiBSWzNdICogcjEueCArIFJbNF0gKiByMS55ICsgUls1XSAqIHIxLnosXG4gICAgICAgIHo6IFJbNl0gKiByMS54ICsgUls3XSAqIHIxLnkgKyBSWzhdICogcjEuelxuICAgICAgfTtcbiAgICAgIHJldHVybiBuO1xuICAgIH0sXG4gICAgaHVsbDogZnVuY3Rpb24odCkge1xuICAgICAgdmFyIHAgPSB0aGlzLnBvaW50cyxcbiAgICAgICAgICBfcCA9IFtdLFxuICAgICAgICAgIHB0LFxuICAgICAgICAgIHEgPSBbXSxcbiAgICAgICAgICBpZHggPSAwLFxuICAgICAgICAgIGk9MCxcbiAgICAgICAgICBsPTA7XG4gICAgICBxW2lkeCsrXSA9IHBbMF07XG4gICAgICBxW2lkeCsrXSA9IHBbMV07XG4gICAgICBxW2lkeCsrXSA9IHBbMl07XG4gICAgICBpZih0aGlzLm9yZGVyID09PSAzKSB7IHFbaWR4KytdID0gcFszXTsgfVxuICAgICAgLy8gd2UgbGVycCBiZXR3ZWVuIGFsbCBwb2ludHMgYXQgZWFjaCBpdGVyYXRpb24sIHVudGlsIHdlIGhhdmUgMSBwb2ludCBsZWZ0LlxuICAgICAgd2hpbGUocC5sZW5ndGg+MSkge1xuICAgICAgICBfcCA9IFtdO1xuICAgICAgICBmb3IoaT0wLCBsPXAubGVuZ3RoLTE7IGk8bDsgaSsrKSB7XG4gICAgICAgICAgcHQgPSB1dGlscy5sZXJwKHQscFtpXSxwW2krMV0pO1xuICAgICAgICAgIHFbaWR4KytdID0gcHQ7XG4gICAgICAgICAgX3AucHVzaChwdCk7XG4gICAgICAgIH1cbiAgICAgICAgcCA9IF9wO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHE7XG4gICAgfSxcbiAgICBzcGxpdDogZnVuY3Rpb24odDEsIHQyKSB7XG4gICAgICAvLyBzaG9ydGN1dHNcbiAgICAgIGlmKHQxPT09MCAmJiAhIXQyKSB7IHJldHVybiB0aGlzLnNwbGl0KHQyKS5sZWZ0OyB9XG4gICAgICBpZih0Mj09PTEpIHsgcmV0dXJuIHRoaXMuc3BsaXQodDEpLnJpZ2h0OyB9XG5cbiAgICAgIC8vIG5vIHNob3J0Y3V0OiB1c2UgXCJkZSBDYXN0ZWxqYXVcIiBpdGVyYXRpb24uXG4gICAgICB2YXIgcSA9IHRoaXMuaHVsbCh0MSk7XG4gICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBsZWZ0OiB0aGlzLm9yZGVyID09PSAyID8gbmV3IEJlemllcihbcVswXSxxWzNdLHFbNV1dKSA6IG5ldyBCZXppZXIoW3FbMF0scVs0XSxxWzddLHFbOV1dKSxcbiAgICAgICAgcmlnaHQ6IHRoaXMub3JkZXIgPT09IDIgPyBuZXcgQmV6aWVyKFtxWzVdLHFbNF0scVsyXV0pIDogbmV3IEJlemllcihbcVs5XSxxWzhdLHFbNl0scVszXV0pLFxuICAgICAgICBzcGFuOiBxXG4gICAgICB9O1xuXG4gICAgICAvLyBtYWtlIHN1cmUgd2UgYmluZCBfdDEvX3QyIGluZm9ybWF0aW9uIVxuICAgICAgcmVzdWx0LmxlZnQuX3QxICA9IHV0aWxzLm1hcCgwLCAgMCwxLCB0aGlzLl90MSx0aGlzLl90Mik7XG4gICAgICByZXN1bHQubGVmdC5fdDIgID0gdXRpbHMubWFwKHQxLCAwLDEsIHRoaXMuX3QxLHRoaXMuX3QyKTtcbiAgICAgIHJlc3VsdC5yaWdodC5fdDEgPSB1dGlscy5tYXAodDEsIDAsMSwgdGhpcy5fdDEsdGhpcy5fdDIpO1xuICAgICAgcmVzdWx0LnJpZ2h0Ll90MiA9IHV0aWxzLm1hcCgxLCAgMCwxLCB0aGlzLl90MSx0aGlzLl90Mik7XG5cbiAgICAgIC8vIGlmIHdlIGhhdmUgbm8gdDIsIHdlJ3JlIGRvbmVcbiAgICAgIGlmKCF0MikgeyByZXR1cm4gcmVzdWx0OyB9XG5cbiAgICAgIC8vIGlmIHdlIGhhdmUgYSB0Miwgc3BsaXQgYWdhaW46XG4gICAgICB0MiA9IHV0aWxzLm1hcCh0Mix0MSwxLDAsMSk7XG4gICAgICB2YXIgc3Vic3BsaXQgPSByZXN1bHQucmlnaHQuc3BsaXQodDIpO1xuICAgICAgcmV0dXJuIHN1YnNwbGl0LmxlZnQ7XG4gICAgfSxcbiAgICBleHRyZW1hOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkaW1zID0gdGhpcy5kaW1zLFxuICAgICAgICAgIHJlc3VsdD17fSxcbiAgICAgICAgICByb290cz1bXSxcbiAgICAgICAgICBwLCBtZm47XG4gICAgICBkaW1zLmZvckVhY2goZnVuY3Rpb24oZGltKSB7XG4gICAgICAgIG1mbiA9IGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHZbZGltXTsgfTtcbiAgICAgICAgcCA9IHRoaXMuZHBvaW50c1swXS5tYXAobWZuKTtcbiAgICAgICAgcmVzdWx0W2RpbV0gPSB1dGlscy5kcm9vdHMocCk7XG4gICAgICAgIGlmKHRoaXMub3JkZXIgPT09IDMpIHtcbiAgICAgICAgICBwID0gdGhpcy5kcG9pbnRzWzFdLm1hcChtZm4pO1xuICAgICAgICAgIHJlc3VsdFtkaW1dID0gcmVzdWx0W2RpbV0uY29uY2F0KHV0aWxzLmRyb290cyhwKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2RpbV0gPSByZXN1bHRbZGltXS5maWx0ZXIoZnVuY3Rpb24odCkgeyByZXR1cm4gKHQ+PTAgJiYgdDw9MSk7IH0pO1xuICAgICAgICByb290cyA9IHJvb3RzLmNvbmNhdChyZXN1bHRbZGltXS5zb3J0KCkpO1xuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgIHJvb3RzID0gcm9vdHMuc29ydCgpLmZpbHRlcihmdW5jdGlvbih2LGlkeCkgeyByZXR1cm4gKHJvb3RzLmluZGV4T2YodikgPT09IGlkeCk7IH0pO1xuICAgICAgcmVzdWx0LnZhbHVlcyA9IHJvb3RzO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIGJib3g6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGV4dHJlbWEgPSB0aGlzLmV4dHJlbWEoKSwgcmVzdWx0ID0ge307XG4gICAgICB0aGlzLmRpbXMuZm9yRWFjaChmdW5jdGlvbihkKSB7XG4gICAgICAgIHJlc3VsdFtkXSA9IHV0aWxzLmdldG1pbm1heCh0aGlzLCBkLCBleHRyZW1hW2RdKTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgb3ZlcmxhcHM6IGZ1bmN0aW9uKGN1cnZlKSB7XG4gICAgICB2YXIgbGJib3ggPSB0aGlzLmJib3goKSxcbiAgICAgICAgICB0YmJveCA9IGN1cnZlLmJib3goKTtcbiAgICAgIHJldHVybiB1dGlscy5iYm94b3ZlcmxhcChsYmJveCx0YmJveCk7XG4gICAgfSxcbiAgICBvZmZzZXQ6IGZ1bmN0aW9uKHQsIGQpIHtcbiAgICAgIGlmKHR5cGVvZiBkICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5nZXQodCk7XG4gICAgICAgIHZhciBuID0gdGhpcy5ub3JtYWwodCk7XG4gICAgICAgIHZhciByZXQgPSB7XG4gICAgICAgICAgYzogYyxcbiAgICAgICAgICBuOiBuLFxuICAgICAgICAgIHg6IGMueCArIG4ueCAqIGQsXG4gICAgICAgICAgeTogYy55ICsgbi55ICogZFxuICAgICAgICB9O1xuICAgICAgICBpZih0aGlzLl8zZCkge1xuICAgICAgICAgIHJldC56ID0gYy56ICsgbi56ICogZDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICAgIGlmKHRoaXMuX2xpbmVhcikge1xuICAgICAgICB2YXIgbnYgPSB0aGlzLm5vcm1hbCgwKTtcbiAgICAgICAgdmFyIGNvb3JkcyA9IHRoaXMucG9pbnRzLm1hcChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgICAgIHg6IHAueCArIHQgKiBudi54LFxuICAgICAgICAgICAgeTogcC55ICsgdCAqIG52LnlcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmKHAueiAmJiBuLnopIHsgcmV0LnogPSBwLnogKyB0ICogbnYuejsgfVxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW25ldyBCZXppZXIoY29vcmRzKV07XG4gICAgICB9XG4gICAgICB2YXIgcmVkdWNlZCA9IHRoaXMucmVkdWNlKCk7XG4gICAgICByZXR1cm4gcmVkdWNlZC5tYXAoZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gcy5zY2FsZSh0KTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2ltcGxlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmKHRoaXMub3JkZXI9PT0zKSB7XG4gICAgICAgIHZhciBhMSA9IHV0aWxzLmFuZ2xlKHRoaXMucG9pbnRzWzBdLCB0aGlzLnBvaW50c1szXSwgdGhpcy5wb2ludHNbMV0pO1xuICAgICAgICB2YXIgYTIgPSB1dGlscy5hbmdsZSh0aGlzLnBvaW50c1swXSwgdGhpcy5wb2ludHNbM10sIHRoaXMucG9pbnRzWzJdKTtcbiAgICAgICAgaWYoYTE+MCAmJiBhMjwwIHx8IGExPDAgJiYgYTI+MCkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIG4xID0gdGhpcy5ub3JtYWwoMCk7XG4gICAgICB2YXIgbjIgPSB0aGlzLm5vcm1hbCgxKTtcbiAgICAgIHZhciBzID0gbjEueCpuMi54ICsgbjEueSpuMi55O1xuICAgICAgaWYodGhpcy5fM2QpIHsgcyArPSBuMS56Km4yLno7IH1cbiAgICAgIHZhciBhbmdsZSA9IGFicyhhY29zKHMpKTtcbiAgICAgIHJldHVybiBhbmdsZSA8IHBpLzM7XG4gICAgfSxcbiAgICByZWR1Y2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGksIHQxPTAsIHQyPTAsIHN0ZXA9MC4wMSwgc2VnbWVudCwgcGFzczE9W10sIHBhc3MyPVtdO1xuICAgICAgLy8gZmlyc3QgcGFzczogc3BsaXQgb24gZXh0cmVtYVxuICAgICAgdmFyIGV4dHJlbWEgPSB0aGlzLmV4dHJlbWEoKS52YWx1ZXM7XG4gICAgICBpZihleHRyZW1hLmluZGV4T2YoMCk9PT0tMSkgeyBleHRyZW1hID0gWzBdLmNvbmNhdChleHRyZW1hKTsgfVxuICAgICAgaWYoZXh0cmVtYS5pbmRleE9mKDEpPT09LTEpIHsgZXh0cmVtYS5wdXNoKDEpOyB9XG5cbiAgICAgIGZvcih0MT1leHRyZW1hWzBdLCBpPTE7IGk8ZXh0cmVtYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0MiA9IGV4dHJlbWFbaV07XG4gICAgICAgIHNlZ21lbnQgPSB0aGlzLnNwbGl0KHQxLHQyKTtcbiAgICAgICAgc2VnbWVudC5fdDEgPSB0MTtcbiAgICAgICAgc2VnbWVudC5fdDIgPSB0MjtcbiAgICAgICAgcGFzczEucHVzaChzZWdtZW50KTtcbiAgICAgICAgdDEgPSB0MjtcbiAgICAgIH1cblxuICAgICAgLy8gc2Vjb25kIHBhc3M6IGZ1cnRoZXIgcmVkdWNlIHRoZXNlIHNlZ21lbnRzIHRvIHNpbXBsZSBzZWdtZW50c1xuICAgICAgcGFzczEuZm9yRWFjaChmdW5jdGlvbihwMSkge1xuICAgICAgICB0MT0wO1xuICAgICAgICB0Mj0wO1xuICAgICAgICB3aGlsZSh0MiA8PSAxKSB7XG4gICAgICAgICAgZm9yKHQyPXQxK3N0ZXA7IHQyPD0xK3N0ZXA7IHQyKz1zdGVwKSB7XG4gICAgICAgICAgICBzZWdtZW50ID0gcDEuc3BsaXQodDEsdDIpO1xuICAgICAgICAgICAgaWYoIXNlZ21lbnQuc2ltcGxlKCkpIHtcbiAgICAgICAgICAgICAgdDIgLT0gc3RlcDtcbiAgICAgICAgICAgICAgaWYoYWJzKHQxLXQyKTxzdGVwKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgY2FuIG5ldmVyIGZvcm0gYSByZWR1Y3Rpb25cbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2VnbWVudCA9IHAxLnNwbGl0KHQxLHQyKTtcbiAgICAgICAgICAgICAgc2VnbWVudC5fdDEgPSB1dGlscy5tYXAodDEsMCwxLHAxLl90MSxwMS5fdDIpO1xuICAgICAgICAgICAgICBzZWdtZW50Ll90MiA9IHV0aWxzLm1hcCh0MiwwLDEscDEuX3QxLHAxLl90Mik7XG4gICAgICAgICAgICAgIHBhc3MyLnB1c2goc2VnbWVudCk7XG4gICAgICAgICAgICAgIHQxID0gdDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZih0MTwxKSB7XG4gICAgICAgICAgc2VnbWVudCA9IHAxLnNwbGl0KHQxLDEpO1xuICAgICAgICAgIHNlZ21lbnQuX3QxID0gdXRpbHMubWFwKHQxLDAsMSxwMS5fdDEscDEuX3QyKTtcbiAgICAgICAgICBzZWdtZW50Ll90MiA9IHAxLl90MjtcbiAgICAgICAgICBwYXNzMi5wdXNoKHNlZ21lbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwYXNzMjtcbiAgICB9LFxuICAgIHNjYWxlOiBmdW5jdGlvbihkKSB7XG4gICAgICB2YXIgb3JkZXIgPSB0aGlzLm9yZGVyO1xuICAgICAgdmFyIGRpc3RhbmNlRm4gPSBmYWxzZVxuICAgICAgaWYodHlwZW9mIGQgPT09IFwiZnVuY3Rpb25cIikgeyBkaXN0YW5jZUZuID0gZDsgfVxuICAgICAgaWYoZGlzdGFuY2VGbiAmJiBvcmRlciA9PT0gMikgeyByZXR1cm4gdGhpcy5yYWlzZSgpLnNjYWxlKGRpc3RhbmNlRm4pOyB9XG5cbiAgICAgIC8vIFRPRE86IGFkZCBzcGVjaWFsIGhhbmRsaW5nIGZvciBkZWdlbmVyYXRlICg9bGluZWFyKSBjdXJ2ZXMuXG4gICAgICB2YXIgY2xvY2t3aXNlID0gdGhpcy5jbG9ja3dpc2U7XG4gICAgICB2YXIgcjEgPSBkaXN0YW5jZUZuID8gZGlzdGFuY2VGbigwKSA6IGQ7XG4gICAgICB2YXIgcjIgPSBkaXN0YW5jZUZuID8gZGlzdGFuY2VGbigxKSA6IGQ7XG4gICAgICB2YXIgdiA9IFsgdGhpcy5vZmZzZXQoMCwxMCksIHRoaXMub2Zmc2V0KDEsMTApIF07XG4gICAgICB2YXIgbyA9IHV0aWxzLmxsaTQodlswXSwgdlswXS5jLCB2WzFdLCB2WzFdLmMpO1xuICAgICAgaWYoIW8pIHsgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IHNjYWxlIHRoaXMgY3VydmUuIFRyeSByZWR1Y2luZyBpdCBmaXJzdC5cIik7IH1cbiAgICAgIC8vIG1vdmUgYWxsIHBvaW50cyBieSBkaXN0YW5jZSAnZCcgd3J0IHRoZSBvcmlnaW4gJ28nXG4gICAgICB2YXIgcG9pbnRzPXRoaXMucG9pbnRzLCBucD1bXTtcblxuICAgICAgLy8gbW92ZSBlbmQgcG9pbnRzIGJ5IGZpeGVkIGRpc3RhbmNlIGFsb25nIG5vcm1hbC5cbiAgICAgIFswLDFdLmZvckVhY2goZnVuY3Rpb24odCkge1xuICAgICAgICB2YXIgcCA9IG5wW3Qqb3JkZXJdID0gdXRpbHMuY29weShwb2ludHNbdCpvcmRlcl0pO1xuICAgICAgICBwLnggKz0gKHQ/cjI6cjEpICogdlt0XS5uLng7XG4gICAgICAgIHAueSArPSAodD9yMjpyMSkgKiB2W3RdLm4ueTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgIGlmICghZGlzdGFuY2VGbikge1xuICAgICAgICAvLyBtb3ZlIGNvbnRyb2wgcG9pbnRzIHRvIGxpZSBvbiB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSBvZmZzZXRcbiAgICAgICAgLy8gZGVyaXZhdGl2ZSB2ZWN0b3IsIGFuZCB0aGUgb3JpZ2luLXRocm91Z2gtY29udHJvbCB2ZWN0b3JcbiAgICAgICAgWzAsMV0uZm9yRWFjaChmdW5jdGlvbih0KSB7XG4gICAgICAgICAgaWYodGhpcy5vcmRlcj09PTIgJiYgISF0KSByZXR1cm47XG4gICAgICAgICAgdmFyIHAgPSBucFt0Km9yZGVyXTtcbiAgICAgICAgICB2YXIgZCA9IHRoaXMuZGVyaXZhdGl2ZSh0KTtcbiAgICAgICAgICB2YXIgcDIgPSB7IHg6IHAueCArIGQueCwgeTogcC55ICsgZC55IH07XG4gICAgICAgICAgbnBbdCsxXSA9IHV0aWxzLmxsaTQocCwgcDIsIG8sIHBvaW50c1t0KzFdKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCZXppZXIobnApO1xuICAgICAgfVxuXG4gICAgICAvLyBtb3ZlIGNvbnRyb2wgcG9pbnRzIGJ5IFwiaG93ZXZlciBtdWNoIG5lY2Vzc2FyeSB0b1xuICAgICAgLy8gZW5zdXJlIHRoZSBjb3JyZWN0IHRhbmdlbnQgdG8gZW5kcG9pbnRcIi5cbiAgICAgIFswLDFdLmZvckVhY2goZnVuY3Rpb24odCkge1xuICAgICAgICBpZih0aGlzLm9yZGVyPT09MiAmJiAhIXQpIHJldHVybjtcbiAgICAgICAgdmFyIHAgPSBwb2ludHNbdCsxXTtcbiAgICAgICAgdmFyIG92ID0ge1xuICAgICAgICAgIHg6IHAueCAtIG8ueCxcbiAgICAgICAgICB5OiBwLnkgLSBvLnlcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJjID0gZGlzdGFuY2VGbiA/IGRpc3RhbmNlRm4oKHQrMSkvb3JkZXIpIDogZDtcbiAgICAgICAgaWYoZGlzdGFuY2VGbiAmJiAhY2xvY2t3aXNlKSByYyA9IC1yYztcbiAgICAgICAgdmFyIG0gPSBzcXJ0KG92Lngqb3YueCArIG92Lnkqb3YueSk7XG4gICAgICAgIG92LnggLz0gbTtcbiAgICAgICAgb3YueSAvPSBtO1xuICAgICAgICBucFt0KzFdID0ge1xuICAgICAgICAgIHg6IHAueCArIHJjKm92LngsXG4gICAgICAgICAgeTogcC55ICsgcmMqb3YueVxuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgcmV0dXJuIG5ldyBCZXppZXIobnApO1xuICAgIH0sXG4gICAgb3V0bGluZTogZnVuY3Rpb24oZDEsIGQyLCBkMywgZDQpIHtcbiAgICAgIGQyID0gKHR5cGVvZiBkMiA9PT0gXCJ1bmRlZmluZWRcIikgPyBkMSA6IGQyO1xuICAgICAgdmFyIHJlZHVjZWQgPSB0aGlzLnJlZHVjZSgpLFxuICAgICAgICAgIGxlbiA9IHJlZHVjZWQubGVuZ3RoLFxuICAgICAgICAgIGZjdXJ2ZXMgPSBbXSxcbiAgICAgICAgICBiY3VydmVzID0gW10sXG4gICAgICAgICAgcCxcbiAgICAgICAgICBhbGVuID0gMCxcbiAgICAgICAgICB0bGVuID0gdGhpcy5sZW5ndGgoKTtcblxuICAgICAgdmFyIGdyYWR1YXRlZCA9ICh0eXBlb2YgZDMgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGQ0ICE9PSBcInVuZGVmaW5lZFwiKTtcblxuICAgICAgZnVuY3Rpb24gbGluZWFyRGlzdGFuY2VGdW5jdGlvbihzLGUsIHRsZW4sYWxlbixzbGVuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgICAgICAgIHZhciBmMSA9IGFsZW4vdGxlbiwgZjIgPSAoYWxlbitzbGVuKS90bGVuLCBkID0gZS1zO1xuICAgICAgICAgIHJldHVybiB1dGlscy5tYXAodiwgMCwxLCBzK2YxKmQsIHMrZjIqZCk7XG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICAvLyBmb3JtIGN1cnZlIG91bGluZXNcbiAgICAgIHJlZHVjZWQuZm9yRWFjaChmdW5jdGlvbihzZWdtZW50KSB7XG4gICAgICAgIHNsZW4gPSBzZWdtZW50Lmxlbmd0aCgpO1xuICAgICAgICBpZiAoZ3JhZHVhdGVkKSB7XG4gICAgICAgICAgZmN1cnZlcy5wdXNoKHNlZ21lbnQuc2NhbGUoICBsaW5lYXJEaXN0YW5jZUZ1bmN0aW9uKCBkMSwgZDMsIHRsZW4sYWxlbixzbGVuKSAgKSk7XG4gICAgICAgICAgYmN1cnZlcy5wdXNoKHNlZ21lbnQuc2NhbGUoICBsaW5lYXJEaXN0YW5jZUZ1bmN0aW9uKC1kMiwtZDQsIHRsZW4sYWxlbixzbGVuKSAgKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmN1cnZlcy5wdXNoKHNlZ21lbnQuc2NhbGUoIGQxKSk7XG4gICAgICAgICAgYmN1cnZlcy5wdXNoKHNlZ21lbnQuc2NhbGUoLWQyKSk7XG4gICAgICAgIH1cbiAgICAgICAgYWxlbiArPSBzbGVuO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHJldmVyc2UgdGhlIFwicmV0dXJuXCIgb3V0bGluZVxuICAgICAgYmN1cnZlcyA9IGJjdXJ2ZXMubWFwKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcCA9IHMucG9pbnRzO1xuICAgICAgICBpZihwWzNdKSB7IHMucG9pbnRzID0gW3BbM10scFsyXSxwWzFdLHBbMF1dOyB9XG4gICAgICAgIGVsc2UgeyBzLnBvaW50cyA9IFtwWzJdLHBbMV0scFswXV07IH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9KS5yZXZlcnNlKCk7XG5cbiAgICAgIC8vIGZvcm0gdGhlIGVuZGNhcHMgYXMgbGluZXNcbiAgICAgIHZhciBmcyA9IGZjdXJ2ZXNbMF0ucG9pbnRzWzBdLFxuICAgICAgICAgIGZlID0gZmN1cnZlc1tsZW4tMV0ucG9pbnRzW2ZjdXJ2ZXNbbGVuLTFdLnBvaW50cy5sZW5ndGgtMV0sXG4gICAgICAgICAgYnMgPSBiY3VydmVzW2xlbi0xXS5wb2ludHNbYmN1cnZlc1tsZW4tMV0ucG9pbnRzLmxlbmd0aC0xXSxcbiAgICAgICAgICBiZSA9IGJjdXJ2ZXNbMF0ucG9pbnRzWzBdLFxuICAgICAgICAgIGxzID0gdXRpbHMubWFrZWxpbmUoYnMsZnMpLFxuICAgICAgICAgIGxlID0gdXRpbHMubWFrZWxpbmUoZmUsYmUpLFxuICAgICAgICAgIHNlZ21lbnRzID0gW2xzXS5jb25jYXQoZmN1cnZlcykuY29uY2F0KFtsZV0pLmNvbmNhdChiY3VydmVzKSxcbiAgICAgICAgICBzbGVuID0gc2VnbWVudHMubGVuZ3RoO1xuXG4gICAgICByZXR1cm4gbmV3IFBvbHlCZXppZXIoc2VnbWVudHMpO1xuICAgIH0sXG4gICAgb3V0bGluZXNoYXBlczogZnVuY3Rpb24oZDEsIGQyLCBjdXJ2ZUludGVyc2VjdGlvblRocmVzaG9sZCkge1xuICAgICAgZDIgPSBkMiB8fCBkMTtcbiAgICAgIHZhciBvdXRsaW5lID0gdGhpcy5vdXRsaW5lKGQxLGQyKS5jdXJ2ZXM7XG4gICAgICB2YXIgc2hhcGVzID0gW107XG4gICAgICBmb3IodmFyIGk9MSwgbGVuPW91dGxpbmUubGVuZ3RoOyBpIDwgbGVuLzI7IGkrKykge1xuICAgICAgICB2YXIgc2hhcGUgPSB1dGlscy5tYWtlc2hhcGUob3V0bGluZVtpXSwgb3V0bGluZVtsZW4taV0sIGN1cnZlSW50ZXJzZWN0aW9uVGhyZXNob2xkKTtcbiAgICAgICAgc2hhcGUuc3RhcnRjYXAudmlydHVhbCA9IChpID4gMSk7XG4gICAgICAgIHNoYXBlLmVuZGNhcC52aXJ0dWFsID0gKGkgPCBsZW4vMi0xKTtcbiAgICAgICAgc2hhcGVzLnB1c2goc2hhcGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNoYXBlcztcbiAgICB9LFxuICAgIGludGVyc2VjdHM6IGZ1bmN0aW9uKGN1cnZlLCBjdXJ2ZUludGVyc2VjdGlvblRocmVzaG9sZCkge1xuICAgICAgaWYoIWN1cnZlKSByZXR1cm4gdGhpcy5zZWxmaW50ZXJzZWN0cyhjdXJ2ZUludGVyc2VjdGlvblRocmVzaG9sZCk7XG4gICAgICBpZihjdXJ2ZS5wMSAmJiBjdXJ2ZS5wMikge1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lSW50ZXJzZWN0cyhjdXJ2ZSk7XG4gICAgICB9XG4gICAgICBpZihjdXJ2ZSBpbnN0YW5jZW9mIEJlemllcikgeyBjdXJ2ZSA9IGN1cnZlLnJlZHVjZSgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5jdXJ2ZWludGVyc2VjdHModGhpcy5yZWR1Y2UoKSwgY3VydmUsIGN1cnZlSW50ZXJzZWN0aW9uVGhyZXNob2xkKTtcbiAgICB9LFxuICAgIGxpbmVJbnRlcnNlY3RzOiBmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgbXggPSBtaW4obGluZS5wMS54LCBsaW5lLnAyLngpLFxuICAgICAgICAgIG15ID0gbWluKGxpbmUucDEueSwgbGluZS5wMi55KSxcbiAgICAgICAgICBNWCA9IG1heChsaW5lLnAxLngsIGxpbmUucDIueCksXG4gICAgICAgICAgTVkgPSBtYXgobGluZS5wMS55LCBsaW5lLnAyLnkpLFxuICAgICAgICAgIHNlbGY9dGhpcztcbiAgICAgIHJldHVybiB1dGlscy5yb290cyh0aGlzLnBvaW50cywgbGluZSkuZmlsdGVyKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIHAgPSBzZWxmLmdldCh0KTtcbiAgICAgICAgcmV0dXJuIHV0aWxzLmJldHdlZW4ocC54LCBteCwgTVgpICYmIHV0aWxzLmJldHdlZW4ocC55LCBteSwgTVkpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBzZWxmaW50ZXJzZWN0czogZnVuY3Rpb24oY3VydmVJbnRlcnNlY3Rpb25UaHJlc2hvbGQpIHtcbiAgICAgIHZhciByZWR1Y2VkID0gdGhpcy5yZWR1Y2UoKTtcbiAgICAgIC8vIFwic2ltcGxlXCIgY3VydmVzIGNhbm5vdCBpbnRlcnNlY3Qgd2l0aCB0aGVpciBkaXJlY3RcbiAgICAgIC8vIG5laWdoYm91ciwgc28gZm9yIGVhY2ggc2VnbWVudCBYIHdlIGNoZWNrIHdoZXRoZXJcbiAgICAgIC8vIGl0IGludGVyc2VjdHMgWzA6eC0yXVt4KzI6bGFzdF0uXG4gICAgICB2YXIgaSxsZW49cmVkdWNlZC5sZW5ndGgtMixyZXN1bHRzPVtdLHJlc3VsdCxsZWZ0LHJpZ2h0O1xuICAgICAgZm9yKGk9MDsgaTxsZW47IGkrKykge1xuICAgICAgICBsZWZ0ID0gcmVkdWNlZC5zbGljZShpLGkrMSk7XG4gICAgICAgIHJpZ2h0ID0gcmVkdWNlZC5zbGljZShpKzIpO1xuICAgICAgICByZXN1bHQgPSB0aGlzLmN1cnZlaW50ZXJzZWN0cyhsZWZ0LCByaWdodCwgY3VydmVJbnRlcnNlY3Rpb25UaHJlc2hvbGQpO1xuICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5jb25jYXQoIHJlc3VsdCApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSxcbiAgICBjdXJ2ZWludGVyc2VjdHM6IGZ1bmN0aW9uKGMxLCBjMiwgY3VydmVJbnRlcnNlY3Rpb25UaHJlc2hvbGQpIHtcbiAgICAgIHZhciBwYWlycyA9IFtdO1xuICAgICAgLy8gc3RlcCAxOiBwYWlyIG9mZiBhbnkgb3ZlcmxhcHBpbmcgc2VnbWVudHNcbiAgICAgIGMxLmZvckVhY2goZnVuY3Rpb24obCkge1xuICAgICAgICBjMi5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICBpZihsLm92ZXJsYXBzKHIpKSB7XG4gICAgICAgICAgICBwYWlycy5wdXNoKHsgbGVmdDogbCwgcmlnaHQ6IHIgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgLy8gc3RlcCAyOiBmb3IgZWFjaCBwYWlyaW5nLCBydW4gdGhyb3VnaCB0aGUgY29udmVyZ2VuY2UgYWxnb3JpdGhtLlxuICAgICAgdmFyIGludGVyc2VjdGlvbnMgPSBbXTtcbiAgICAgIHBhaXJzLmZvckVhY2goZnVuY3Rpb24ocGFpcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdXRpbHMucGFpcml0ZXJhdGlvbihwYWlyLmxlZnQsIHBhaXIucmlnaHQsIGN1cnZlSW50ZXJzZWN0aW9uVGhyZXNob2xkKTtcbiAgICAgICAgaWYocmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpbnRlcnNlY3Rpb25zID0gaW50ZXJzZWN0aW9ucy5jb25jYXQocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbiAgICB9LFxuICAgIGFyY3M6IGZ1bmN0aW9uKGVycm9yVGhyZXNob2xkKSB7XG4gICAgICBlcnJvclRocmVzaG9sZCA9IGVycm9yVGhyZXNob2xkIHx8IDAuNTtcbiAgICAgIHZhciBjaXJjbGVzID0gW107XG4gICAgICByZXR1cm4gdGhpcy5faXRlcmF0ZShlcnJvclRocmVzaG9sZCwgY2lyY2xlcyk7XG4gICAgfSxcbiAgICBfZXJyb3I6IGZ1bmN0aW9uKHBjLCBucDEsIHMsIGUpIHtcbiAgICAgIHZhciBxID0gKGUgLSBzKSAvIDQsXG4gICAgICAgICAgYzEgPSB0aGlzLmdldChzICsgcSksXG4gICAgICAgICAgYzIgPSB0aGlzLmdldChlIC0gcSksXG4gICAgICAgICAgcmVmID0gdXRpbHMuZGlzdChwYywgbnAxKSxcbiAgICAgICAgICBkMSAgPSB1dGlscy5kaXN0KHBjLCBjMSksXG4gICAgICAgICAgZDIgID0gdXRpbHMuZGlzdChwYywgYzIpO1xuICAgICAgcmV0dXJuIGFicyhkMS1yZWYpICsgYWJzKGQyLXJlZik7XG4gICAgfSxcbiAgICBfaXRlcmF0ZTogZnVuY3Rpb24oZXJyb3JUaHJlc2hvbGQsIGNpcmNsZXMpIHtcbiAgICAgIHZhciBzID0gMCwgZSA9IDEsIHNhZmV0eTtcbiAgICAgIC8vIHdlIGRvIGEgYmluYXJ5IHNlYXJjaCB0byBmaW5kIHRoZSBcImdvb2QgYHRgIGNsb3Nlc3QgdG8gbm8tbG9uZ2VyLWdvb2RcIlxuICAgICAgZG8ge1xuICAgICAgICBzYWZldHk9MDtcblxuICAgICAgICAvLyBzdGVwIDE6IHN0YXJ0IHdpdGggdGhlIG1heGltdW0gcG9zc2libGUgYXJjXG4gICAgICAgIGUgPSAxO1xuXG4gICAgICAgIC8vIHBvaW50czpcbiAgICAgICAgdmFyIG5wMSA9IHRoaXMuZ2V0KHMpLCBucDIsIG5wMywgYXJjLCBwcmV2X2FyYztcblxuICAgICAgICAvLyBib29sZWFuczpcbiAgICAgICAgdmFyIGN1cnJfZ29vZCA9IGZhbHNlLCBwcmV2X2dvb2QgPSBmYWxzZSwgZG9uZTtcblxuICAgICAgICAvLyBudW1iZXJzOlxuICAgICAgICB2YXIgbSA9IGUsIHByZXZfZSA9IDEsIHN0ZXAgPSAwO1xuXG4gICAgICAgIC8vIHN0ZXAgMjogZmluZCB0aGUgYmVzdCBwb3NzaWJsZSBhcmNcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHByZXZfZ29vZCA9IGN1cnJfZ29vZDtcbiAgICAgICAgICBwcmV2X2FyYyA9IGFyYztcbiAgICAgICAgICBtID0gKHMgKyBlKS8yO1xuICAgICAgICAgIHN0ZXArKztcblxuICAgICAgICAgIG5wMiA9IHRoaXMuZ2V0KG0pO1xuICAgICAgICAgIG5wMyA9IHRoaXMuZ2V0KGUpO1xuXG4gICAgICAgICAgYXJjID0gdXRpbHMuZ2V0Y2NlbnRlcihucDEsIG5wMiwgbnAzKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvL2Fsc28gc2F2ZSB0aGUgdCB2YWx1ZXNcbiAgICAgICAgICBhcmMuaW50ZXJ2YWwgPSB7XG4gICAgICAgICAgICBzdGFydDogcyxcbiAgICAgICAgICAgIGVuZDogZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgZXJyb3IgPSB0aGlzLl9lcnJvcihhcmMsIG5wMSwgcywgZSk7XG4gICAgICAgICAgY3Vycl9nb29kID0gKGVycm9yIDw9IGVycm9yVGhyZXNob2xkKTtcblxuICAgICAgICAgIGRvbmUgPSBwcmV2X2dvb2QgJiYgIWN1cnJfZ29vZDtcbiAgICAgICAgICBpZighZG9uZSkgcHJldl9lID0gZTtcblxuICAgICAgICAgIC8vIHRoaXMgYXJjIGlzIGZpbmU6IHdlIGNhbiBtb3ZlICdlJyB1cCB0byBzZWUgaWYgd2UgY2FuIGZpbmQgYSB3aWRlciBhcmNcbiAgICAgICAgICBpZihjdXJyX2dvb2QpIHtcbiAgICAgICAgICAgIC8vIGlmIGUgaXMgYWxyZWFkeSBhdCBtYXgsIHRoZW4gd2UncmUgZG9uZSBmb3IgdGhpcyBhcmMuXG4gICAgICAgICAgICBpZiAoZSA+PSAxKSB7XG4gICAgICAgICAgICAgIHByZXZfZSA9IDE7XG4gICAgICAgICAgICAgIHByZXZfYXJjID0gYXJjO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIG5vdCwgbW92ZSBpdCB1cCBieSBoYWxmIHRoZSBpdGVyYXRpb24gZGlzdGFuY2VcbiAgICAgICAgICAgIGUgPSBlICsgKGUtcykvMjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB0aGlzIGlzIGEgYmFkIGFyYzogd2UgbmVlZCB0byBtb3ZlICdlJyBkb3duIHRvIGZpbmQgYSBnb29kIGFyY1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZSA9IG07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlKCFkb25lICYmIHNhZmV0eSsrPDEwMCk7XG5cbiAgICAgICAgaWYoc2FmZXR5Pj0xMDApIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiYXJjIGFic3RyYWN0aW9uIHNvbWVob3cgZmFpbGVkLi4uXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJbRl0gYXJjIGZvdW5kXCIsIHMsIHByZXZfZSwgcHJldl9hcmMueCwgcHJldl9hcmMueSwgcHJldl9hcmMucywgcHJldl9hcmMuZSk7XG5cbiAgICAgICAgcHJldl9hcmMgPSAocHJldl9hcmMgPyBwcmV2X2FyYyA6IGFyYyk7XG4gICAgICAgIGNpcmNsZXMucHVzaChwcmV2X2FyYyk7XG4gICAgICAgIHMgPSBwcmV2X2U7XG4gICAgICB9XG4gICAgICB3aGlsZShlIDwgMSk7XG4gICAgICByZXR1cm4gY2lyY2xlcztcbiAgICB9XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBCZXppZXI7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMuanMnKTtcblxuICAvKipcbiAgICogUG9seSBCZXppZXJcbiAgICogQHBhcmFtIHtbdHlwZV19IGN1cnZlcyBbZGVzY3JpcHRpb25dXG4gICAqL1xuICB2YXIgUG9seUJlemllciA9IGZ1bmN0aW9uKGN1cnZlcykge1xuICAgIHRoaXMuY3VydmVzID0gW107XG4gICAgdGhpcy5fM2QgPSBmYWxzZTtcbiAgICBpZighIWN1cnZlcykge1xuICAgICAgdGhpcy5jdXJ2ZXMgPSBjdXJ2ZXM7XG4gICAgICB0aGlzLl8zZCA9IHRoaXMuY3VydmVzWzBdLl8zZDtcbiAgICB9XG4gIH1cblxuICBQb2x5QmV6aWVyLnByb3RvdHlwZSA9IHtcbiAgICB2YWx1ZU9mOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXCJbXCIgKyB0aGlzLmN1cnZlcy5tYXAoZnVuY3Rpb24oY3VydmUpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzLnBvaW50c1RvU3RyaW5nKGN1cnZlLnBvaW50cyk7XG4gICAgICB9KS5qb2luKFwiLCBcIikgKyBcIl1cIjtcbiAgICB9LFxuICAgIGFkZEN1cnZlOiBmdW5jdGlvbihjdXJ2ZSkge1xuICAgICAgdGhpcy5jdXJ2ZXMucHVzaChjdXJ2ZSk7XG4gICAgICB0aGlzLl8zZCA9IHRoaXMuXzNkIHx8IGN1cnZlLl8zZDtcbiAgICB9LFxuICAgIGxlbmd0aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJ2ZXMubWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYubGVuZ3RoKCk7IH0pLnJlZHVjZShmdW5jdGlvbihhLGIpIHsgcmV0dXJuIGErYjsgfSk7XG4gICAgfSxcbiAgICBjdXJ2ZTogZnVuY3Rpb24oaWR4KSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJ2ZXNbaWR4XTtcbiAgICB9LFxuICAgIGJib3g6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGMgPSB0aGlzLmN1cnZlcztcbiAgICAgIHZhciBiYm94ID0gY1swXS5iYm94KCk7XG4gICAgICBmb3IodmFyIGk9MTsgaTxjLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHV0aWxzLmV4cGFuZGJveChiYm94LCBjW2ldLmJib3goKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmJveDtcbiAgICB9LFxuICAgIG9mZnNldDogZnVuY3Rpb24oZCkge1xuICAgICAgdmFyIG9mZnNldCA9IFtdO1xuICAgICAgdGhpcy5jdXJ2ZXMuZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldC5jb25jYXQodi5vZmZzZXQoZCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFBvbHlCZXppZXIob2Zmc2V0KTtcbiAgICB9XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBQb2x5QmV6aWVyO1xufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgLy8gbWF0aC1pbmxpbmluZy5cbiAgdmFyIGFicyA9IE1hdGguYWJzLFxuICAgICAgY29zID0gTWF0aC5jb3MsXG4gICAgICBzaW4gPSBNYXRoLnNpbixcbiAgICAgIGFjb3MgPSBNYXRoLmFjb3MsXG4gICAgICBhdGFuMiA9IE1hdGguYXRhbjIsXG4gICAgICBzcXJ0ID0gTWF0aC5zcXJ0LFxuICAgICAgcG93ID0gTWF0aC5wb3csXG4gICAgICAvLyBjdWJlIHJvb3QgZnVuY3Rpb24geWllbGRpbmcgcmVhbCByb290c1xuICAgICAgY3J0ID0gZnVuY3Rpb24odikgeyByZXR1cm4gKHY8MCkgPyAtcG93KC12LDEvMykgOiBwb3codiwxLzMpOyB9LFxuICAgICAgLy8gdHJpZyBjb25zdGFudHNcbiAgICAgIHBpID0gTWF0aC5QSSxcbiAgICAgIHRhdSA9IDIqcGksXG4gICAgICBxdWFydCA9IHBpLzIsXG4gICAgICAvLyBmbG9hdCBwcmVjaXNpb24gc2lnbmlmaWNhbnQgZGVjaW1hbFxuICAgICAgZXBzaWxvbiA9IDAuMDAwMDAxLFxuICAgICAgLy8gZXh0cmVtYXMgdXNlZCBpbiBiYm94IGNhbGN1bGF0aW9uIGFuZCBzaW1pbGFyIGFsZ29yaXRobXNcbiAgICAgIG5NYXggPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICAgIG5NaW4gPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcblxuICAvLyBCZXppZXIgdXRpbGl0eSBmdW5jdGlvbnNcbiAgdmFyIHV0aWxzID0ge1xuICAgIC8vIExlZ2VuZHJlLUdhdXNzIGFic2Npc3NhZSB3aXRoIG49MjQgKHhfaSB2YWx1ZXMsIGRlZmluZWQgYXQgaT1uIGFzIHRoZSByb290cyBvZiB0aGUgbnRoIG9yZGVyIExlZ2VuZHJlIHBvbHlub21pYWwgUG4oeCkpXG4gICAgVHZhbHVlczogW1xuICAgICAgLTAuMDY0MDU2ODkyODYyNjA1NjI2MDg1MDQzMDgyNjI0NzQ1MDM4NTkwOSxcbiAgICAgICAwLjA2NDA1Njg5Mjg2MjYwNTYyNjA4NTA0MzA4MjYyNDc0NTAzODU5MDksXG4gICAgICAtMC4xOTExMTg4Njc0NzM2MTYzMDkxNTg2Mzk4MjA3NTcwNjk2MzE4NDA0LFxuICAgICAgIDAuMTkxMTE4ODY3NDczNjE2MzA5MTU4NjM5ODIwNzU3MDY5NjMxODQwNCxcbiAgICAgIC0wLjMxNTA0MjY3OTY5NjE2MzM3NDM4Njc5MzI5MTMxOTgxMDI0MDc4NjQsXG4gICAgICAgMC4zMTUwNDI2Nzk2OTYxNjMzNzQzODY3OTMyOTEzMTk4MTAyNDA3ODY0LFxuICAgICAgLTAuNDMzNzkzNTA3NjI2MDQ1MTM4NDg3MDg0MjMxOTEzMzQ5NzEyNDUyNCxcbiAgICAgICAwLjQzMzc5MzUwNzYyNjA0NTEzODQ4NzA4NDIzMTkxMzM0OTcxMjQ1MjQsXG4gICAgICAtMC41NDU0MjE0NzEzODg4Mzk1MzU2NTgzNzU2MTcyMTgzNzIzNzAwMTA3LFxuICAgICAgIDAuNTQ1NDIxNDcxMzg4ODM5NTM1NjU4Mzc1NjE3MjE4MzcyMzcwMDEwNyxcbiAgICAgIC0wLjY0ODA5MzY1MTkzNjk3NTU2OTI1MjQ5NTc4NjkxMDc0NzYyNjY2OTYsXG4gICAgICAgMC42NDgwOTM2NTE5MzY5NzU1NjkyNTI0OTU3ODY5MTA3NDc2MjY2Njk2LFxuICAgICAgLTAuNzQwMTI0MTkxNTc4NTU0MzY0MjQzODI4MTAzMDk5OTc4NDI1NTIzMixcbiAgICAgICAwLjc0MDEyNDE5MTU3ODU1NDM2NDI0MzgyODEwMzA5OTk3ODQyNTUyMzIsXG4gICAgICAtMC44MjAwMDE5ODU5NzM5MDI5MjE5NTM5NDk4NzI2Njk3NDUyMDgwNzYxLFxuICAgICAgIDAuODIwMDAxOTg1OTczOTAyOTIxOTUzOTQ5ODcyNjY5NzQ1MjA4MDc2MSxcbiAgICAgIC0wLjg4NjQxNTUyNzAwNDQwMTAzNDIxMzE1NDM0MTk4MjE5Njc1NTA4NzMsXG4gICAgICAgMC44ODY0MTU1MjcwMDQ0MDEwMzQyMTMxNTQzNDE5ODIxOTY3NTUwODczLFxuICAgICAgLTAuOTM4Mjc0NTUyMDAyNzMyNzU4NTIzNjQ5MDAxNzA4NzIxNDQ5NjU0OCxcbiAgICAgICAwLjkzODI3NDU1MjAwMjczMjc1ODUyMzY0OTAwMTcwODcyMTQ0OTY1NDgsXG4gICAgICAtMC45NzQ3Mjg1NTU5NzEzMDk0OTgxOTgzOTE5OTMwMDgxNjkwNjE3NDExLFxuICAgICAgIDAuOTc0NzI4NTU1OTcxMzA5NDk4MTk4MzkxOTkzMDA4MTY5MDYxNzQxMSxcbiAgICAgIC0wLjk5NTE4NzIxOTk5NzAyMTM2MDE3OTk5NzQwOTcwMDczNjgxMTg3NDUsXG4gICAgICAgMC45OTUxODcyMTk5OTcwMjEzNjAxNzk5OTc0MDk3MDA3MzY4MTE4NzQ1XG4gICAgXSxcblxuICAgIC8vIExlZ2VuZHJlLUdhdXNzIHdlaWdodHMgd2l0aCBuPTI0ICh3X2kgdmFsdWVzLCBkZWZpbmVkIGJ5IGEgZnVuY3Rpb24gbGlua2VkIHRvIGluIHRoZSBCZXppZXIgcHJpbWVyIGFydGljbGUpXG4gICAgQ3ZhbHVlczogW1xuICAgICAgMC4xMjc5MzgxOTUzNDY3NTIxNTY5NzQwNTYxNjUyMjQ2OTUzNzE4NTE3LFxuICAgICAgMC4xMjc5MzgxOTUzNDY3NTIxNTY5NzQwNTYxNjUyMjQ2OTUzNzE4NTE3LFxuICAgICAgMC4xMjU4Mzc0NTYzNDY4MjgyOTYxMjEzNzUzODI1MTExODM2ODg3MjY0LFxuICAgICAgMC4xMjU4Mzc0NTYzNDY4MjgyOTYxMjEzNzUzODI1MTExODM2ODg3MjY0LFxuICAgICAgMC4xMjE2NzA0NzI5Mjc4MDMzOTEyMDQ0NjMxNTM0NzYyNjI0MjU2MDcwLFxuICAgICAgMC4xMjE2NzA0NzI5Mjc4MDMzOTEyMDQ0NjMxNTM0NzYyNjI0MjU2MDcwLFxuICAgICAgMC4xMTU1MDU2NjgwNTM3MjU2MDEzNTMzNDQ0ODM5MDY3ODM1NTk4NjIyLFxuICAgICAgMC4xMTU1MDU2NjgwNTM3MjU2MDEzNTMzNDQ0ODM5MDY3ODM1NTk4NjIyLFxuICAgICAgMC4xMDc0NDQyNzAxMTU5NjU2MzQ3ODI1NzczNDI0NDY2MDYyMjI3OTQ2LFxuICAgICAgMC4xMDc0NDQyNzAxMTU5NjU2MzQ3ODI1NzczNDI0NDY2MDYyMjI3OTQ2LFxuICAgICAgMC4wOTc2MTg2NTIxMDQxMTM4ODgyNjk4ODA2NjQ0NjQyNDcxNTQ0Mjc5LFxuICAgICAgMC4wOTc2MTg2NTIxMDQxMTM4ODgyNjk4ODA2NjQ0NjQyNDcxNTQ0Mjc5LFxuICAgICAgMC4wODYxOTAxNjE1MzE5NTMyNzU5MTcxODUyMDI5ODM3NDI2NjcxODUwLFxuICAgICAgMC4wODYxOTAxNjE1MzE5NTMyNzU5MTcxODUyMDI5ODM3NDI2NjcxODUwLFxuICAgICAgMC4wNzMzNDY0ODE0MTEwODAzMDU3MzQwMzM2MTUyNTMxMTY1MTgxMTkzLFxuICAgICAgMC4wNzMzNDY0ODE0MTEwODAzMDU3MzQwMzM2MTUyNTMxMTY1MTgxMTkzLFxuICAgICAgMC4wNTkyOTg1ODQ5MTU0MzY3ODA3NDYzNjc3NTg1MDAxMDg1ODQ1NDEyLFxuICAgICAgMC4wNTkyOTg1ODQ5MTU0MzY3ODA3NDYzNjc3NTg1MDAxMDg1ODQ1NDEyLFxuICAgICAgMC4wNDQyNzc0Mzg4MTc0MTk4MDYxNjg2MDI3NDgyMTEzMzgyMjg4NTkzLFxuICAgICAgMC4wNDQyNzc0Mzg4MTc0MTk4MDYxNjg2MDI3NDgyMTEzMzgyMjg4NTkzLFxuICAgICAgMC4wMjg1MzEzODg2Mjg5MzM2NjMxODEzMDc4MTU5NTE4NzgyODY0NDkxLFxuICAgICAgMC4wMjg1MzEzODg2Mjg5MzM2NjMxODEzMDc4MTU5NTE4NzgyODY0NDkxLFxuICAgICAgMC4wMTIzNDEyMjk3OTk5ODcxOTk1NDY4MDU2NjcwNzAwMzcyOTE1NzU5LFxuICAgICAgMC4wMTIzNDEyMjk3OTk5ODcxOTk1NDY4MDU2NjcwNzAwMzcyOTE1NzU5XG4gICAgXSxcblxuICAgIGFyY2ZuOiBmdW5jdGlvbih0LCBkZXJpdmF0aXZlRm4pIHtcbiAgICAgIHZhciBkID0gZGVyaXZhdGl2ZUZuKHQpO1xuICAgICAgdmFyIGwgPSBkLngqZC54ICsgZC55KmQueTtcbiAgICAgIGlmKHR5cGVvZiBkLnogIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgbCArPSBkLnoqZC56O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNxcnQobCk7XG4gICAgfSxcblxuICAgIGJldHdlZW46IGZ1bmN0aW9uKHYsIG0sIE0pIHtcbiAgICAgIHJldHVybiAobSA8PSB2ICYmIHYgPD0gTSkgfHwgdXRpbHMuYXBwcm94aW1hdGVseSh2LCBtKSB8fCB1dGlscy5hcHByb3hpbWF0ZWx5KHYsIE0pO1xuICAgIH0sXG5cbiAgICBhcHByb3hpbWF0ZWx5OiBmdW5jdGlvbihhLGIscHJlY2lzaW9uKSB7XG4gICAgICByZXR1cm4gYWJzKGEtYikgPD0gKHByZWNpc2lvbiB8fCBlcHNpbG9uKTtcbiAgICB9LFxuXG4gICAgbGVuZ3RoOiBmdW5jdGlvbihkZXJpdmF0aXZlRm4pIHtcbiAgICAgIHZhciB6PTAuNSxzdW09MCxsZW49dXRpbHMuVHZhbHVlcy5sZW5ndGgsaSx0O1xuICAgICAgZm9yKGk9MDsgaTxsZW47IGkrKykge1xuICAgICAgICB0ID0geiAqIHV0aWxzLlR2YWx1ZXNbaV0gKyB6O1xuICAgICAgICBzdW0gKz0gdXRpbHMuQ3ZhbHVlc1tpXSAqIHV0aWxzLmFyY2ZuKHQsZGVyaXZhdGl2ZUZuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB6ICogc3VtO1xuICAgIH0sXG5cbiAgICBtYXA6IGZ1bmN0aW9uKHYsIGRzLGRlLCB0cyx0ZSkge1xuICAgICAgdmFyIGQxID0gZGUtZHMsIGQyID0gdGUtdHMsIHYyID0gIHYtZHMsIHIgPSB2Mi9kMTtcbiAgICAgIHJldHVybiB0cyArIGQyKnI7XG4gICAgfSxcblxuICAgIGxlcnA6IGZ1bmN0aW9uKHIsIHYxLCB2Mikge1xuICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgeDogdjEueCArIHIqKHYyLngtdjEueCksXG4gICAgICAgIHk6IHYxLnkgKyByKih2Mi55LXYxLnkpXG4gICAgICB9O1xuICAgICAgaWYoISF2MS56ICYmICEhdjIueikge1xuICAgICAgICByZXQueiA9ICB2MS56ICsgcioodjIuei12MS56KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIHBvaW50VG9TdHJpbmc6IGZ1bmN0aW9uKHApIHtcbiAgICAgIHZhciBzID0gcC54K1wiL1wiK3AueTtcbiAgICAgIGlmKHR5cGVvZiBwLnogIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcyArPSBcIi9cIitwLno7XG4gICAgICB9XG4gICAgICByZXR1cm4gcztcbiAgICB9LFxuXG4gICAgcG9pbnRzVG9TdHJpbmc6IGZ1bmN0aW9uKHBvaW50cykge1xuICAgICAgcmV0dXJuIFwiW1wiICsgcG9pbnRzLm1hcCh1dGlscy5wb2ludFRvU3RyaW5nKS5qb2luKFwiLCBcIikgKyBcIl1cIjtcbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgICB9LFxuXG4gICAgYW5nbGU6IGZ1bmN0aW9uKG8sdjEsdjIpIHtcbiAgICAgIHZhciBkeDEgPSB2MS54IC0gby54LFxuICAgICAgICAgIGR5MSA9IHYxLnkgLSBvLnksXG4gICAgICAgICAgZHgyID0gdjIueCAtIG8ueCxcbiAgICAgICAgICBkeTIgPSB2Mi55IC0gby55LFxuICAgICAgICAgIGNyb3NzID0gZHgxKmR5MiAtIGR5MSpkeDIsXG4gICAgICAgICAgZG90ID0gZHgxKmR4MiArIGR5MSpkeTI7XG4gICAgICByZXR1cm4gYXRhbjIoY3Jvc3MsIGRvdCk7XG4gICAgfSxcblxuICAgIC8vIHJvdW5kIGFzIHN0cmluZywgdG8gYXZvaWQgcm91bmRpbmcgZXJyb3JzXG4gICAgcm91bmQ6IGZ1bmN0aW9uKHYsIGQpIHtcbiAgICAgIHZhciBzID0gJycgKyB2O1xuICAgICAgdmFyIHBvcyA9IHMuaW5kZXhPZihcIi5cIik7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChzLnN1YnN0cmluZygwLHBvcysxK2QpKTtcbiAgICB9LFxuXG4gICAgZGlzdDogZnVuY3Rpb24ocDEsIHAyKSB7XG4gICAgICB2YXIgZHggPSBwMS54IC0gcDIueCxcbiAgICAgICAgICBkeSA9IHAxLnkgLSBwMi55O1xuICAgICAgcmV0dXJuIHNxcnQoZHgqZHgrZHkqZHkpO1xuICAgIH0sXG5cbiAgICBjbG9zZXN0OiBmdW5jdGlvbihMVVQsIHBvaW50KSB7XG4gICAgICB2YXIgbWRpc3QgPSBwb3coMiw2MyksIG1wb3MsIGQ7XG4gICAgICBMVVQuZm9yRWFjaChmdW5jdGlvbihwLCBpZHgpIHtcbiAgICAgICAgZCA9IHV0aWxzLmRpc3QocG9pbnQsIHApO1xuICAgICAgICBpZiAoZDxtZGlzdCkge1xuICAgICAgICAgIG1kaXN0ID0gZDtcbiAgICAgICAgICBtcG9zID0gaWR4O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7IG1kaXN0Om1kaXN0LCBtcG9zOm1wb3MgfTtcbiAgICB9LFxuXG4gICAgYWJjcmF0aW86IGZ1bmN0aW9uKHQsIG4pIHtcbiAgICAgIC8vIHNlZSByYXRpbyh0KSBub3RlIG9uIGh0dHA6Ly9wb21heC5naXRodWIuaW8vYmV6aWVyaW5mby8jYWJjXG4gICAgICBpZiAobiE9PTIgJiYgbiE9PTMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHQgPSAwLjU7XG4gICAgICB9IGVsc2UgaWYgKHQ9PT0wIHx8IHQ9PT0xKSB7XG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfVxuICAgICAgdmFyIGJvdHRvbSA9IHBvdyh0LG4pICsgcG93KDEtdCxuKSwgdG9wID0gYm90dG9tIC0gMTtcbiAgICAgIHJldHVybiBhYnModG9wL2JvdHRvbSk7XG4gICAgfSxcblxuICAgIHByb2plY3Rpb25yYXRpbzogZnVuY3Rpb24odCwgbikge1xuICAgICAgLy8gc2VlIHUodCkgbm90ZSBvbiBodHRwOi8vcG9tYXguZ2l0aHViLmlvL2JlemllcmluZm8vI2FiY1xuICAgICAgaWYgKG4hPT0yICYmIG4hPT0zKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0ID0gMC41O1xuICAgICAgfSBlbHNlIGlmICh0PT09MCB8fCB0PT09MSkge1xuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH1cbiAgICAgIHZhciB0b3AgPSBwb3coMS10LCBuKSwgYm90dG9tID0gcG93KHQsbikgKyB0b3A7XG4gICAgICByZXR1cm4gdG9wL2JvdHRvbTtcbiAgICB9LFxuXG4gICAgbGxpODogZnVuY3Rpb24oeDEseTEseDIseTIseDMseTMseDQseTQpIHtcbiAgICAgIHZhciBueD0oeDEqeTIteTEqeDIpKih4My14NCktKHgxLXgyKSooeDMqeTQteTMqeDQpLFxuICAgICAgICAgIG55PSh4MSp5Mi15MSp4MikqKHkzLXk0KS0oeTEteTIpKih4Myp5NC15Myp4NCksXG4gICAgICAgICAgZD0oeDEteDIpKih5My15NCktKHkxLXkyKSooeDMteDQpO1xuICAgICAgaWYoZD09MCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgIHJldHVybiB7IHg6IG54L2QsIHk6IG55L2QgfTtcbiAgICB9LFxuXG4gICAgbGxpNDogZnVuY3Rpb24ocDEscDIscDMscDQpIHtcbiAgICAgIHZhciB4MSA9IHAxLngsIHkxID0gcDEueSxcbiAgICAgICAgICB4MiA9IHAyLngsIHkyID0gcDIueSxcbiAgICAgICAgICB4MyA9IHAzLngsIHkzID0gcDMueSxcbiAgICAgICAgICB4NCA9IHA0LngsIHk0ID0gcDQueTtcbiAgICAgIHJldHVybiB1dGlscy5sbGk4KHgxLHkxLHgyLHkyLHgzLHkzLHg0LHk0KTtcbiAgICB9LFxuXG4gICAgbGxpOiBmdW5jdGlvbih2MSwgdjIpIHtcbiAgICAgIHJldHVybiB1dGlscy5sbGk0KHYxLHYxLmMsdjIsdjIuYyk7XG4gICAgfSxcblxuICAgIG1ha2VsaW5lOiBmdW5jdGlvbihwMSxwMikge1xuICAgICAgdmFyIEJlemllciA9IHJlcXVpcmUoJy4vYmV6aWVyJyk7XG4gICAgICB2YXIgeDEgPSBwMS54LCB5MSA9IHAxLnksIHgyID0gcDIueCwgeTIgPSBwMi55LCBkeCA9ICh4Mi14MSkvMywgZHkgPSAoeTIteTEpLzM7XG4gICAgICByZXR1cm4gbmV3IEJlemllcih4MSwgeTEsIHgxK2R4LCB5MStkeSwgeDErMipkeCwgeTErMipkeSwgeDIsIHkyKTtcbiAgICB9LFxuXG4gICAgZmluZGJib3g6IGZ1bmN0aW9uKHNlY3Rpb25zKSB7XG4gICAgICB2YXIgbXg9bk1heCxteT1uTWF4LE1YPW5NaW4sTVk9bk1pbjtcbiAgICAgIHNlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgICAgICB2YXIgYmJveCA9IHMuYmJveCgpO1xuICAgICAgICBpZihteCA+IGJib3gueC5taW4pIG14ID0gYmJveC54Lm1pbjtcbiAgICAgICAgaWYobXkgPiBiYm94LnkubWluKSBteSA9IGJib3gueS5taW47XG4gICAgICAgIGlmKE1YIDwgYmJveC54Lm1heCkgTVggPSBiYm94LngubWF4O1xuICAgICAgICBpZihNWSA8IGJib3gueS5tYXgpIE1ZID0gYmJveC55Lm1heDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeyBtaW46IG14LCBtaWQ6KG14K01YKS8yLCBtYXg6IE1YLCBzaXplOk1YLW14IH0sXG4gICAgICAgIHk6IHsgbWluOiBteSwgbWlkOihteStNWSkvMiwgbWF4OiBNWSwgc2l6ZTpNWS1teSB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNoYXBlaW50ZXJzZWN0aW9uczogZnVuY3Rpb24oczEsIGJib3gxLCBzMiwgYmJveDIsIGN1cnZlSW50ZXJzZWN0aW9uVGhyZXNob2xkKSB7XG4gICAgICBpZighdXRpbHMuYmJveG92ZXJsYXAoYmJveDEsIGJib3gyKSkgcmV0dXJuIFtdO1xuICAgICAgdmFyIGludGVyc2VjdGlvbnMgPSBbXTtcbiAgICAgIHZhciBhMSA9IFtzMS5zdGFydGNhcCwgczEuZm9yd2FyZCwgczEuYmFjaywgczEuZW5kY2FwXTtcbiAgICAgIHZhciBhMiA9IFtzMi5zdGFydGNhcCwgczIuZm9yd2FyZCwgczIuYmFjaywgczIuZW5kY2FwXTtcbiAgICAgIGExLmZvckVhY2goZnVuY3Rpb24obDEpIHtcbiAgICAgICAgaWYobDEudmlydHVhbCkgcmV0dXJuO1xuICAgICAgICBhMi5mb3JFYWNoKGZ1bmN0aW9uKGwyKSB7XG4gICAgICAgICAgaWYobDIudmlydHVhbCkgcmV0dXJuO1xuICAgICAgICAgIHZhciBpc3MgPSBsMS5pbnRlcnNlY3RzKGwyLCBjdXJ2ZUludGVyc2VjdGlvblRocmVzaG9sZCk7XG4gICAgICAgICAgaWYoaXNzLmxlbmd0aD4wKSB7XG4gICAgICAgICAgICBpc3MuYzEgPSBsMTtcbiAgICAgICAgICAgIGlzcy5jMiA9IGwyO1xuICAgICAgICAgICAgaXNzLnMxID0gczE7XG4gICAgICAgICAgICBpc3MuczIgPSBzMjtcbiAgICAgICAgICAgIGludGVyc2VjdGlvbnMucHVzaChpc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBpbnRlcnNlY3Rpb25zO1xuICAgIH0sXG5cbiAgICBtYWtlc2hhcGU6IGZ1bmN0aW9uKGZvcndhcmQsIGJhY2ssIGN1cnZlSW50ZXJzZWN0aW9uVGhyZXNob2xkKSB7XG4gICAgICB2YXIgYnBsID0gYmFjay5wb2ludHMubGVuZ3RoO1xuICAgICAgdmFyIGZwbCA9IGZvcndhcmQucG9pbnRzLmxlbmd0aDtcbiAgICAgIHZhciBzdGFydCAgPSB1dGlscy5tYWtlbGluZShiYWNrLnBvaW50c1ticGwtMV0sIGZvcndhcmQucG9pbnRzWzBdKTtcbiAgICAgIHZhciBlbmQgICAgPSB1dGlscy5tYWtlbGluZShmb3J3YXJkLnBvaW50c1tmcGwtMV0sIGJhY2sucG9pbnRzWzBdKTtcbiAgICAgIHZhciBzaGFwZSAgPSB7XG4gICAgICAgIHN0YXJ0Y2FwOiBzdGFydCxcbiAgICAgICAgZm9yd2FyZDogZm9yd2FyZCxcbiAgICAgICAgYmFjazogYmFjayxcbiAgICAgICAgZW5kY2FwOiBlbmQsXG4gICAgICAgIGJib3g6IHV0aWxzLmZpbmRiYm94KFtzdGFydCwgZm9yd2FyZCwgYmFjaywgZW5kXSlcbiAgICAgIH07XG4gICAgICB2YXIgc2VsZiA9IHV0aWxzO1xuICAgICAgc2hhcGUuaW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uKHMyKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnNoYXBlaW50ZXJzZWN0aW9ucyhzaGFwZSxzaGFwZS5iYm94LHMyLHMyLmJib3gsIGN1cnZlSW50ZXJzZWN0aW9uVGhyZXNob2xkKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gc2hhcGU7XG4gICAgfSxcblxuICAgIGdldG1pbm1heDogZnVuY3Rpb24oY3VydmUsIGQsIGxpc3QpIHtcbiAgICAgIGlmKCFsaXN0KSByZXR1cm4geyBtaW46MCwgbWF4OjAgfTtcbiAgICAgIHZhciBtaW49bk1heCwgbWF4PW5NaW4sdCxjO1xuICAgICAgaWYobGlzdC5pbmRleE9mKDApPT09LTEpIHsgbGlzdCA9IFswXS5jb25jYXQobGlzdCk7IH1cbiAgICAgIGlmKGxpc3QuaW5kZXhPZigxKT09PS0xKSB7IGxpc3QucHVzaCgxKTsgfVxuICAgICAgZm9yKHZhciBpPTAsbGVuPWxpc3QubGVuZ3RoOyBpPGxlbjsgaSsrKSB7XG4gICAgICAgIHQgPSBsaXN0W2ldO1xuICAgICAgICBjID0gY3VydmUuZ2V0KHQpO1xuICAgICAgICBpZihjW2RdIDwgbWluKSB7IG1pbiA9IGNbZF07IH1cbiAgICAgICAgaWYoY1tkXSA+IG1heCkgeyBtYXggPSBjW2RdOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyBtaW46bWluLCBtaWQ6KG1pbittYXgpLzIsIG1heDptYXgsIHNpemU6bWF4LW1pbiB9O1xuICAgIH0sXG5cbiAgICBhbGlnbjogZnVuY3Rpb24ocG9pbnRzLCBsaW5lKSB7XG4gICAgICB2YXIgdHggPSBsaW5lLnAxLngsXG4gICAgICAgICAgdHkgPSBsaW5lLnAxLnksXG4gICAgICAgICAgYSA9IC1hdGFuMihsaW5lLnAyLnktdHksIGxpbmUucDIueC10eCksXG4gICAgICAgICAgZCA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHg6ICh2LngtdHgpKmNvcyhhKSAtICh2LnktdHkpKnNpbihhKSxcbiAgICAgICAgICAgICAgeTogKHYueC10eCkqc2luKGEpICsgKHYueS10eSkqY29zKGEpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICByZXR1cm4gcG9pbnRzLm1hcChkKTtcbiAgICB9LFxuXG4gICAgcm9vdHM6IGZ1bmN0aW9uKHBvaW50cywgbGluZSkge1xuICAgICAgbGluZSA9IGxpbmUgfHwge3AxOnt4OjAseTowfSxwMjp7eDoxLHk6MH19O1xuICAgICAgdmFyIG9yZGVyID0gcG9pbnRzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgcCA9IHV0aWxzLmFsaWduKHBvaW50cywgbGluZSk7XG4gICAgICB2YXIgcmVkdWNlID0gZnVuY3Rpb24odCkgeyByZXR1cm4gMDw9dCAmJiB0IDw9MTsgfTtcblxuICAgICAgaWYgKG9yZGVyID09PSAyKSB7XG4gICAgICAgIHZhciBhID0gcFswXS55LFxuICAgICAgICAgICAgYiA9IHBbMV0ueSxcbiAgICAgICAgICAgIGMgPSBwWzJdLnksXG4gICAgICAgICAgICBkID0gYSAtIDIqYiArIGM7XG4gICAgICAgIGlmKGQhPT0wKSB7XG4gICAgICAgICAgdmFyIG0xID0gLXNxcnQoYipiLWEqYyksXG4gICAgICAgICAgICAgIG0yID0gLWErYixcbiAgICAgICAgICAgICAgdjEgPSAtKCBtMSttMikvZCxcbiAgICAgICAgICAgICAgdjIgPSAtKC1tMSttMikvZDtcbiAgICAgICAgICByZXR1cm4gW3YxLCB2Ml0uZmlsdGVyKHJlZHVjZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihiIT09YyAmJiBkPT09MCkge1xuICAgICAgICAgIHJldHVybiBbICgyKmItYykvMiooYi1jKSBdLmZpbHRlcihyZWR1Y2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgLy8gc2VlIGh0dHA6Ly93d3cudHJhbnM0bWluZC5jb20vcGVyc29uYWxfZGV2ZWxvcG1lbnQvbWF0aGVtYXRpY3MvcG9seW5vbWlhbHMvY3ViaWNBbGdlYnJhLmh0bVxuICAgICAgdmFyIHBhID0gcFswXS55LFxuICAgICAgICAgIHBiID0gcFsxXS55LFxuICAgICAgICAgIHBjID0gcFsyXS55LFxuICAgICAgICAgIHBkID0gcFszXS55LFxuICAgICAgICAgIGQgPSAoLXBhICsgMypwYiAtIDMqcGMgKyBwZCksXG4gICAgICAgICAgYSA9ICgzKnBhIC0gNipwYiArIDMqcGMpIC8gZCxcbiAgICAgICAgICBiID0gKC0zKnBhICsgMypwYikgLyBkLFxuICAgICAgICAgIGMgPSBwYSAvIGQsXG4gICAgICAgICAgcCA9ICgzKmIgLSBhKmEpLzMsXG4gICAgICAgICAgcDMgPSBwLzMsXG4gICAgICAgICAgcSA9ICgyKmEqYSphIC0gOSphKmIgKyAyNypjKS8yNyxcbiAgICAgICAgICBxMiA9IHEvMixcbiAgICAgICAgICBkaXNjcmltaW5hbnQgPSBxMipxMiArIHAzKnAzKnAzLFxuICAgICAgICAgIHUxLHYxLHgxLHgyLHgzO1xuICAgICAgIGlmIChkaXNjcmltaW5hbnQgPCAwKSB7XG4gICAgICAgIHZhciBtcDMgPSAtcC8zLFxuICAgICAgICAgICAgbXAzMyA9IG1wMyptcDMqbXAzLFxuICAgICAgICAgICAgciA9IHNxcnQoIG1wMzMgKSxcbiAgICAgICAgICAgIHQgPSAtcS8oMipyKSxcbiAgICAgICAgICAgIGNvc3BoaSA9IHQ8LTEgPyAtMSA6IHQ+MSA/IDEgOiB0LFxuICAgICAgICAgICAgcGhpID0gYWNvcyhjb3NwaGkpLFxuICAgICAgICAgICAgY3J0ciA9IGNydChyKSxcbiAgICAgICAgICAgIHQxID0gMipjcnRyO1xuICAgICAgICB4MSA9IHQxICogY29zKHBoaS8zKSAtIGEvMztcbiAgICAgICAgeDIgPSB0MSAqIGNvcygocGhpK3RhdSkvMykgLSBhLzM7XG4gICAgICAgIHgzID0gdDEgKiBjb3MoKHBoaSsyKnRhdSkvMykgLSBhLzM7XG4gICAgICAgIHJldHVybiBbeDEsIHgyLCB4M10uZmlsdGVyKHJlZHVjZSk7XG4gICAgICB9IGVsc2UgaWYoZGlzY3JpbWluYW50ID09PSAwKSB7XG4gICAgICAgIHUxID0gcTIgPCAwID8gY3J0KC1xMikgOiAtY3J0KHEyKTtcbiAgICAgICAgeDEgPSAyKnUxLWEvMztcbiAgICAgICAgeDIgPSAtdTEgLSBhLzM7XG4gICAgICAgIHJldHVybiBbeDEseDJdLmZpbHRlcihyZWR1Y2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNkID0gc3FydChkaXNjcmltaW5hbnQpO1xuICAgICAgICB1MSA9IGNydCgtcTIrc2QpO1xuICAgICAgICB2MSA9IGNydChxMitzZCk7XG4gICAgICAgIHJldHVybiBbdTEtdjEtYS8zXS5maWx0ZXIocmVkdWNlKTs7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGRyb290czogZnVuY3Rpb24ocCkge1xuICAgICAgLy8gcXVhZHJhdGljIHJvb3RzIGFyZSBlYXN5XG4gICAgICBpZihwLmxlbmd0aCA9PT0gMykge1xuICAgICAgICB2YXIgYSA9IHBbMF0sXG4gICAgICAgICAgICBiID0gcFsxXSxcbiAgICAgICAgICAgIGMgPSBwWzJdLFxuICAgICAgICAgICAgZCA9IGEgLSAyKmIgKyBjO1xuICAgICAgICBpZihkIT09MCkge1xuICAgICAgICAgIHZhciBtMSA9IC1zcXJ0KGIqYi1hKmMpLFxuICAgICAgICAgICAgICBtMiA9IC1hK2IsXG4gICAgICAgICAgICAgIHYxID0gLSggbTErbTIpL2QsXG4gICAgICAgICAgICAgIHYyID0gLSgtbTErbTIpL2Q7XG4gICAgICAgICAgcmV0dXJuIFt2MSwgdjJdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoYiE9PWMgJiYgZD09PTApIHtcbiAgICAgICAgICByZXR1cm4gWygyKmItYykvKDIqKGItYykpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIC8vIGxpbmVhciByb290cyBhcmUgZXZlbiBlYXNpZXJcbiAgICAgIGlmKHAubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHZhciBhID0gcFswXSwgYiA9IHBbMV07XG4gICAgICAgIGlmKGEhPT1iKSB7XG4gICAgICAgICAgcmV0dXJuIFthLyhhLWIpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfSxcblxuICAgIGluZmxlY3Rpb25zOiBmdW5jdGlvbihwb2ludHMpIHtcbiAgICAgIGlmIChwb2ludHMubGVuZ3RoPDQpIHJldHVybiBbXTtcblxuICAgICAgLy8gRklYTUU6IFRPRE86IGFkZCBpbiBpbmZsZWN0aW9uIGFic3RyYWN0aW9uIGZvciBxdWFydGljKyBjdXJ2ZXM/XG5cbiAgICAgIHZhciBwID0gdXRpbHMuYWxpZ24ocG9pbnRzLCB7IHAxOiBwb2ludHNbMF0sIHAyOiBwb2ludHMuc2xpY2UoLTEpWzBdIH0pLFxuICAgICAgICAgIGEgPSBwWzJdLnggKiBwWzFdLnksXG4gICAgICAgICAgYiA9IHBbM10ueCAqIHBbMV0ueSxcbiAgICAgICAgICBjID0gcFsxXS54ICogcFsyXS55LFxuICAgICAgICAgIGQgPSBwWzNdLnggKiBwWzJdLnksXG4gICAgICAgICAgdjEgPSAxOCAqICgtMyphICsgMipiICsgMypjIC0gZCksXG4gICAgICAgICAgdjIgPSAxOCAqICgzKmEgLSBiIC0gMypjKSxcbiAgICAgICAgICB2MyA9IDE4ICogKGMgLSBhKTtcblxuICAgICAgaWYgKHV0aWxzLmFwcHJveGltYXRlbHkodjEsMCkpe1xuICAgICAgICBpZighdXRpbHMuYXBwcm94aW1hdGVseSh2MiwwKSl7XG4gICAgICAgICAgdmFyIHQgPSAtdjMvdjI7XG4gICAgICAgICAgaWYgKDAgPD0gdCAmJiB0IDw9IDEpXG4gICAgICAgICAgICAgcmV0dXJuIFt0XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIHZhciB0cm0gPSB2Mip2MiAtIDQqdjEqdjMsXG4gICAgICAgICAgc3EgPSBNYXRoLnNxcnQodHJtKSxcbiAgICAgICAgICBkID0gMiAqIHYxO1xuXG4gICAgICBpZiAodXRpbHMuYXBwcm94aW1hdGVseShkLDApKSByZXR1cm4gW107XG5cbiAgICAgIHJldHVybiBbKHNxLXYyKS9kLCAtKHYyK3NxKS9kXS5maWx0ZXIoZnVuY3Rpb24ocikge1xuICAgICAgICByZXR1cm4gKDAgPD0gciAmJiByIDw9IDEpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGJib3hvdmVybGFwOiBmdW5jdGlvbihiMSxiMikge1xuICAgICAgdmFyIGRpbXM9Wyd4JywneSddLGxlbj1kaW1zLmxlbmd0aCxpLGRpbSxsLHQsZFxuICAgICAgZm9yKGk9MDsgaTxsZW47IGkrKykge1xuICAgICAgICBkaW0gPSBkaW1zW2ldO1xuICAgICAgICBsID0gYjFbZGltXS5taWQ7XG4gICAgICAgIHQgPSBiMltkaW1dLm1pZDtcbiAgICAgICAgZCA9IChiMVtkaW1dLnNpemUgKyBiMltkaW1dLnNpemUpLzI7XG4gICAgICAgIGlmKGFicyhsLXQpID49IGQpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICBleHBhbmRib3g6IGZ1bmN0aW9uKGJib3gsIF9iYm94KSB7XG4gICAgICBpZihfYmJveC54Lm1pbiA8IGJib3gueC5taW4pIHsgYmJveC54Lm1pbiA9IF9iYm94LngubWluOyB9XG4gICAgICBpZihfYmJveC55Lm1pbiA8IGJib3gueS5taW4pIHsgYmJveC55Lm1pbiA9IF9iYm94LnkubWluOyB9XG4gICAgICBpZihfYmJveC56ICYmIF9iYm94LnoubWluIDwgYmJveC56Lm1pbikgeyBiYm94LnoubWluID0gX2Jib3guei5taW47IH1cbiAgICAgIGlmKF9iYm94LngubWF4ID4gYmJveC54Lm1heCkgeyBiYm94LngubWF4ID0gX2Jib3gueC5tYXg7IH1cbiAgICAgIGlmKF9iYm94LnkubWF4ID4gYmJveC55Lm1heCkgeyBiYm94LnkubWF4ID0gX2Jib3gueS5tYXg7IH1cbiAgICAgIGlmKF9iYm94LnogJiYgX2Jib3guei5tYXggPiBiYm94LnoubWF4KSB7IGJib3guei5tYXggPSBfYmJveC56Lm1heDsgfVxuICAgICAgYmJveC54Lm1pZCA9IChiYm94LngubWluICsgYmJveC54Lm1heCkvMjtcbiAgICAgIGJib3gueS5taWQgPSAoYmJveC55Lm1pbiArIGJib3gueS5tYXgpLzI7XG4gICAgICBpZihiYm94LnopIHsgYmJveC56Lm1pZCA9IChiYm94LnoubWluICsgYmJveC56Lm1heCkvMjsgfVxuICAgICAgYmJveC54LnNpemUgPSBiYm94LngubWF4IC0gYmJveC54Lm1pbjtcbiAgICAgIGJib3gueS5zaXplID0gYmJveC55Lm1heCAtIGJib3gueS5taW47XG4gICAgICBpZihiYm94LnopIHsgYmJveC56LnNpemUgPSBiYm94LnoubWF4IC0gYmJveC56Lm1pbjsgfVxuICAgIH0sXG5cbiAgICBwYWlyaXRlcmF0aW9uOiBmdW5jdGlvbihjMSwgYzIsIGN1cnZlSW50ZXJzZWN0aW9uVGhyZXNob2xkKSB7XG4gICAgICB2YXIgYzFiID0gYzEuYmJveCgpLFxuICAgICAgICAgIGMyYiA9IGMyLmJib3goKSxcbiAgICAgICAgICByID0gMTAwMDAwLFxuICAgICAgICAgIHRocmVzaG9sZCA9IGN1cnZlSW50ZXJzZWN0aW9uVGhyZXNob2xkIHx8IDAuNTtcbiAgICAgIGlmKGMxYi54LnNpemUgKyBjMWIueS5zaXplIDwgdGhyZXNob2xkICYmIGMyYi54LnNpemUgKyBjMmIueS5zaXplIDwgdGhyZXNob2xkKSB7XG4gICAgICAgIHJldHVybiBbICgociAqIChjMS5fdDErYzEuX3QyKS8yKXwwKS9yICsgXCIvXCIgKyAoKHIgKiAoYzIuX3QxK2MyLl90MikvMil8MCkvciBdO1xuICAgICAgfVxuICAgICAgdmFyIGNjMSA9IGMxLnNwbGl0KDAuNSksXG4gICAgICAgICAgY2MyID0gYzIuc3BsaXQoMC41KSxcbiAgICAgICAgICBwYWlycyA9IFtcbiAgICAgICAgICAgIHtsZWZ0OiBjYzEubGVmdCwgcmlnaHQ6IGNjMi5sZWZ0IH0sXG4gICAgICAgICAgICB7bGVmdDogY2MxLmxlZnQsIHJpZ2h0OiBjYzIucmlnaHQgfSxcbiAgICAgICAgICAgIHtsZWZ0OiBjYzEucmlnaHQsIHJpZ2h0OiBjYzIucmlnaHQgfSxcbiAgICAgICAgICAgIHtsZWZ0OiBjYzEucmlnaHQsIHJpZ2h0OiBjYzIubGVmdCB9XTtcbiAgICAgIHBhaXJzID0gcGFpcnMuZmlsdGVyKGZ1bmN0aW9uKHBhaXIpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzLmJib3hvdmVybGFwKHBhaXIubGVmdC5iYm94KCkscGFpci5yaWdodC5iYm94KCkpO1xuICAgICAgfSk7XG4gICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgaWYocGFpcnMubGVuZ3RoID09PSAwKSByZXR1cm4gcmVzdWx0cztcbiAgICAgIHBhaXJzLmZvckVhY2goZnVuY3Rpb24ocGFpcikge1xuICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5jb25jYXQoXG4gICAgICAgICAgdXRpbHMucGFpcml0ZXJhdGlvbihwYWlyLmxlZnQsIHBhaXIucmlnaHQsIHRocmVzaG9sZClcbiAgICAgICAgKTtcbiAgICAgIH0pXG4gICAgICByZXN1bHRzID0gcmVzdWx0cy5maWx0ZXIoZnVuY3Rpb24odixpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHRzLmluZGV4T2YodikgPT09IGk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0sXG5cbiAgICBnZXRjY2VudGVyOiBmdW5jdGlvbihwMSxwMixwMykge1xuICAgICAgdmFyIGR4MSA9IChwMi54IC0gcDEueCksXG4gICAgICAgICAgZHkxID0gKHAyLnkgLSBwMS55KSxcbiAgICAgICAgICBkeDIgPSAocDMueCAtIHAyLngpLFxuICAgICAgICAgIGR5MiA9IChwMy55IC0gcDIueSk7XG4gICAgICB2YXIgZHgxcCA9IGR4MSAqIGNvcyhxdWFydCkgLSBkeTEgKiBzaW4ocXVhcnQpLFxuICAgICAgICAgIGR5MXAgPSBkeDEgKiBzaW4ocXVhcnQpICsgZHkxICogY29zKHF1YXJ0KSxcbiAgICAgICAgICBkeDJwID0gZHgyICogY29zKHF1YXJ0KSAtIGR5MiAqIHNpbihxdWFydCksXG4gICAgICAgICAgZHkycCA9IGR4MiAqIHNpbihxdWFydCkgKyBkeTIgKiBjb3MocXVhcnQpO1xuICAgICAgLy8gY2hvcmQgbWlkcG9pbnRzXG4gICAgICB2YXIgbXgxID0gKHAxLnggKyBwMi54KS8yLFxuICAgICAgICAgIG15MSA9IChwMS55ICsgcDIueSkvMixcbiAgICAgICAgICBteDIgPSAocDIueCArIHAzLngpLzIsXG4gICAgICAgICAgbXkyID0gKHAyLnkgKyBwMy55KS8yO1xuICAgICAgLy8gbWlkcG9pbnQgb2Zmc2V0c1xuICAgICAgdmFyIG14MW4gPSBteDEgKyBkeDFwLFxuICAgICAgICAgIG15MW4gPSBteTEgKyBkeTFwLFxuICAgICAgICAgIG14Mm4gPSBteDIgKyBkeDJwLFxuICAgICAgICAgIG15Mm4gPSBteTIgKyBkeTJwO1xuICAgICAgLy8gaW50ZXJzZWN0aW9uIG9mIHRoZXNlIGxpbmVzOlxuICAgICAgdmFyIGFyYyA9IHV0aWxzLmxsaTgobXgxLG15MSxteDFuLG15MW4sIG14MixteTIsbXgybixteTJuKSxcbiAgICAgICAgICByID0gdXRpbHMuZGlzdChhcmMscDEpLFxuICAgICAgICAgIC8vIGFyYyBzdGFydC9lbmQgdmFsdWVzLCBvdmVyIG1pZCBwb2ludDpcbiAgICAgICAgICBzID0gYXRhbjIocDEueSAtIGFyYy55LCBwMS54IC0gYXJjLngpLFxuICAgICAgICAgIG0gPSBhdGFuMihwMi55IC0gYXJjLnksIHAyLnggLSBhcmMueCksXG4gICAgICAgICAgZSA9IGF0YW4yKHAzLnkgLSBhcmMueSwgcDMueCAtIGFyYy54KSxcbiAgICAgICAgICBfO1xuICAgICAgLy8gZGV0ZXJtaW5lIGFyYyBkaXJlY3Rpb24gKGN3L2NjdyBjb3JyZWN0aW9uKVxuICAgICAgaWYgKHM8ZSkge1xuICAgICAgICAvLyBpZiBzPG08ZSwgYXJjKHMsIGUpXG4gICAgICAgIC8vIGlmIG08czxlLCBhcmMoZSwgcyArIHRhdSlcbiAgICAgICAgLy8gaWYgczxlPG0sIGFyYyhlLCBzICsgdGF1KVxuICAgICAgICBpZiAocz5tIHx8IG0+ZSkgeyBzICs9IHRhdTsgfVxuICAgICAgICBpZiAocz5lKSB7IF89ZTsgZT1zOyBzPV87IH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIGU8bTxzLCBhcmMoZSwgcylcbiAgICAgICAgLy8gaWYgbTxlPHMsIGFyYyhzLCBlICsgdGF1KVxuICAgICAgICAvLyBpZiBlPHM8bSwgYXJjKHMsIGUgKyB0YXUpXG4gICAgICAgIGlmIChlPG0gJiYgbTxzKSB7IF89ZTsgZT1zOyBzPV87IH0gZWxzZSB7IGUgKz0gdGF1OyB9XG4gICAgICB9XG4gICAgICAvLyBhc3NpZ24gYW5kIGRvbmUuXG4gICAgICBhcmMucyA9IHM7XG4gICAgICBhcmMuZSA9IGU7XG4gICAgICBhcmMuciA9IHI7XG4gICAgICByZXR1cm4gYXJjO1xuICAgIH1cbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IHV0aWxzO1xufSgpKTtcbiIsIi8vID09Q2xvc3VyZUNvbXBpbGVyPT1cclxuLy8gQG91dHB1dF9maWxlX25hbWUgZml0LWN1cnZlLm1pbi5qc1xyXG4vLyBAY29tcGlsYXRpb25fbGV2ZWwgU0lNUExFX09QVElNSVpBVElPTlNcclxuLy8gPT0vQ2xvc3VyZUNvbXBpbGVyPT1cclxuXHJcbi8qKlxyXG4gKiAgQHByZXNlcnZlICBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mXHJcbiAqICBBbGdvcml0aG0gZm9yIEF1dG9tYXRpY2FsbHkgRml0dGluZyBEaWdpdGl6ZWQgQ3VydmVzXHJcbiAqICBieSBQaGlsaXAgSi4gU2NobmVpZGVyXHJcbiAqICBcIkdyYXBoaWNzIEdlbXNcIiwgQWNhZGVtaWMgUHJlc3MsIDE5OTBcclxuICpcclxuICogIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxyXG4gKlxyXG4gKiAgaHR0cHM6Ly9naXRodWIuY29tL3Nvc3dvdy9maXQtY3VydmVzXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEZpdCBvbmUgb3IgbW9yZSBCZXppZXIgY3VydmVzIHRvIGEgc2V0IG9mIHBvaW50cy5cclxuICpcclxuICogQHBhcmFtIHtBcnJheTxBcnJheTxOdW1iZXI+Pn0gcG9pbnRzIC0gQXJyYXkgb2YgZGlnaXRpemVkIHBvaW50cywgZS5nLiBbWzUsNV0sWzUsNTBdLFsxMTAsMTQwXSxbMjEwLDE2MF0sWzMyMCwxMTBdXVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4RXJyb3IgLSBUb2xlcmFuY2UsIHNxdWFyZWQgZXJyb3IgYmV0d2VlbiBwb2ludHMgYW5kIGZpdHRlZCBjdXJ2ZVxyXG4gKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk8QXJyYXk8TnVtYmVyPj4+fSBBcnJheSBvZiBCZXppZXIgY3VydmVzLCB3aGVyZSBlYWNoIGVsZW1lbnQgaXMgW2ZpcnN0LXBvaW50LCBjb250cm9sLXBvaW50LTEsIGNvbnRyb2wtcG9pbnQtMiwgc2Vjb25kLXBvaW50XSBhbmQgcG9pbnRzIGFyZSBbeCwgeV1cclxuICovXHJcbmZ1bmN0aW9uIGZpdEN1cnZlKHBvaW50cywgbWF4RXJyb3IsIHByb2dyZXNzQ2FsbGJhY2spIHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShwb2ludHMpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpcnN0IGFyZ3VtZW50IHNob3VsZCBiZSBhbiBhcnJheVwiKTtcclxuICAgIH1cclxuICAgIHBvaW50cy5mb3JFYWNoKChwb2ludCkgPT4ge1xyXG4gICAgICAgIGlmKCFBcnJheS5pc0FycmF5KHBvaW50KSB8fCBwb2ludC5sZW5ndGggIT09IDJcclxuICAgICAgICB8fCB0eXBlb2YgcG9pbnRbMF0gIT09ICdudW1iZXInIHx8IHR5cGVvZiBwb2ludFsxXSAhPT0gJ251bWJlcicpe1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkVhY2ggcG9pbnQgc2hvdWxkIGJlIGFuIGFycmF5IG9mIHR3byBudW1iZXJzXCIpXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvLyBSZW1vdmUgZHVwbGljYXRlIHBvaW50c1xyXG4gICAgcG9pbnRzID0gcG9pbnRzLmZpbHRlcigocG9pbnQsIGkpID0+XHJcbiAgICAgICAgaSA9PT0gMCB8fCAhKHBvaW50WzBdID09PSBwb2ludHNbaS0xXVswXSAmJiBwb2ludFsxXSA9PT0gcG9pbnRzW2ktMV1bMV0pXHJcbiAgICApO1xyXG5cclxuICAgIGlmIChwb2ludHMubGVuZ3RoIDwgMikge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBsZW4gPSBwb2ludHMubGVuZ3RoO1xyXG4gICAgY29uc3QgbGVmdFRhbmdlbnQgPSBjcmVhdGVUYW5nZW50KHBvaW50c1sxXSwgcG9pbnRzWzBdKTtcclxuICAgIGNvbnN0IHJpZ2h0VGFuZ2VudCA9IGNyZWF0ZVRhbmdlbnQocG9pbnRzW2xlbiAtIDJdLCBwb2ludHNbbGVuIC0gMV0pO1xyXG5cclxuICAgIHJldHVybiBmaXRDdWJpYyhwb2ludHMsIGxlZnRUYW5nZW50LCByaWdodFRhbmdlbnQsIG1heEVycm9yLCBwcm9ncmVzc0NhbGxiYWNrKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZpdCBhIEJlemllciBjdXJ2ZSB0byBhIChzdWIpc2V0IG9mIGRpZ2l0aXplZCBwb2ludHMuXHJcbiAqIFlvdXIgY29kZSBzaG91bGQgbm90IGNhbGwgdGhpcyBmdW5jdGlvbiBkaXJlY3RseS4gVXNlIHtAbGluayBmaXRDdXJ2ZX0gaW5zdGVhZC5cclxuICpcclxuICogQHBhcmFtIHtBcnJheTxBcnJheTxOdW1iZXI+Pn0gcG9pbnRzIC0gQXJyYXkgb2YgZGlnaXRpemVkIHBvaW50cywgZS5nLiBbWzUsNV0sWzUsNTBdLFsxMTAsMTQwXSxbMjEwLDE2MF0sWzMyMCwxMTBdXVxyXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IGxlZnRUYW5nZW50IC0gVW5pdCB0YW5nZW50IHZlY3RvciBhdCBzdGFydCBwb2ludFxyXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IHJpZ2h0VGFuZ2VudCAtIFVuaXQgdGFuZ2VudCB2ZWN0b3IgYXQgZW5kIHBvaW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBlcnJvciAtIFRvbGVyYW5jZSwgc3F1YXJlZCBlcnJvciBiZXR3ZWVuIHBvaW50cyBhbmQgZml0dGVkIGN1cnZlXHJcbiAqIEByZXR1cm5zIHtBcnJheTxBcnJheTxBcnJheTxOdW1iZXI+Pj59IEFycmF5IG9mIEJlemllciBjdXJ2ZXMsIHdoZXJlIGVhY2ggZWxlbWVudCBpcyBbZmlyc3QtcG9pbnQsIGNvbnRyb2wtcG9pbnQtMSwgY29udHJvbC1wb2ludC0yLCBzZWNvbmQtcG9pbnRdIGFuZCBwb2ludHMgYXJlIFt4LCB5XVxyXG4gKi9cclxuZnVuY3Rpb24gZml0Q3ViaWMocG9pbnRzLCBsZWZ0VGFuZ2VudCwgcmlnaHRUYW5nZW50LCBlcnJvciwgcHJvZ3Jlc3NDYWxsYmFjaykge1xyXG4gICAgY29uc3QgTWF4SXRlcmF0aW9ucyA9IDIwOyAgIC8vTWF4IHRpbWVzIHRvIHRyeSBpdGVyYXRpbmcgKHRvIGZpbmQgYW4gYWNjZXB0YWJsZSBjdXJ2ZSlcclxuXHJcbiAgICB2YXIgYmV6Q3VydmUsICAgICAgICAgICAgICAgLy9Db250cm9sIHBvaW50cyBvZiBmaXR0ZWQgQmV6aWVyIGN1cnZlXHJcbiAgICAgICAgdSwgICAgICAgICAgICAgICAgICAgICAgLy9QYXJhbWV0ZXIgdmFsdWVzIGZvciBwb2ludFxyXG4gICAgICAgIHVQcmltZSwgICAgICAgICAgICAgICAgIC8vSW1wcm92ZWQgcGFyYW1ldGVyIHZhbHVlc1xyXG4gICAgICAgIG1heEVycm9yLCBwcmV2RXJyLCAgICAgIC8vTWF4aW11bSBmaXR0aW5nIGVycm9yXHJcbiAgICAgICAgc3BsaXRQb2ludCwgcHJldlNwbGl0LCAgLy9Qb2ludCB0byBzcGxpdCBwb2ludCBzZXQgYXQgaWYgd2UgbmVlZCBtb3JlIHRoYW4gb25lIGN1cnZlXHJcbiAgICAgICAgY2VudGVyVmVjdG9yLCB0b0NlbnRlclRhbmdlbnQsIGZyb21DZW50ZXJUYW5nZW50LCAgLy9Vbml0IHRhbmdlbnQgdmVjdG9yKHMpIGF0IHNwbGl0UG9pbnRcclxuICAgICAgICBiZXppZXJzLCAgICAgICAgICAgICAgICAvL0FycmF5IG9mIGZpdHRlZCBCZXppZXIgY3VydmVzIGlmIHdlIG5lZWQgbW9yZSB0aGFuIG9uZSBjdXJ2ZVxyXG4gICAgICAgIGRpc3QsIGk7XHJcblxyXG4gICAgLy9jb25zb2xlLmxvZygnZml0Q3ViaWMsICcsIHBvaW50cy5sZW5ndGgpO1xyXG5cclxuICAgIC8vVXNlIGhldXJpc3RpYyBpZiByZWdpb24gb25seSBoYXMgdHdvIHBvaW50cyBpbiBpdFxyXG4gICAgaWYgKHBvaW50cy5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICBkaXN0ID0gbWF0aHMudmVjdG9yTGVuKG1hdGhzLnN1YnRyYWN0KHBvaW50c1swXSwgcG9pbnRzWzFdKSkgLyAzLjA7XHJcbiAgICAgICAgYmV6Q3VydmUgPSBbXHJcbiAgICAgICAgICAgIHBvaW50c1swXSxcclxuICAgICAgICAgICAgbWF0aHMuYWRkQXJyYXlzKHBvaW50c1swXSwgbWF0aHMubXVsSXRlbXMobGVmdFRhbmdlbnQsICBkaXN0KSksXHJcbiAgICAgICAgICAgIG1hdGhzLmFkZEFycmF5cyhwb2ludHNbMV0sIG1hdGhzLm11bEl0ZW1zKHJpZ2h0VGFuZ2VudCwgZGlzdCkpLFxyXG4gICAgICAgICAgICBwb2ludHNbMV1cclxuICAgICAgICBdO1xyXG4gICAgICAgIHJldHVybiBbYmV6Q3VydmVdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vUGFyYW1ldGVyaXplIHBvaW50cywgYW5kIGF0dGVtcHQgdG8gZml0IGN1cnZlXHJcbiAgICB1ID0gY2hvcmRMZW5ndGhQYXJhbWV0ZXJpemUocG9pbnRzKTtcclxuICAgIFtiZXpDdXJ2ZSwgbWF4RXJyb3IsIHNwbGl0UG9pbnRdID0gZ2VuZXJhdGVBbmRSZXBvcnQocG9pbnRzLCB1LCB1LCBsZWZ0VGFuZ2VudCwgcmlnaHRUYW5nZW50LCBwcm9ncmVzc0NhbGxiYWNrKVxyXG5cclxuICAgIGlmIChtYXhFcnJvciA8IGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIFtiZXpDdXJ2ZV07XHJcbiAgICB9XHJcbiAgICAvL0lmIGVycm9yIG5vdCB0b28gbGFyZ2UsIHRyeSBzb21lIHJlcGFyYW1ldGVyaXphdGlvbiBhbmQgaXRlcmF0aW9uXHJcbiAgICBpZiAobWF4RXJyb3IgPCAoZXJyb3IqZXJyb3IpKSB7XHJcblxyXG4gICAgICAgIHVQcmltZSA9IHU7XHJcbiAgICAgICAgcHJldkVyciA9IG1heEVycm9yO1xyXG4gICAgICAgIHByZXZTcGxpdCA9IHNwbGl0UG9pbnQ7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBNYXhJdGVyYXRpb25zOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgIHVQcmltZSA9IHJlcGFyYW1ldGVyaXplKGJlekN1cnZlLCBwb2ludHMsIHVQcmltZSk7XHJcbiAgICAgICAgICAgIFtiZXpDdXJ2ZSwgbWF4RXJyb3IsIHNwbGl0UG9pbnRdID0gZ2VuZXJhdGVBbmRSZXBvcnQocG9pbnRzLCB1LCB1UHJpbWUsIGxlZnRUYW5nZW50LCByaWdodFRhbmdlbnQsIHByb2dyZXNzQ2FsbGJhY2spO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1heEVycm9yIDwgZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbYmV6Q3VydmVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vSWYgdGhlIGRldmVsb3BtZW50IG9mIHRoZSBmaXR0ZWQgY3VydmUgZ3JpbmRzIHRvIGEgaGFsdCxcclxuICAgICAgICAgICAgLy93ZSBhYm9ydCB0aGlzIGF0dGVtcHQgKGFuZCB0cnkgYSBzaG9ydGVyIGN1cnZlKTpcclxuICAgICAgICAgICAgZWxzZSBpZihzcGxpdFBvaW50ID09PSBwcmV2U3BsaXQpIHtcclxuICAgICAgICAgICAgICAgIGxldCBlcnJDaGFuZ2UgPSBtYXhFcnJvci9wcmV2RXJyO1xyXG4gICAgICAgICAgICAgICAgaWYoKGVyckNoYW5nZSA+IC45OTk5KSAmJiAoZXJyQ2hhbmdlIDwgMS4wMDAxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwcmV2RXJyID0gbWF4RXJyb3I7XHJcbiAgICAgICAgICAgIHByZXZTcGxpdCA9IHNwbGl0UG9pbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vRml0dGluZyBmYWlsZWQgLS0gc3BsaXQgYXQgbWF4IGVycm9yIHBvaW50IGFuZCBmaXQgcmVjdXJzaXZlbHlcclxuICAgIGJlemllcnMgPSBbXTtcclxuXHJcbiAgICAvL1RvIGNyZWF0ZSBhIHNtb290aCB0cmFuc2l0aW9uIGZyb20gb25lIGN1cnZlIHNlZ21lbnQgdG8gdGhlIG5leHQsXHJcbiAgICAvL3dlIGNhbGN1bGF0ZSB0aGUgdGFuZ2VudCBvZiB0aGUgcG9pbnRzIGRpcmVjdGx5IGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGNlbnRlcixcclxuICAgIC8vYW5kIHVzZSB0aGF0IHNhbWUgdGFuZ2VudCBib3RoIHRvIGFuZCBmcm9tIHRoZSBjZW50ZXIgcG9pbnQuXHJcbiAgICBjZW50ZXJWZWN0b3IgPSBtYXRocy5zdWJ0cmFjdChwb2ludHNbc3BsaXRQb2ludCAtIDFdLCBwb2ludHNbc3BsaXRQb2ludCArIDFdKTtcclxuICAgIC8vSG93ZXZlciwgc2hvdWxkIHRob3NlIHR3byBwb2ludHMgYmUgZXF1YWwsIHRoZSBub3JtYWwgdGFuZ2VudCBjYWxjdWxhdGlvbiB3aWxsIGZhaWwuXHJcbiAgICAvL0luc3RlYWQsIHdlIGNhbGN1bGF0ZSB0aGUgdGFuZ2VudCBmcm9tIHRoYXQgXCJkb3VibGUtcG9pbnRcIiB0byB0aGUgY2VudGVyIHBvaW50LCBhbmQgcm90YXRlIDkwZGVnLlxyXG4gICAgaWYoKGNlbnRlclZlY3RvclswXSA9PT0gMCkgJiYgKGNlbnRlclZlY3RvclsxXSA9PT0gMCkpIHtcclxuICAgICAgICAvL3RvQ2VudGVyVGFuZ2VudCA9IGNyZWF0ZVRhbmdlbnQocG9pbnRzW3NwbGl0UG9pbnQgLSAxXSwgcG9pbnRzW3NwbGl0UG9pbnRdKTtcclxuICAgICAgICAvL2Zyb21DZW50ZXJUYW5nZW50ID0gY3JlYXRlVGFuZ2VudChwb2ludHNbc3BsaXRQb2ludCArIDFdLCBwb2ludHNbc3BsaXRQb2ludF0pO1xyXG5cclxuICAgICAgICAvL1t4LHldIC0+IFsteSx4XTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDc4MDE0MS8xODY5NjYwXHJcbiAgICAgICAgY2VudGVyVmVjdG9yID0gbWF0aHMuc3VidHJhY3QocG9pbnRzW3NwbGl0UG9pbnQgLSAxXSwgcG9pbnRzW3NwbGl0UG9pbnRdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJldmVyc2UoKTtcclxuICAgICAgICBjZW50ZXJWZWN0b3JbMF0gPSAtY2VudGVyVmVjdG9yWzBdO1xyXG4gICAgfVxyXG4gICAgdG9DZW50ZXJUYW5nZW50ID0gbWF0aHMubm9ybWFsaXplKGNlbnRlclZlY3Rvcik7XHJcbiAgICAvL1RvIGFuZCBmcm9tIG5lZWQgdG8gcG9pbnQgaW4gb3Bwb3NpdGUgZGlyZWN0aW9uczpcclxuICAgIGZyb21DZW50ZXJUYW5nZW50ID0gbWF0aHMubXVsSXRlbXModG9DZW50ZXJUYW5nZW50LCAtMSk7XHJcblxyXG4gICAgLypcclxuICAgIE5vdGU6IEFuIGFsdGVybmF0aXZlIHRvIHRoaXMgXCJkaXZpZGUgYW5kIGNvbnF1ZXJcIiByZWN1cnNpb24gY291bGQgYmUgdG8gYWx3YXlzXHJcbiAgICAgICAgICBsZXQgbmV3IGN1cnZlIHNlZ21lbnRzIHN0YXJ0IGJ5IHRyeWluZyB0byBnbyBhbGwgdGhlIHdheSB0byB0aGUgZW5kLFxyXG4gICAgICAgICAgaW5zdGVhZCBvZiBvbmx5IHRvIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgc3ViZGl2aWRlZCBwb2x5bGluZS5cclxuICAgICAgICAgIFRoYXQgbWlnaHQgbGV0IG1hbnkgc2VnbWVudHMgZml0IGEgZmV3IHBvaW50cyBtb3JlLCByZWR1Y2luZyB0aGUgbnVtYmVyIG9mIHRvdGFsIHNlZ21lbnRzLlxyXG5cclxuICAgICAgICAgIEhvd2V2ZXIsIGEgZmV3IHRlc3RzIGhhdmUgc2hvd24gdGhhdCB0aGUgc2VnbWVudCByZWR1Y3Rpb24gaXMgaW5zaWduaWZpY2FudFxyXG4gICAgICAgICAgKDI0MCBwdHMsIDEwMCBlcnI6IDI1IGN1cnZlcyB2cyAyNyBjdXJ2ZXMuIDE0MCBwdHMsIDEwMCBlcnI6IDE3IGN1cnZlcyBvbiBib3RoKSxcclxuICAgICAgICAgIGFuZCB0aGUgcmVzdWx0cyB0YWtlIHR3aWNlIGFzIG1hbnkgc3RlcHMgYW5kIG1pbGxpc2Vjb25kcyB0byBmaW5pc2gsXHJcbiAgICAgICAgICB3aXRob3V0IGxvb2tpbmcgYW55IGJldHRlciB0aGFuIHdoYXQgd2UgYWxyZWFkeSBoYXZlLlxyXG4gICAgKi9cclxuICAgIGJlemllcnMgPSBiZXppZXJzLmNvbmNhdChmaXRDdWJpYyhwb2ludHMuc2xpY2UoMCwgc3BsaXRQb2ludCArIDEpLCBsZWZ0VGFuZ2VudCwgdG9DZW50ZXJUYW5nZW50LCAgICBlcnJvciwgcHJvZ3Jlc3NDYWxsYmFjaykpO1xyXG4gICAgYmV6aWVycyA9IGJlemllcnMuY29uY2F0KGZpdEN1YmljKHBvaW50cy5zbGljZShzcGxpdFBvaW50KSwgICAgICAgIGZyb21DZW50ZXJUYW5nZW50LCByaWdodFRhbmdlbnQsIGVycm9yLCBwcm9ncmVzc0NhbGxiYWNrKSk7XHJcbiAgICByZXR1cm4gYmV6aWVycztcclxufTtcclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlQW5kUmVwb3J0KHBvaW50cywgcGFyYW1zT3JpZywgcGFyYW1zUHJpbWUsIGxlZnRUYW5nZW50LCByaWdodFRhbmdlbnQsIHByb2dyZXNzQ2FsbGJhY2spIHtcclxuICAgIHZhciBiZXpDdXJ2ZSwgbWF4RXJyb3IsIHNwbGl0UG9pbnQ7XHJcblxyXG4gICAgYmV6Q3VydmUgPSBnZW5lcmF0ZUJlemllcihwb2ludHMsIHBhcmFtc1ByaW1lLCBsZWZ0VGFuZ2VudCwgcmlnaHRUYW5nZW50LCBwcm9ncmVzc0NhbGxiYWNrKTtcclxuICAgIC8vRmluZCBtYXggZGV2aWF0aW9uIG9mIHBvaW50cyB0byBmaXR0ZWQgY3VydmUuXHJcbiAgICAvL0hlcmUgd2UgYWx3YXlzIHVzZSB0aGUgb3JpZ2luYWwgcGFyYW1ldGVycyAoZnJvbSBjaG9yZExlbmd0aFBhcmFtZXRlcml6ZSgpKSxcclxuICAgIC8vYmVjYXVzZSB3ZSBuZWVkIHRvIGNvbXBhcmUgdGhlIGN1cnJlbnQgY3VydmUgdG8gdGhlIGFjdHVhbCBzb3VyY2UgcG9seWxpbmUsXHJcbiAgICAvL2FuZCBub3QgdGhlIGN1cnJlbnRseSBpdGVyYXRlZCBwYXJhbWV0ZXJzIHdoaWNoIHJlcGFyYW1ldGVyaXplKCkgJiBnZW5lcmF0ZUJlemllcigpIHVzZSxcclxuICAgIC8vYXMgdGhvc2UgaGF2ZSBwcm9iYWJseSBkcmlmdGVkIGZhciBhd2F5IGFuZCBtYXkgbm8gbG9uZ2VyIGJlIGluIGFzY2VuZGluZyBvcmRlci5cclxuICAgIFttYXhFcnJvciwgc3BsaXRQb2ludF0gPSBjb21wdXRlTWF4RXJyb3IocG9pbnRzLCBiZXpDdXJ2ZSwgcGFyYW1zT3JpZyk7XHJcblxyXG4gICAgaWYocHJvZ3Jlc3NDYWxsYmFjaykge1xyXG4gICAgICAgIHByb2dyZXNzQ2FsbGJhY2soe1xyXG4gICAgICAgICAgICBiZXo6IGJlekN1cnZlLFxyXG4gICAgICAgICAgICBwb2ludHM6IHBvaW50cyxcclxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXNPcmlnLFxyXG4gICAgICAgICAgICBtYXhFcnI6IG1heEVycm9yLFxyXG4gICAgICAgICAgICBtYXhQb2ludDogc3BsaXRQb2ludCxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gW2JlekN1cnZlLCBtYXhFcnJvciwgc3BsaXRQb2ludF07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVc2UgbGVhc3Qtc3F1YXJlcyBtZXRob2QgdG8gZmluZCBCZXppZXIgY29udHJvbCBwb2ludHMgZm9yIHJlZ2lvbi5cclxuICpcclxuICogQHBhcmFtIHtBcnJheTxBcnJheTxOdW1iZXI+Pn0gcG9pbnRzIC0gQXJyYXkgb2YgZGlnaXRpemVkIHBvaW50c1xyXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IHBhcmFtZXRlcnMgLSBQYXJhbWV0ZXIgdmFsdWVzIGZvciByZWdpb25cclxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBsZWZ0VGFuZ2VudCAtIFVuaXQgdGFuZ2VudCB2ZWN0b3IgYXQgc3RhcnQgcG9pbnRcclxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSByaWdodFRhbmdlbnQgLSBVbml0IHRhbmdlbnQgdmVjdG9yIGF0IGVuZCBwb2ludFxyXG4gKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk8TnVtYmVyPj59IEFwcHJveGltYXRlZCBCZXppZXIgY3VydmU6IFtmaXJzdC1wb2ludCwgY29udHJvbC1wb2ludC0xLCBjb250cm9sLXBvaW50LTIsIHNlY29uZC1wb2ludF0gd2hlcmUgcG9pbnRzIGFyZSBbeCwgeV1cclxuICovXHJcbmZ1bmN0aW9uIGdlbmVyYXRlQmV6aWVyKHBvaW50cywgcGFyYW1ldGVycywgbGVmdFRhbmdlbnQsIHJpZ2h0VGFuZ2VudCkge1xyXG4gICAgdmFyIGJlekN1cnZlLCAgICAgICAgICAgICAgICAgICAgICAgLy9CZXppZXIgY3VydmUgY3RsIHB0c1xyXG4gICAgICAgIEEsIGEsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9QcmVjb21wdXRlZCByaHMgZm9yIGVxblxyXG4gICAgICAgIEMsIFgsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9NYXRyaWNlcyBDICYgWFxyXG4gICAgICAgIGRldF9DMF9DMSwgZGV0X0MwX1gsIGRldF9YX0MxLCAgLy9EZXRlcm1pbmFudHMgb2YgbWF0cmljZXNcclxuICAgICAgICBhbHBoYV9sLCBhbHBoYV9yLCAgICAgICAgICAgICAgIC8vQWxwaGEgdmFsdWVzLCBsZWZ0IGFuZCByaWdodFxyXG5cclxuICAgICAgICBlcHNpbG9uLCBzZWdMZW5ndGgsXHJcbiAgICAgICAgaSwgbGVuLCB0bXAsIHUsIHV4LFxyXG4gICAgICAgIGZpcnN0UG9pbnQgPSBwb2ludHNbMF0sXHJcbiAgICAgICAgbGFzdFBvaW50ID0gcG9pbnRzW3BvaW50cy5sZW5ndGgtMV07XHJcblxyXG4gICAgYmV6Q3VydmUgPSBbZmlyc3RQb2ludCwgbnVsbCwgbnVsbCwgbGFzdFBvaW50XTtcclxuICAgIC8vY29uc29sZS5sb2coJ2diJywgcGFyYW1ldGVycy5sZW5ndGgpO1xyXG5cclxuICAgIC8vQ29tcHV0ZSB0aGUgQSdzXHJcbiAgICBBID0gbWF0aHMuemVyb3NfWHgyeDIocGFyYW1ldGVycy5sZW5ndGgpO1xyXG4gICAgZm9yIChpID0gMCwgbGVuID0gcGFyYW1ldGVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIHUgPSBwYXJhbWV0ZXJzW2ldO1xyXG4gICAgICAgIHV4ID0gMSAtIHU7XHJcbiAgICAgICAgYSA9IEFbaV07XHJcblxyXG4gICAgICAgIGFbMF0gPSBtYXRocy5tdWxJdGVtcyhsZWZ0VGFuZ2VudCwgIDMgKiB1ICAqICh1eCp1eCkpO1xyXG4gICAgICAgIGFbMV0gPSBtYXRocy5tdWxJdGVtcyhyaWdodFRhbmdlbnQsIDMgKiB1eCAqICh1KnUpKTtcclxuICAgIH1cclxuXHJcbiAgICAvL0NyZWF0ZSB0aGUgQyBhbmQgWCBtYXRyaWNlc1xyXG4gICAgQyA9IFtbMCwwXSwgWzAsMF1dO1xyXG4gICAgWCA9IFswLDBdO1xyXG4gICAgZm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgdSA9IHBhcmFtZXRlcnNbaV07XHJcbiAgICAgICAgYSA9IEFbaV07XHJcblxyXG4gICAgICAgIENbMF1bMF0gKz0gbWF0aHMuZG90KGFbMF0sIGFbMF0pO1xyXG4gICAgICAgIENbMF1bMV0gKz0gbWF0aHMuZG90KGFbMF0sIGFbMV0pO1xyXG4gICAgICAgIENbMV1bMF0gKz0gbWF0aHMuZG90KGFbMF0sIGFbMV0pO1xyXG4gICAgICAgIENbMV1bMV0gKz0gbWF0aHMuZG90KGFbMV0sIGFbMV0pO1xyXG5cclxuICAgICAgICB0bXAgPSBtYXRocy5zdWJ0cmFjdChwb2ludHNbaV0sIGJlemllci5xKFtmaXJzdFBvaW50LCBmaXJzdFBvaW50LCBsYXN0UG9pbnQsIGxhc3RQb2ludF0sIHUpKTtcclxuXHJcbiAgICAgICAgWFswXSArPSBtYXRocy5kb3QoYVswXSwgdG1wKTtcclxuICAgICAgICBYWzFdICs9IG1hdGhzLmRvdChhWzFdLCB0bXApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vQ29tcHV0ZSB0aGUgZGV0ZXJtaW5hbnRzIG9mIEMgYW5kIFhcclxuICAgIGRldF9DMF9DMSA9IChDWzBdWzBdICogQ1sxXVsxXSkgLSAoQ1sxXVswXSAqIENbMF1bMV0pO1xyXG4gICAgZGV0X0MwX1ggID0gKENbMF1bMF0gKiBYWzFdICAgKSAtIChDWzFdWzBdICogWFswXSAgICk7XHJcbiAgICBkZXRfWF9DMSAgPSAoWFswXSAgICAqIENbMV1bMV0pIC0gKFhbMV0gICAgKiBDWzBdWzFdKTtcclxuXHJcbiAgICAvL0ZpbmFsbHksIGRlcml2ZSBhbHBoYSB2YWx1ZXNcclxuICAgIGFscGhhX2wgPSBkZXRfQzBfQzEgPT09IDAgPyAwIDogZGV0X1hfQzEgLyBkZXRfQzBfQzE7XHJcbiAgICBhbHBoYV9yID0gZGV0X0MwX0MxID09PSAwID8gMCA6IGRldF9DMF9YIC8gZGV0X0MwX0MxO1xyXG5cclxuICAgIC8vSWYgYWxwaGEgbmVnYXRpdmUsIHVzZSB0aGUgV3UvQmFyc2t5IGhldXJpc3RpYyAoc2VlIHRleHQpLlxyXG4gICAgLy9JZiBhbHBoYSBpcyAwLCB5b3UgZ2V0IGNvaW5jaWRlbnQgY29udHJvbCBwb2ludHMgdGhhdCBsZWFkIHRvXHJcbiAgICAvL2RpdmlkZSBieSB6ZXJvIGluIGFueSBzdWJzZXF1ZW50IE5ld3RvblJhcGhzb25Sb290RmluZCgpIGNhbGwuXHJcbiAgICBzZWdMZW5ndGggPSBtYXRocy52ZWN0b3JMZW4obWF0aHMuc3VidHJhY3QoZmlyc3RQb2ludCwgbGFzdFBvaW50KSk7XHJcbiAgICBlcHNpbG9uID0gMS4wZS02ICogc2VnTGVuZ3RoO1xyXG4gICAgaWYgKGFscGhhX2wgPCBlcHNpbG9uIHx8IGFscGhhX3IgPCBlcHNpbG9uKSB7XHJcbiAgICAgICAgLy9GYWxsIGJhY2sgb24gc3RhbmRhcmQgKHByb2JhYmx5IGluYWNjdXJhdGUpIGZvcm11bGEsIGFuZCBzdWJkaXZpZGUgZnVydGhlciBpZiBuZWVkZWQuXHJcbiAgICAgICAgYmV6Q3VydmVbMV0gPSBtYXRocy5hZGRBcnJheXMoZmlyc3RQb2ludCwgbWF0aHMubXVsSXRlbXMobGVmdFRhbmdlbnQsICBzZWdMZW5ndGggLyAzLjApKTtcclxuICAgICAgICBiZXpDdXJ2ZVsyXSA9IG1hdGhzLmFkZEFycmF5cyhsYXN0UG9pbnQsICBtYXRocy5tdWxJdGVtcyhyaWdodFRhbmdlbnQsIHNlZ0xlbmd0aCAvIDMuMCkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvL0ZpcnN0IGFuZCBsYXN0IGNvbnRyb2wgcG9pbnRzIG9mIHRoZSBCZXppZXIgY3VydmUgYXJlXHJcbiAgICAgICAgLy9wb3NpdGlvbmVkIGV4YWN0bHkgYXQgdGhlIGZpcnN0IGFuZCBsYXN0IGRhdGEgcG9pbnRzXHJcbiAgICAgICAgLy9Db250cm9sIHBvaW50cyAxIGFuZCAyIGFyZSBwb3NpdGlvbmVkIGFuIGFscGhhIGRpc3RhbmNlIG91dFxyXG4gICAgICAgIC8vb24gdGhlIHRhbmdlbnQgdmVjdG9ycywgbGVmdCBhbmQgcmlnaHQsIHJlc3BlY3RpdmVseVxyXG4gICAgICAgIGJlekN1cnZlWzFdID0gbWF0aHMuYWRkQXJyYXlzKGZpcnN0UG9pbnQsIG1hdGhzLm11bEl0ZW1zKGxlZnRUYW5nZW50LCAgYWxwaGFfbCkpO1xyXG4gICAgICAgIGJlekN1cnZlWzJdID0gbWF0aHMuYWRkQXJyYXlzKGxhc3RQb2ludCwgIG1hdGhzLm11bEl0ZW1zKHJpZ2h0VGFuZ2VudCwgYWxwaGFfcikpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBiZXpDdXJ2ZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBzZXQgb2YgcG9pbnRzIGFuZCB0aGVpciBwYXJhbWV0ZXJpemF0aW9uLCB0cnkgdG8gZmluZCBhIGJldHRlciBwYXJhbWV0ZXJpemF0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PE51bWJlcj4+fSBiZXppZXIgLSBDdXJyZW50IGZpdHRlZCBjdXJ2ZVxyXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PE51bWJlcj4+fSBwb2ludHMgLSBBcnJheSBvZiBkaWdpdGl6ZWQgcG9pbnRzXHJcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gcGFyYW1ldGVycyAtIEN1cnJlbnQgcGFyYW1ldGVyIHZhbHVlc1xyXG4gKiBAcmV0dXJucyB7QXJyYXk8TnVtYmVyPn0gTmV3IHBhcmFtZXRlciB2YWx1ZXNcclxuICovXHJcbmZ1bmN0aW9uIHJlcGFyYW1ldGVyaXplKGJlemllciwgcG9pbnRzLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICAvKlxyXG4gICAgdmFyIGosIGxlbiwgcG9pbnQsIHJlc3VsdHMsIHU7XHJcbiAgICByZXN1bHRzID0gW107XHJcbiAgICBmb3IgKGogPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcclxuICAgICAgICBwb2ludCA9IHBvaW50c1tqXSwgdSA9IHBhcmFtZXRlcnNbal07XHJcblxyXG4gICAgICAgIHJlc3VsdHMucHVzaChuZXd0b25SYXBoc29uUm9vdEZpbmQoYmV6aWVyLCBwb2ludCwgdSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAvLyovXHJcbiAgICByZXR1cm4gcGFyYW1ldGVycy5tYXAoKHAsIGkpID0+IG5ld3RvblJhcGhzb25Sb290RmluZChiZXppZXIsIHBvaW50c1tpXSwgcCkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFVzZSBOZXd0b24tUmFwaHNvbiBpdGVyYXRpb24gdG8gZmluZCBiZXR0ZXIgcm9vdC5cclxuICpcclxuICogQHBhcmFtIHtBcnJheTxBcnJheTxOdW1iZXI+Pn0gYmV6IC0gQ3VycmVudCBmaXR0ZWQgY3VydmVcclxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBwb2ludCAtIERpZ2l0aXplZCBwb2ludFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdSAtIFBhcmFtZXRlciB2YWx1ZSBmb3IgXCJQXCJcclxuICogQHJldHVybnMge051bWJlcn0gTmV3IHVcclxuICovXHJcbmZ1bmN0aW9uIG5ld3RvblJhcGhzb25Sb290RmluZChiZXosIHBvaW50LCB1KSB7XHJcbiAgICAvKlxyXG4gICAgICAgIE5ld3RvbidzIHJvb3QgZmluZGluZyBhbGdvcml0aG0gY2FsY3VsYXRlcyBmKHgpPTAgYnkgcmVpdGVyYXRpbmdcclxuICAgICAgICB4X24rMSA9IHhfbiAtIGYoeF9uKS9mJyh4X24pXHJcbiAgICAgICAgV2UgYXJlIHRyeWluZyB0byBmaW5kIGN1cnZlIHBhcmFtZXRlciB1IGZvciBzb21lIHBvaW50IHAgdGhhdCBtaW5pbWl6ZXNcclxuICAgICAgICB0aGUgZGlzdGFuY2UgZnJvbSB0aGF0IHBvaW50IHRvIHRoZSBjdXJ2ZS4gRGlzdGFuY2UgcG9pbnQgdG8gY3VydmUgaXMgZD1xKHUpLXAuXHJcbiAgICAgICAgQXQgbWluaW11bSBkaXN0YW5jZSB0aGUgcG9pbnQgaXMgcGVycGVuZGljdWxhciB0byB0aGUgY3VydmUuXHJcbiAgICAgICAgV2UgYXJlIHNvbHZpbmdcclxuICAgICAgICBmID0gcSh1KS1wICogcScodSkgPSAwXHJcbiAgICAgICAgd2l0aFxyXG4gICAgICAgIGYnID0gcScodSkgKiBxJyh1KSArIHEodSktcCAqIHEnJyh1KVxyXG4gICAgICAgIGdpdmVzXHJcbiAgICAgICAgdV9uKzEgPSB1X24gLSB8cSh1X24pLXAgKiBxJyh1X24pfCAvIHxxJyh1X24pKioyICsgcSh1X24pLXAgKiBxJycodV9uKXxcclxuICAgICovXHJcblxyXG4gICAgdmFyIGQgPSBtYXRocy5zdWJ0cmFjdChiZXppZXIucShiZXosIHUpLCBwb2ludCksXHJcbiAgICAgICAgcXByaW1lID0gYmV6aWVyLnFwcmltZShiZXosIHUpLFxyXG4gICAgICAgIG51bWVyYXRvciA9IC8qc3VtKCovbWF0aHMubXVsTWF0cml4KGQsIHFwcmltZSkvKikqLyxcclxuICAgICAgICBkZW5vbWluYXRvciA9IG1hdGhzLnN1bShtYXRocy5hZGRJdGVtcyggbWF0aHMuc3F1YXJlSXRlbXMocXByaW1lKSwgbWF0aHMubXVsTWF0cml4KGQsIGJlemllci5xcHJpbWVwcmltZShiZXosIHUpKSApKTtcclxuXHJcbiAgICBpZiAoZGVub21pbmF0b3IgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gdTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHUgLSAobnVtZXJhdG9yL2Rlbm9taW5hdG9yKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBBc3NpZ24gcGFyYW1ldGVyIHZhbHVlcyB0byBkaWdpdGl6ZWQgcG9pbnRzIHVzaW5nIHJlbGF0aXZlIGRpc3RhbmNlcyBiZXR3ZWVuIHBvaW50cy5cclxuICpcclxuICogQHBhcmFtIHtBcnJheTxBcnJheTxOdW1iZXI+Pn0gcG9pbnRzIC0gQXJyYXkgb2YgZGlnaXRpemVkIHBvaW50c1xyXG4gKiBAcmV0dXJucyB7QXJyYXk8TnVtYmVyPn0gUGFyYW1ldGVyIHZhbHVlc1xyXG4gKi9cclxuZnVuY3Rpb24gY2hvcmRMZW5ndGhQYXJhbWV0ZXJpemUocG9pbnRzKSB7XHJcbiAgICB2YXIgdSA9IFtdLCBjdXJyVSwgcHJldlUsIHByZXZQO1xyXG5cclxuICAgIHBvaW50cy5mb3JFYWNoKChwLCBpKSA9PiB7XHJcbiAgICAgICAgY3VyclUgPSBpID8gcHJldlUgKyBtYXRocy52ZWN0b3JMZW4obWF0aHMuc3VidHJhY3QocCwgcHJldlApKVxyXG4gICAgICAgICAgICAgICAgICA6IDA7XHJcbiAgICAgICAgdS5wdXNoKGN1cnJVKTtcclxuXHJcbiAgICAgICAgcHJldlUgPSBjdXJyVTtcclxuICAgICAgICBwcmV2UCA9IHA7XHJcbiAgICB9KVxyXG4gICAgdSA9IHUubWFwKHggPT4geC9wcmV2VSk7XHJcblxyXG4gICAgcmV0dXJuIHU7XHJcbn07XHJcblxyXG4vKipcclxuICogRmluZCB0aGUgbWF4aW11bSBzcXVhcmVkIGRpc3RhbmNlIG9mIGRpZ2l0aXplZCBwb2ludHMgdG8gZml0dGVkIGN1cnZlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PE51bWJlcj4+fSBwb2ludHMgLSBBcnJheSBvZiBkaWdpdGl6ZWQgcG9pbnRzXHJcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8TnVtYmVyPj59IGJleiAtIEZpdHRlZCBjdXJ2ZVxyXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IHBhcmFtZXRlcnMgLSBQYXJhbWV0ZXJpemF0aW9uIG9mIHBvaW50c1xyXG4gKiBAcmV0dXJucyB7QXJyYXk8TnVtYmVyPn0gTWF4aW11bSBlcnJvciAoc3F1YXJlZCkgYW5kIHBvaW50IG9mIG1heCBlcnJvclxyXG4gKi9cclxuZnVuY3Rpb24gY29tcHV0ZU1heEVycm9yKHBvaW50cywgYmV6LCBwYXJhbWV0ZXJzKSB7XHJcbiAgICB2YXIgZGlzdCwgICAgICAgLy9DdXJyZW50IGVycm9yXHJcbiAgICAgICAgbWF4RGlzdCwgICAgLy9NYXhpbXVtIGVycm9yXHJcbiAgICAgICAgc3BsaXRQb2ludCwgLy9Qb2ludCBvZiBtYXhpbXVtIGVycm9yXHJcbiAgICAgICAgdiwgICAgICAgICAgLy9WZWN0b3IgZnJvbSBwb2ludCB0byBjdXJ2ZVxyXG4gICAgICAgIGksIGNvdW50LCBwb2ludCwgdDtcclxuXHJcbiAgICBtYXhEaXN0ID0gMDtcclxuICAgIHNwbGl0UG9pbnQgPSBwb2ludHMubGVuZ3RoIC8gMjtcclxuXHJcbiAgICBjb25zdCB0X2Rpc3RNYXAgPSBtYXBUdG9SZWxhdGl2ZURpc3RhbmNlcyhiZXosIDEwKTtcclxuXHJcbiAgICBmb3IgKGkgPSAwLCBjb3VudCA9IHBvaW50cy5sZW5ndGg7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgcG9pbnQgPSBwb2ludHNbaV07XHJcbiAgICAgICAgLy9GaW5kICd0JyBmb3IgYSBwb2ludCBvbiB0aGUgYmV6IGN1cnZlIHRoYXQncyBhcyBjbG9zZSB0byAncG9pbnQnIGFzIHBvc3NpYmxlOlxyXG4gICAgICAgIHQgPSBmaW5kX3QoYmV6LCBwYXJhbWV0ZXJzW2ldLCB0X2Rpc3RNYXAsIDEwKTtcclxuXHJcbiAgICAgICAgdiA9IG1hdGhzLnN1YnRyYWN0KGJlemllci5xKGJleiwgdCksIHBvaW50KTtcclxuICAgICAgICBkaXN0ID0gdlswXSp2WzBdICsgdlsxXSp2WzFdO1xyXG5cclxuICAgICAgICBpZiAoZGlzdCA+IG1heERpc3QpIHtcclxuICAgICAgICAgICAgbWF4RGlzdCA9IGRpc3Q7XHJcbiAgICAgICAgICAgIHNwbGl0UG9pbnQgPSBpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gW21heERpc3QsIHNwbGl0UG9pbnRdO1xyXG59O1xyXG5cclxuLy9TYW1wbGUgJ3QncyBhbmQgbWFwIHRoZW0gdG8gcmVsYXRpdmUgZGlzdGFuY2VzIGFsb25nIHRoZSBjdXJ2ZTpcclxudmFyIG1hcFR0b1JlbGF0aXZlRGlzdGFuY2VzID0gZnVuY3Rpb24gKGJleiwgQl9wYXJ0cykge1xyXG4gICAgdmFyIEJfdF9jdXJyO1xyXG4gICAgdmFyIEJfdF9kaXN0ID0gWzBdO1xyXG4gICAgdmFyIEJfdF9wcmV2ID0gYmV6WzBdO1xyXG4gICAgdmFyIHN1bUxlbiA9IDA7XHJcblxyXG4gICAgZm9yICh2YXIgaT0xOyBpPD1CX3BhcnRzOyBpKyspIHtcclxuICAgICAgQl90X2N1cnIgPSBiZXppZXIucShiZXosIGkvQl9wYXJ0cyk7XHJcblxyXG4gICAgICBzdW1MZW4gKz0gbWF0aHMudmVjdG9yTGVuKG1hdGhzLnN1YnRyYWN0KEJfdF9jdXJyLCBCX3RfcHJldikpO1xyXG5cclxuICAgICAgQl90X2Rpc3QucHVzaChzdW1MZW4pO1xyXG4gICAgICBCX3RfcHJldiA9IEJfdF9jdXJyO1xyXG4gICAgfVxyXG5cclxuICAgIC8vTm9ybWFsaXplIEJfbGVuZ3RoIHRvIHRoZSBzYW1lIGludGVydmFsIGFzIHRoZSBwYXJhbWV0ZXIgZGlzdGFuY2VzOyAwIHRvIDE6XHJcbiAgICBCX3RfZGlzdCA9IEJfdF9kaXN0Lm1hcCh4ID0+IHgvc3VtTGVuKTtcclxuICAgIHJldHVybiBCX3RfZGlzdDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGZpbmRfdChiZXosIHBhcmFtLCB0X2Rpc3RNYXAsIEJfcGFydHMpIHtcclxuICAgIGlmKHBhcmFtIDwgMCkgeyByZXR1cm4gMDsgfVxyXG4gICAgaWYocGFyYW0gPiAxKSB7IHJldHVybiAxOyB9XHJcblxyXG4gICAgLypcclxuICAgICAgICAncGFyYW0nIGlzIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxIHRlbGxpbmcgdXMgdGhlIHJlbGF0aXZlIHBvc2l0aW9uXHJcbiAgICAgICAgb2YgYSBwb2ludCBvbiB0aGUgc291cmNlIHBvbHlsaW5lIChsaW5lYXJseSBmcm9tIHRoZSBzdGFydCAoMCkgdG8gdGhlIGVuZCAoMSkpLlxyXG4gICAgICAgIFRvIHNlZSBpZiBhIGdpdmVuIGN1cnZlIC0gJ2JleicgLSBpcyBhIGNsb3NlIGFwcHJveGltYXRpb24gb2YgdGhlIHBvbHlsaW5lLFxyXG4gICAgICAgIHdlIGNvbXBhcmUgc3VjaCBhIHBvbHktcG9pbnQgdG8gdGhlIHBvaW50IG9uIHRoZSBjdXJ2ZSB0aGF0J3MgdGhlIHNhbWVcclxuICAgICAgICByZWxhdGl2ZSBkaXN0YW5jZSBhbG9uZyB0aGUgY3VydmUncyBsZW5ndGguXHJcblxyXG4gICAgICAgIEJ1dCBmaW5kaW5nIHRoYXQgY3VydmUtcG9pbnQgdGFrZXMgYSBsaXR0bGUgd29yazpcclxuICAgICAgICBUaGVyZSBpcyBhIGZ1bmN0aW9uIFwiQih0KVwiIHRvIGZpbmQgcG9pbnRzIGFsb25nIGEgY3VydmUgZnJvbSB0aGUgcGFyYW1ldHJpYyBwYXJhbWV0ZXIgJ3QnXHJcbiAgICAgICAgKGFsc28gcmVsYXRpdmUgZnJvbSAwIHRvIDE6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMyODQxNzY0LzE4Njk2NjBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHR0cDovL3BvbWF4LmdpdGh1Yi5pby9iZXppZXJpbmZvLyNleHBsYW5hdGlvbiksXHJcbiAgICAgICAgYnV0ICd0JyBpc24ndCBsaW5lYXIgYnkgbGVuZ3RoIChodHRwOi8vZ2FtZWRldi5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMTA1MjMwKS5cclxuXHJcbiAgICAgICAgU28sIHdlIHNhbXBsZSBzb21lIHBvaW50cyBhbG9uZyB0aGUgY3VydmUgdXNpbmcgYSBoYW5kZnVsIG9mIHZhbHVlcyBmb3IgJ3QnLlxyXG4gICAgICAgIFRoZW4sIHdlIGNhbGN1bGF0ZSB0aGUgbGVuZ3RoIGJldHdlZW4gdGhvc2Ugc2FtcGxlcyB2aWEgcGxhaW4gZXVjbGlkZWFuIGRpc3RhbmNlO1xyXG4gICAgICAgIEIodCkgY29uY2VudHJhdGVzIHRoZSBwb2ludHMgYXJvdW5kIHNoYXJwIHR1cm5zLCBzbyB0aGlzIHNob3VsZCBnaXZlIHVzIGEgZ29vZC1lbm91Z2ggb3V0bGluZSBvZiB0aGUgY3VydmUuXHJcbiAgICAgICAgVGh1cywgZm9yIGEgZ2l2ZW4gcmVsYXRpdmUgZGlzdGFuY2UgKCdwYXJhbScpLCB3ZSBjYW4gbm93IGZpbmQgYW4gdXBwZXIgYW5kIGxvd2VyIHZhbHVlXHJcbiAgICAgICAgZm9yIHRoZSBjb3JyZXNwb25kaW5nICd0JyBieSBzZWFyY2hpbmcgdGhyb3VnaCB0aG9zZSBzYW1wbGVkIGRpc3RhbmNlcy5cclxuICAgICAgICBGaW5hbGx5LCB3ZSBqdXN0IHVzZSBsaW5lYXIgaW50ZXJwb2xhdGlvbiB0byBmaW5kIGEgYmV0dGVyIHZhbHVlIGZvciB0aGUgZXhhY3QgJ3QnLlxyXG5cclxuICAgICAgICBNb3JlIGluZm86XHJcbiAgICAgICAgICAgIGh0dHA6Ly9nYW1lZGV2LnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8xMDUyMzAvcG9pbnRzLWV2ZW5seS1zcGFjZWQtYWxvbmctYS1iZXppZXItY3VydmVcclxuICAgICAgICAgICAgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yOTQzODM5OC9jaGVhcC13YXktb2YtY2FsY3VsYXRpbmctY3ViaWMtYmV6aWVyLWxlbmd0aFxyXG4gICAgICAgICAgICBodHRwOi8vc3RldmUuaG9sbGFzY2gubmV0L2NnaW5kZXgvY3VydmVzL2NiZXphcmNsZW4uaHRtbFxyXG4gICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vcmV0dXh4L3RpbnlzcGxpbmVcclxuICAgICovXHJcbiAgICB2YXIgbGVuTWF4LCBsZW5NaW4sIHRNYXgsIHRNaW4sIHQ7XHJcblxyXG4gICAgLy9GaW5kIHRoZSB0d28gdC1zIHRoYXQgdGhlIGN1cnJlbnQgcGFyYW0gZGlzdGFuY2UgbGllcyBiZXR3ZWVuLFxyXG4gICAgLy9hbmQgdGhlbiBpbnRlcnBvbGF0ZSBhIHNvbWV3aGF0IGFjY3VyYXRlIHZhbHVlIGZvciB0aGUgZXhhY3QgdDpcclxuICAgIGZvcih2YXIgaSA9IDE7IGkgPD0gQl9wYXJ0czsgaSsrKSB7XHJcblxyXG4gICAgICAgIGlmKHBhcmFtIDw9IHRfZGlzdE1hcFtpXSkge1xyXG4gICAgICAgICAgICB0TWluICAgPSAoaS0xKSAvIEJfcGFydHM7XHJcbiAgICAgICAgICAgIHRNYXggICA9IGkgLyBCX3BhcnRzO1xyXG4gICAgICAgICAgICBsZW5NaW4gPSB0X2Rpc3RNYXBbaS0xXTtcclxuICAgICAgICAgICAgbGVuTWF4ID0gdF9kaXN0TWFwW2ldO1xyXG5cclxuICAgICAgICAgICAgdCA9IChwYXJhbS1sZW5NaW4pLyhsZW5NYXgtbGVuTWluKSAqICh0TWF4LXRNaW4pICsgdE1pbjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgdmVjdG9yIG9mIGxlbmd0aCAxIHdoaWNoIHNob3dzIHRoZSBkaXJlY3Rpb24gZnJvbSBCIHRvIEFcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVRhbmdlbnQocG9pbnRBLCBwb2ludEIpIHtcclxuICAgIHJldHVybiBtYXRocy5ub3JtYWxpemUobWF0aHMuc3VidHJhY3QocG9pbnRBLCBwb2ludEIpKTtcclxufVxyXG5cclxuLypcclxuICAgIFNpbXBsaWZpZWQgdmVyc2lvbnMgb2Ygd2hhdCB3ZSBuZWVkIGZyb20gbWF0aC5qc1xyXG4gICAgT3B0aW1pemVkIGZvciBvdXIgaW5wdXQsIHdoaWNoIGlzIG9ubHkgbnVtYmVycyBhbmQgMXgyIGFycmF5cyAoaS5lLiBbeCwgeV0gY29vcmRpbmF0ZXMpLlxyXG4qL1xyXG5jbGFzcyBtYXRocyB7XHJcbiAgICAvL3plcm9zID0gbG9nQW5kUnVuKG1hdGguemVyb3MpO1xyXG4gICAgc3RhdGljIHplcm9zX1h4MngyKHgpIHtcclxuICAgICAgICB2YXIgenMgPSBbXTtcclxuICAgICAgICB3aGlsZSh4LS0pIHsgenMucHVzaChbMCwwXSk7IH1cclxuICAgICAgICByZXR1cm4genNcclxuICAgIH1cclxuXHJcbiAgICAvL211bHRpcGx5ID0gbG9nQW5kUnVuKG1hdGgubXVsdGlwbHkpO1xyXG4gICAgc3RhdGljIG11bEl0ZW1zKGl0ZW1zLCBtdWx0aXBsaWVyKSB7XHJcbiAgICAgICAgLy9yZXR1cm4gaXRlbXMubWFwKHggPT4geCptdWx0aXBsaWVyKTtcclxuICAgICAgICByZXR1cm4gW2l0ZW1zWzBdKm11bHRpcGxpZXIsIGl0ZW1zWzFdKm11bHRpcGxpZXJdO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG11bE1hdHJpeChtMSwgbTIpIHtcclxuICAgICAgICAvL2h0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hdHJpeF9tdWx0aXBsaWNhdGlvbiNNYXRyaXhfcHJvZHVjdF8uMjh0d29fbWF0cmljZXMuMjlcclxuICAgICAgICAvL1NpbXBsaWZpZWQgdG8gb25seSBoYW5kbGUgMS1kaW1lbnNpb25hbCBtYXRyaWNlcyAoaS5lLiBhcnJheXMpIG9mIGVxdWFsIGxlbmd0aDpcclxuICAgICAgICAvLyAgcmV0dXJuIG0xLnJlZHVjZSgoc3VtLHgxLGkpID0+IHN1bSArICh4MSptMltpXSksXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgMCk7XHJcbiAgICAgICAgcmV0dXJuIChtMVswXSptMlswXSkgKyAobTFbMV0qbTJbMV0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vT25seSB1c2VkIHRvIHN1YnJhY3QgdG8gcG9pbnRzIChvciBhdCBsZWFzdCBhcnJheXMpOlxyXG4gICAgLy8gIHN1YnRyYWN0ID0gbG9nQW5kUnVuKG1hdGguc3VidHJhY3QpO1xyXG4gICAgc3RhdGljIHN1YnRyYWN0KGFycjEsIGFycjIpIHtcclxuICAgICAgICAvL3JldHVybiBhcnIxLm1hcCgoeDEsIGkpID0+IHgxIC0gYXJyMltpXSk7XHJcbiAgICAgICAgcmV0dXJuIFthcnIxWzBdLWFycjJbMF0sIGFycjFbMV0tYXJyMlsxXV07XHJcbiAgICB9XHJcblxyXG4gICAgLy9hZGQgPSBsb2dBbmRSdW4obWF0aC5hZGQpO1xyXG4gICAgc3RhdGljIGFkZEFycmF5cyhhcnIxLCBhcnIyKSB7XHJcbiAgICAgICAgLy9yZXR1cm4gYXJyMS5tYXAoKHgxLCBpKSA9PiB4MSArIGFycjJbaV0pO1xyXG4gICAgICAgIHJldHVybiBbYXJyMVswXSthcnIyWzBdLCBhcnIxWzFdK2FycjJbMV1dO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFkZEl0ZW1zKGl0ZW1zLCBhZGRpdGlvbikge1xyXG4gICAgICAgIC8vcmV0dXJuIGl0ZW1zLm1hcCh4ID0+IHgrYWRkaXRpb24pO1xyXG4gICAgICAgIHJldHVybiBbaXRlbXNbMF0rYWRkaXRpb24sIGl0ZW1zWzFdK2FkZGl0aW9uXTtcclxuICAgIH1cclxuXHJcbiAgICAvL3ZhciBzdW0gPSBsb2dBbmRSdW4obWF0aC5zdW0pO1xyXG4gICAgc3RhdGljIHN1bShpdGVtcykge1xyXG4gICAgICAgIHJldHVybiBpdGVtcy5yZWR1Y2UoKHN1bSx4KSA9PiBzdW0gKyB4KTtcclxuICAgIH1cclxuXHJcbiAgICAvL2NoYWluID0gbWF0aC5jaGFpbjtcclxuXHJcbiAgICAvL09ubHkgdXNlZCBvbiB0d28gYXJyYXlzLiBUaGUgZG90IHByb2R1Y3QgaXMgZXF1YWwgdG8gdGhlIG1hdHJpeCBwcm9kdWN0IGluIHRoaXMgY2FzZTpcclxuICAgIC8vICBkb3QgPSBsb2dBbmRSdW4obWF0aC5kb3QpO1xyXG4gICAgc3RhdGljIGRvdChtMSwgbTIpIHtcclxuICAgICAgICByZXR1cm4gbWF0aHMubXVsTWF0cml4KG0xLCBtMik7XHJcbiAgICB9XHJcblxyXG4gICAgLy9odHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ob3JtXyhtYXRoZW1hdGljcykjRXVjbGlkZWFuX25vcm1cclxuICAgIC8vICB2YXIgbm9ybSA9IGxvZ0FuZFJ1bihtYXRoLm5vcm0pO1xyXG4gICAgc3RhdGljIHZlY3Rvckxlbih2KSB7XHJcbiAgICAgICAgdmFyIGEgPSB2WzBdLCBiID0gdlsxXTtcclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KGEqYSArIGIqYik7XHJcbiAgICB9XHJcblxyXG4gICAgLy9tYXRoLmRpdmlkZSA9IGxvZ0FuZFJ1bihtYXRoLmRpdmlkZSk7XHJcbiAgICBzdGF0aWMgZGl2SXRlbXMoaXRlbXMsIGRpdmlzb3IpIHtcclxuICAgICAgICAvL3JldHVybiBpdGVtcy5tYXAoeCA9PiB4L2Rpdmlzb3IpO1xyXG4gICAgICAgIHJldHVybiBbaXRlbXNbMF0vZGl2aXNvciwgaXRlbXNbMV0vZGl2aXNvcl07XHJcbiAgICB9XHJcblxyXG4gICAgLy92YXIgZG90UG93ID0gbG9nQW5kUnVuKG1hdGguZG90UG93KTtcclxuICAgIHN0YXRpYyBzcXVhcmVJdGVtcyhpdGVtcykge1xyXG4gICAgICAgIC8vcmV0dXJuIGl0ZW1zLm1hcCh4ID0+IHgqeCk7XHJcbiAgICAgICAgdmFyIGEgPSBpdGVtc1swXSwgYiA9IGl0ZW1zWzFdO1xyXG4gICAgICAgIHJldHVybiBbYSphLCBiKmJdO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBub3JtYWxpemUodikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRpdkl0ZW1zKHYsIHRoaXMudmVjdG9yTGVuKHYpKTtcclxuICAgIH1cclxuXHJcbiAgICAvL01hdGgucG93ID0gbG9nQW5kUnVuKE1hdGgucG93KTtcclxufVxyXG5cclxuXHJcbmNsYXNzIGJlemllciB7XHJcbiAgICAvL0V2YWx1YXRlcyBjdWJpYyBiZXppZXIgYXQgdCwgcmV0dXJuIHBvaW50XHJcbiAgICBzdGF0aWMgcShjdHJsUG9seSwgdCkge1xyXG4gICAgICAgIHZhciB0eCA9IDEuMCAtIHQ7XHJcbiAgICAgICAgdmFyIHBBID0gbWF0aHMubXVsSXRlbXMoIGN0cmxQb2x5WzBdLCAgICAgIHR4ICogdHggKiB0eCApLFxyXG4gICAgICAgICAgICBwQiA9IG1hdGhzLm11bEl0ZW1zKCBjdHJsUG9seVsxXSwgIDMgKiB0eCAqIHR4ICogIHQgKSxcclxuICAgICAgICAgICAgcEMgPSBtYXRocy5tdWxJdGVtcyggY3RybFBvbHlbMl0sICAzICogdHggKiAgdCAqICB0ICksXHJcbiAgICAgICAgICAgIHBEID0gbWF0aHMubXVsSXRlbXMoIGN0cmxQb2x5WzNdLCAgICAgICB0ICogIHQgKiAgdCApO1xyXG4gICAgICAgIHJldHVybiBtYXRocy5hZGRBcnJheXMobWF0aHMuYWRkQXJyYXlzKHBBLCBwQiksIG1hdGhzLmFkZEFycmF5cyhwQywgcEQpKTtcclxuICAgIH1cclxuXHJcbiAgICAvL0V2YWx1YXRlcyBjdWJpYyBiZXppZXIgZmlyc3QgZGVyaXZhdGl2ZSBhdCB0LCByZXR1cm4gcG9pbnRcclxuICAgIHN0YXRpYyBxcHJpbWUoY3RybFBvbHksIHQpIHtcclxuICAgICAgICB2YXIgdHggPSAxLjAgLSB0O1xyXG4gICAgICAgIHZhciBwQSA9IG1hdGhzLm11bEl0ZW1zKCBtYXRocy5zdWJ0cmFjdChjdHJsUG9seVsxXSwgY3RybFBvbHlbMF0pLCAgMyAqIHR4ICogdHggKSxcclxuICAgICAgICAgICAgcEIgPSBtYXRocy5tdWxJdGVtcyggbWF0aHMuc3VidHJhY3QoY3RybFBvbHlbMl0sIGN0cmxQb2x5WzFdKSwgIDYgKiB0eCAqICB0ICksXHJcbiAgICAgICAgICAgIHBDID0gbWF0aHMubXVsSXRlbXMoIG1hdGhzLnN1YnRyYWN0KGN0cmxQb2x5WzNdLCBjdHJsUG9seVsyXSksICAzICogIHQgKiAgdCApO1xyXG4gICAgICAgIHJldHVybiBtYXRocy5hZGRBcnJheXMobWF0aHMuYWRkQXJyYXlzKHBBLCBwQiksIHBDKTtcclxuICAgIH1cclxuXHJcbiAgICAvL0V2YWx1YXRlcyBjdWJpYyBiZXppZXIgc2Vjb25kIGRlcml2YXRpdmUgYXQgdCwgcmV0dXJuIHBvaW50XHJcbiAgICBzdGF0aWMgcXByaW1lcHJpbWUoY3RybFBvbHksIHQpIHtcclxuICAgICAgICByZXR1cm4gbWF0aHMuYWRkQXJyYXlzKG1hdGhzLm11bEl0ZW1zKCBtYXRocy5hZGRBcnJheXMobWF0aHMuc3VidHJhY3QoY3RybFBvbHlbMl0sIG1hdGhzLm11bEl0ZW1zKGN0cmxQb2x5WzFdLCAyKSksIGN0cmxQb2x5WzBdKSwgIDYgKiAoMS4wIC0gdCkgKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGhzLm11bEl0ZW1zKCBtYXRocy5hZGRBcnJheXMobWF0aHMuc3VidHJhY3QoY3RybFBvbHlbM10sIG1hdGhzLm11bEl0ZW1zKGN0cmxQb2x5WzJdLCAyKSksIGN0cmxQb2x5WzFdKSwgIDYgKiAgICAgICAgdCAgKSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZml0Q3VydmU7XHJcbiIsIi8qIVxuKiBzdmcuanMgLSBBIGxpZ2h0d2VpZ2h0IGxpYnJhcnkgZm9yIG1hbmlwdWxhdGluZyBhbmQgYW5pbWF0aW5nIFNWRy5cbiogQHZlcnNpb24gMi4zLjdcbiogaHR0cHM6Ly9zdmdkb3Rqcy5naXRodWIuaW8vXG4qXG4qIEBjb3B5cmlnaHQgV291dCBGaWVyZW5zIDx3b3V0QG1pY2std291dC5jb20+XG4qIEBsaWNlbnNlIE1JVFxuKlxuKiBCVUlMVDogU2F0IEphbiAxNCAyMDE3IDA3OjIzOjE4IEdNVCswMTAwIChDRVQpXG4qLztcbihmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBmYWN0b3J5KHJvb3QsIHJvb3QuZG9jdW1lbnQpXG4gICAgfSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJvb3QuZG9jdW1lbnQgPyBmYWN0b3J5KHJvb3QsIHJvb3QuZG9jdW1lbnQpIDogZnVuY3Rpb24odyl7IHJldHVybiBmYWN0b3J5KHcsIHcuZG9jdW1lbnQpIH1cbiAgfSBlbHNlIHtcbiAgICByb290LlNWRyA9IGZhY3Rvcnkocm9vdCwgcm9vdC5kb2N1bWVudClcbiAgfVxufSh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24od2luZG93LCBkb2N1bWVudCkge1xuXG4vLyBUaGUgbWFpbiB3cmFwcGluZyBlbGVtZW50XG52YXIgU1ZHID0gdGhpcy5TVkcgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIGlmIChTVkcuc3VwcG9ydGVkKSB7XG4gICAgZWxlbWVudCA9IG5ldyBTVkcuRG9jKGVsZW1lbnQpXG5cbiAgICBpZighU1ZHLnBhcnNlci5kcmF3KVxuICAgICAgU1ZHLnByZXBhcmUoKVxuXG4gICAgcmV0dXJuIGVsZW1lbnRcbiAgfVxufVxuXG4vLyBEZWZhdWx0IG5hbWVzcGFjZXNcblNWRy5ucyAgICA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZydcblNWRy54bWxucyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zLydcblNWRy54bGluayA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJ1xuU1ZHLnN2Z2pzID0gJ2h0dHA6Ly9zdmdqcy5jb20vc3ZnanMnXG5cbi8vIFN2ZyBzdXBwb3J0IHRlc3RcblNWRy5zdXBwb3J0ZWQgPSAoZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhISBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgJiZcbiAgICAgICAgICEhIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkcubnMsJ3N2ZycpLmNyZWF0ZVNWR1JlY3Rcbn0pKClcblxuLy8gRG9uJ3QgYm90aGVyIHRvIGNvbnRpbnVlIGlmIFNWRyBpcyBub3Qgc3VwcG9ydGVkXG5pZiAoIVNWRy5zdXBwb3J0ZWQpIHJldHVybiBmYWxzZVxuXG4vLyBFbGVtZW50IGlkIHNlcXVlbmNlXG5TVkcuZGlkICA9IDEwMDBcblxuLy8gR2V0IG5leHQgbmFtZWQgZWxlbWVudCBpZFxuU1ZHLmVpZCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuICdTdmdqcycgKyBjYXBpdGFsaXplKG5hbWUpICsgKFNWRy5kaWQrKylcbn1cblxuLy8gTWV0aG9kIGZvciBlbGVtZW50IGNyZWF0aW9uXG5TVkcuY3JlYXRlID0gZnVuY3Rpb24obmFtZSkge1xuICAvLyBjcmVhdGUgZWxlbWVudFxuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh0aGlzLm5zLCBuYW1lKVxuXG4gIC8vIGFwcGx5IHVuaXF1ZSBpZFxuICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLmVpZChuYW1lKSlcblxuICByZXR1cm4gZWxlbWVudFxufVxuXG4vLyBNZXRob2QgZm9yIGV4dGVuZGluZyBvYmplY3RzXG5TVkcuZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG4gIHZhciBtb2R1bGVzLCBtZXRob2RzLCBrZXksIGlcblxuICAvLyBHZXQgbGlzdCBvZiBtb2R1bGVzXG4gIG1vZHVsZXMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cylcblxuICAvLyBHZXQgb2JqZWN0IHdpdGggZXh0ZW5zaW9uc1xuICBtZXRob2RzID0gbW9kdWxlcy5wb3AoKVxuXG4gIGZvciAoaSA9IG1vZHVsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgaWYgKG1vZHVsZXNbaV0pXG4gICAgICBmb3IgKGtleSBpbiBtZXRob2RzKVxuICAgICAgICBtb2R1bGVzW2ldLnByb3RvdHlwZVtrZXldID0gbWV0aG9kc1trZXldXG5cbiAgLy8gTWFrZSBzdXJlIFNWRy5TZXQgaW5oZXJpdHMgYW55IG5ld2x5IGFkZGVkIG1ldGhvZHNcbiAgaWYgKFNWRy5TZXQgJiYgU1ZHLlNldC5pbmhlcml0KVxuICAgIFNWRy5TZXQuaW5oZXJpdCgpXG59XG5cbi8vIEludmVudCBuZXcgZWxlbWVudFxuU1ZHLmludmVudCA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAvLyBDcmVhdGUgZWxlbWVudCBpbml0aWFsaXplclxuICB2YXIgaW5pdGlhbGl6ZXIgPSB0eXBlb2YgY29uZmlnLmNyZWF0ZSA9PSAnZnVuY3Rpb24nID9cbiAgICBjb25maWcuY3JlYXRlIDpcbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBTVkcuY3JlYXRlKGNvbmZpZy5jcmVhdGUpKVxuICAgIH1cblxuICAvLyBJbmhlcml0IHByb3RvdHlwZVxuICBpZiAoY29uZmlnLmluaGVyaXQpXG4gICAgaW5pdGlhbGl6ZXIucHJvdG90eXBlID0gbmV3IGNvbmZpZy5pbmhlcml0XG5cbiAgLy8gRXh0ZW5kIHdpdGggbWV0aG9kc1xuICBpZiAoY29uZmlnLmV4dGVuZClcbiAgICBTVkcuZXh0ZW5kKGluaXRpYWxpemVyLCBjb25maWcuZXh0ZW5kKVxuXG4gIC8vIEF0dGFjaCBjb25zdHJ1Y3QgbWV0aG9kIHRvIHBhcmVudFxuICBpZiAoY29uZmlnLmNvbnN0cnVjdClcbiAgICBTVkcuZXh0ZW5kKGNvbmZpZy5wYXJlbnQgfHwgU1ZHLkNvbnRhaW5lciwgY29uZmlnLmNvbnN0cnVjdClcblxuICByZXR1cm4gaW5pdGlhbGl6ZXJcbn1cblxuLy8gQWRvcHQgZXhpc3Rpbmcgc3ZnIGVsZW1lbnRzXG5TVkcuYWRvcHQgPSBmdW5jdGlvbihub2RlKSB7XG4gIC8vIGNoZWNrIGZvciBwcmVzZW5jZSBvZiBub2RlXG4gIGlmICghbm9kZSkgcmV0dXJuIG51bGxcblxuICAvLyBtYWtlIHN1cmUgYSBub2RlIGlzbid0IGFscmVhZHkgYWRvcHRlZFxuICBpZiAobm9kZS5pbnN0YW5jZSkgcmV0dXJuIG5vZGUuaW5zdGFuY2VcblxuICAvLyBpbml0aWFsaXplIHZhcmlhYmxlc1xuICB2YXIgZWxlbWVudFxuXG4gIC8vIGFkb3B0IHdpdGggZWxlbWVudC1zcGVjaWZpYyBzZXR0aW5nc1xuICBpZiAobm9kZS5ub2RlTmFtZSA9PSAnc3ZnJylcbiAgICBlbGVtZW50ID0gbm9kZS5wYXJlbnROb2RlIGluc3RhbmNlb2YgU1ZHRWxlbWVudCA/IG5ldyBTVkcuTmVzdGVkIDogbmV3IFNWRy5Eb2NcbiAgZWxzZSBpZiAobm9kZS5ub2RlTmFtZSA9PSAnbGluZWFyR3JhZGllbnQnKVxuICAgIGVsZW1lbnQgPSBuZXcgU1ZHLkdyYWRpZW50KCdsaW5lYXInKVxuICBlbHNlIGlmIChub2RlLm5vZGVOYW1lID09ICdyYWRpYWxHcmFkaWVudCcpXG4gICAgZWxlbWVudCA9IG5ldyBTVkcuR3JhZGllbnQoJ3JhZGlhbCcpXG4gIGVsc2UgaWYgKFNWR1tjYXBpdGFsaXplKG5vZGUubm9kZU5hbWUpXSlcbiAgICBlbGVtZW50ID0gbmV3IFNWR1tjYXBpdGFsaXplKG5vZGUubm9kZU5hbWUpXVxuICBlbHNlXG4gICAgZWxlbWVudCA9IG5ldyBTVkcuRWxlbWVudChub2RlKVxuXG4gIC8vIGVuc3VyZSByZWZlcmVuY2VzXG4gIGVsZW1lbnQudHlwZSAgPSBub2RlLm5vZGVOYW1lXG4gIGVsZW1lbnQubm9kZSAgPSBub2RlXG4gIG5vZGUuaW5zdGFuY2UgPSBlbGVtZW50XG5cbiAgLy8gU1ZHLkNsYXNzIHNwZWNpZmljIHByZXBhcmF0aW9uc1xuICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIFNWRy5Eb2MpXG4gICAgZWxlbWVudC5uYW1lc3BhY2UoKS5kZWZzKClcblxuICAvLyBwdWxsIHN2Z2pzIGRhdGEgZnJvbSB0aGUgZG9tIChnZXRBdHRyaWJ1dGVOUyBkb2Vzbid0IHdvcmsgaW4gaHRtbDUpXG4gIGVsZW1lbnQuc2V0RGF0YShKU09OLnBhcnNlKG5vZGUuZ2V0QXR0cmlidXRlKCdzdmdqczpkYXRhJykpIHx8IHt9KVxuXG4gIHJldHVybiBlbGVtZW50XG59XG5cbi8vIEluaXRpYWxpemUgcGFyc2luZyBlbGVtZW50XG5TVkcucHJlcGFyZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBTZWxlY3QgZG9jdW1lbnQgYm9keSBhbmQgY3JlYXRlIGludmlzaWJsZSBzdmcgZWxlbWVudFxuICB2YXIgYm9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JylbMF1cbiAgICAsIGRyYXcgPSAoYm9keSA/IG5ldyBTVkcuRG9jKGJvZHkpIDogIG5ldyBTVkcuRG9jKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkubmVzdGVkKCkpLnNpemUoMiwgMClcblxuICAvLyBDcmVhdGUgcGFyc2VyIG9iamVjdFxuICBTVkcucGFyc2VyID0ge1xuICAgIGJvZHk6IGJvZHkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XG4gICwgZHJhdzogZHJhdy5zdHlsZSgnb3BhY2l0eTowO3Bvc2l0aW9uOmZpeGVkO2xlZnQ6MTAwJTt0b3A6MTAwJTtvdmVyZmxvdzpoaWRkZW4nKVxuICAsIHBvbHk6IGRyYXcucG9seWxpbmUoKS5ub2RlXG4gICwgcGF0aDogZHJhdy5wYXRoKCkubm9kZVxuICAsIG5hdGl2ZTogU1ZHLmNyZWF0ZSgnc3ZnJylcbiAgfVxufVxuXG5TVkcucGFyc2VyID0ge1xuICBuYXRpdmU6IFNWRy5jcmVhdGUoJ3N2ZycpXG59XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbigpIHtcbiAgaWYoIVNWRy5wYXJzZXIuZHJhdylcbiAgICBTVkcucHJlcGFyZSgpXG59LCBmYWxzZSlcblxuLy8gU3RvcmFnZSBmb3IgcmVndWxhciBleHByZXNzaW9uc1xuU1ZHLnJlZ2V4ID0ge1xuICAvLyBQYXJzZSB1bml0IHZhbHVlXG4gIG51bWJlckFuZFVuaXQ6ICAgIC9eKFsrLV0/KFxcZCsoXFwuXFxkKik/fFxcLlxcZCspKGVbKy1dP1xcZCspPykoW2EteiVdKikkL2lcblxuICAvLyBQYXJzZSBoZXggdmFsdWVcbiwgaGV4OiAgICAgICAgICAgICAgL14jPyhbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KSQvaVxuXG4gIC8vIFBhcnNlIHJnYiB2YWx1ZVxuLCByZ2I6ICAgICAgICAgICAgICAvcmdiXFwoKFxcZCspLChcXGQrKSwoXFxkKylcXCkvXG5cbiAgLy8gUGFyc2UgcmVmZXJlbmNlIGlkXG4sIHJlZmVyZW5jZTogICAgICAgIC8jKFthLXowLTlcXC1fXSspL2lcblxuICAvLyBQYXJzZSBtYXRyaXggd3JhcHBlclxuLCBtYXRyaXg6ICAgICAgICAgICAvbWF0cml4XFwofFxcKS9nXG5cbiAgLy8gRWxlbWVudHMgb2YgYSBtYXRyaXhcbiwgbWF0cml4RWxlbWVudHM6ICAgLywqXFxzK3wsL1xuXG4gIC8vIFdoaXRlc3BhY2Vcbiwgd2hpdGVzcGFjZTogICAgICAgL1xccy9nXG5cbiAgLy8gVGVzdCBoZXggdmFsdWVcbiwgaXNIZXg6ICAgICAgICAgICAgL14jW2EtZjAtOV17Myw2fSQvaVxuXG4gIC8vIFRlc3QgcmdiIHZhbHVlXG4sIGlzUmdiOiAgICAgICAgICAgIC9ecmdiXFwoL1xuXG4gIC8vIFRlc3QgY3NzIGRlY2xhcmF0aW9uXG4sIGlzQ3NzOiAgICAgICAgICAgIC9bXjpdKzpbXjtdKzs/L1xuXG4gIC8vIFRlc3QgZm9yIGJsYW5rIHN0cmluZ1xuLCBpc0JsYW5rOiAgICAgICAgICAvXihcXHMrKT8kL1xuXG4gIC8vIFRlc3QgZm9yIG51bWVyaWMgc3RyaW5nXG4sIGlzTnVtYmVyOiAgICAgICAgIC9eWystXT8oXFxkKyhcXC5cXGQqKT98XFwuXFxkKykoZVsrLV0/XFxkKyk/JC9pXG5cbiAgLy8gVGVzdCBmb3IgcGVyY2VudCB2YWx1ZVxuLCBpc1BlcmNlbnQ6ICAgICAgICAvXi0/W1xcZFxcLl0rJSQvXG5cbiAgLy8gVGVzdCBmb3IgaW1hZ2UgdXJsXG4sIGlzSW1hZ2U6ICAgICAgICAgIC9cXC4oanBnfGpwZWd8cG5nfGdpZnxzdmcpKFxcP1tePV0rLiopPy9pXG5cbiAgLy8gVGhlIGZvbGxvd2luZyByZWdleCBhcmUgdXNlZCB0byBwYXJzZSB0aGUgZCBhdHRyaWJ1dGUgb2YgYSBwYXRoXG5cbiAgLy8gUmVwbGFjZXMgYWxsIG5lZ2F0aXZlIGV4cG9uZW50c1xuLCBuZWdFeHA6ICAgICAgICAgICAvZVxcLS9naVxuXG4gIC8vIFJlcGxhY2VzIGFsbCBjb21tYVxuLCBjb21tYTogICAgICAgICAgICAvLC9nXG5cbiAgLy8gUmVwbGFjZXMgYWxsIGh5cGhlbnNcbiwgaHlwaGVuOiAgICAgICAgICAgL1xcLS9nXG5cbiAgLy8gUmVwbGFjZXMgYW5kIHRlc3RzIGZvciBhbGwgcGF0aCBsZXR0ZXJzXG4sIHBhdGhMZXR0ZXJzOiAgICAgIC9bTUxIVkNTUVRBWl0vZ2lcblxuICAvLyB5ZXMgd2UgbmVlZCB0aGlzIG9uZSwgdG9vXG4sIGlzUGF0aExldHRlcjogICAgIC9bTUxIVkNTUVRBWl0vaVxuXG4gIC8vIHNwbGl0IGF0IHdoaXRlc3BhY2VzXG4sIHdoaXRlc3BhY2VzOiAgICAgIC9cXHMrL1xuXG4gIC8vIG1hdGNoZXMgWFxuLCBYOiAgICAgICAgICAgICAgICAvWC9nXG59XG5cblNWRy51dGlscyA9IHtcbiAgLy8gTWFwIGZ1bmN0aW9uXG4gIG1hcDogZnVuY3Rpb24oYXJyYXksIGJsb2NrKSB7XG4gICAgdmFyIGlcbiAgICAgICwgaWwgPSBhcnJheS5sZW5ndGhcbiAgICAgICwgcmVzdWx0ID0gW11cblxuICAgIGZvciAoaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgcmVzdWx0LnB1c2goYmxvY2soYXJyYXlbaV0pKVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLy8gRmlsdGVyIGZ1bmN0aW9uXG4sIGZpbHRlcjogZnVuY3Rpb24oYXJyYXksIGJsb2NrKSB7XG4gICAgdmFyIGlcbiAgICAgICwgaWwgPSBhcnJheS5sZW5ndGhcbiAgICAgICwgcmVzdWx0ID0gW11cblxuICAgIGZvciAoaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgaWYgKGJsb2NrKGFycmF5W2ldKSlcbiAgICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaV0pXG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvLyBEZWdyZWVzIHRvIHJhZGlhbnNcbiwgcmFkaWFuczogZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkICUgMzYwICogTWF0aC5QSSAvIDE4MFxuICB9XG5cbiAgLy8gUmFkaWFucyB0byBkZWdyZWVzXG4sIGRlZ3JlZXM6IGZ1bmN0aW9uKHIpIHtcbiAgICByZXR1cm4gciAqIDE4MCAvIE1hdGguUEkgJSAzNjBcbiAgfVxuXG4sIGZpbHRlclNWR0VsZW1lbnRzOiBmdW5jdGlvbihub2Rlcykge1xuICAgIHJldHVybiB0aGlzLmZpbHRlciggbm9kZXMsIGZ1bmN0aW9uKGVsKSB7IHJldHVybiBlbCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQgfSlcbiAgfVxuXG59XG5cblNWRy5kZWZhdWx0cyA9IHtcbiAgLy8gRGVmYXVsdCBhdHRyaWJ1dGUgdmFsdWVzXG4gIGF0dHJzOiB7XG4gICAgLy8gZmlsbCBhbmQgc3Ryb2tlXG4gICAgJ2ZpbGwtb3BhY2l0eSc6ICAgICAxXG4gICwgJ3N0cm9rZS1vcGFjaXR5JzogICAxXG4gICwgJ3N0cm9rZS13aWR0aCc6ICAgICAwXG4gICwgJ3N0cm9rZS1saW5lam9pbic6ICAnbWl0ZXInXG4gICwgJ3N0cm9rZS1saW5lY2FwJzogICAnYnV0dCdcbiAgLCBmaWxsOiAgICAgICAgICAgICAgICcjMDAwMDAwJ1xuICAsIHN0cm9rZTogICAgICAgICAgICAgJyMwMDAwMDAnXG4gICwgb3BhY2l0eTogICAgICAgICAgICAxXG4gICAgLy8gcG9zaXRpb25cbiAgLCB4OiAgICAgICAgICAgICAgICAgIDBcbiAgLCB5OiAgICAgICAgICAgICAgICAgIDBcbiAgLCBjeDogICAgICAgICAgICAgICAgIDBcbiAgLCBjeTogICAgICAgICAgICAgICAgIDBcbiAgICAvLyBzaXplXG4gICwgd2lkdGg6ICAgICAgICAgICAgICAwXG4gICwgaGVpZ2h0OiAgICAgICAgICAgICAwXG4gICAgLy8gcmFkaXVzXG4gICwgcjogICAgICAgICAgICAgICAgICAwXG4gICwgcng6ICAgICAgICAgICAgICAgICAwXG4gICwgcnk6ICAgICAgICAgICAgICAgICAwXG4gICAgLy8gZ3JhZGllbnRcbiAgLCBvZmZzZXQ6ICAgICAgICAgICAgIDBcbiAgLCAnc3RvcC1vcGFjaXR5JzogICAgIDFcbiAgLCAnc3RvcC1jb2xvcic6ICAgICAgICcjMDAwMDAwJ1xuICAgIC8vIHRleHRcbiAgLCAnZm9udC1zaXplJzogICAgICAgIDE2XG4gICwgJ2ZvbnQtZmFtaWx5JzogICAgICAnSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZidcbiAgLCAndGV4dC1hbmNob3InOiAgICAgICdzdGFydCdcbiAgfVxuXG59XG4vLyBNb2R1bGUgZm9yIGNvbG9yIGNvbnZlcnRpb25zXG5TVkcuQ29sb3IgPSBmdW5jdGlvbihjb2xvcikge1xuICB2YXIgbWF0Y2hcblxuICAvLyBpbml0aWFsaXplIGRlZmF1bHRzXG4gIHRoaXMuciA9IDBcbiAgdGhpcy5nID0gMFxuICB0aGlzLmIgPSAwXG5cbiAgaWYoIWNvbG9yKSByZXR1cm5cblxuICAvLyBwYXJzZSBjb2xvclxuICBpZiAodHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJykge1xuICAgIGlmIChTVkcucmVnZXguaXNSZ2IudGVzdChjb2xvcikpIHtcbiAgICAgIC8vIGdldCByZ2IgdmFsdWVzXG4gICAgICBtYXRjaCA9IFNWRy5yZWdleC5yZ2IuZXhlYyhjb2xvci5yZXBsYWNlKC9cXHMvZywnJykpXG5cbiAgICAgIC8vIHBhcnNlIG51bWVyaWMgdmFsdWVzXG4gICAgICB0aGlzLnIgPSBwYXJzZUludChtYXRjaFsxXSlcbiAgICAgIHRoaXMuZyA9IHBhcnNlSW50KG1hdGNoWzJdKVxuICAgICAgdGhpcy5iID0gcGFyc2VJbnQobWF0Y2hbM10pXG5cbiAgICB9IGVsc2UgaWYgKFNWRy5yZWdleC5pc0hleC50ZXN0KGNvbG9yKSkge1xuICAgICAgLy8gZ2V0IGhleCB2YWx1ZXNcbiAgICAgIG1hdGNoID0gU1ZHLnJlZ2V4LmhleC5leGVjKGZ1bGxIZXgoY29sb3IpKVxuXG4gICAgICAvLyBwYXJzZSBudW1lcmljIHZhbHVlc1xuICAgICAgdGhpcy5yID0gcGFyc2VJbnQobWF0Y2hbMV0sIDE2KVxuICAgICAgdGhpcy5nID0gcGFyc2VJbnQobWF0Y2hbMl0sIDE2KVxuICAgICAgdGhpcy5iID0gcGFyc2VJbnQobWF0Y2hbM10sIDE2KVxuXG4gICAgfVxuXG4gIH0gZWxzZSBpZiAodHlwZW9mIGNvbG9yID09PSAnb2JqZWN0Jykge1xuICAgIHRoaXMuciA9IGNvbG9yLnJcbiAgICB0aGlzLmcgPSBjb2xvci5nXG4gICAgdGhpcy5iID0gY29sb3IuYlxuXG4gIH1cblxufVxuXG5TVkcuZXh0ZW5kKFNWRy5Db2xvciwge1xuICAvLyBEZWZhdWx0IHRvIGhleCBjb252ZXJzaW9uXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50b0hleCgpXG4gIH1cbiAgLy8gQnVpbGQgaGV4IHZhbHVlXG4sIHRvSGV4OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJyMnXG4gICAgICArIGNvbXBUb0hleCh0aGlzLnIpXG4gICAgICArIGNvbXBUb0hleCh0aGlzLmcpXG4gICAgICArIGNvbXBUb0hleCh0aGlzLmIpXG4gIH1cbiAgLy8gQnVpbGQgcmdiIHZhbHVlXG4sIHRvUmdiOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJ3JnYignICsgW3RoaXMuciwgdGhpcy5nLCB0aGlzLmJdLmpvaW4oKSArICcpJ1xuICB9XG4gIC8vIENhbGN1bGF0ZSB0cnVlIGJyaWdodG5lc3NcbiwgYnJpZ2h0bmVzczogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICh0aGlzLnIgLyAyNTUgKiAwLjMwKVxuICAgICAgICAgKyAodGhpcy5nIC8gMjU1ICogMC41OSlcbiAgICAgICAgICsgKHRoaXMuYiAvIDI1NSAqIDAuMTEpXG4gIH1cbiAgLy8gTWFrZSBjb2xvciBtb3JwaGFibGVcbiwgbW9ycGg6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTVkcuQ29sb3IoY29sb3IpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG4gIC8vIEdldCBtb3JwaGVkIGNvbG9yIGF0IGdpdmVuIHBvc2l0aW9uXG4sIGF0OiBmdW5jdGlvbihwb3MpIHtcbiAgICAvLyBtYWtlIHN1cmUgYSBkZXN0aW5hdGlvbiBpcyBkZWZpbmVkXG4gICAgaWYgKCF0aGlzLmRlc3RpbmF0aW9uKSByZXR1cm4gdGhpc1xuXG4gICAgLy8gbm9ybWFsaXNlIHBvc1xuICAgIHBvcyA9IHBvcyA8IDAgPyAwIDogcG9zID4gMSA/IDEgOiBwb3NcblxuICAgIC8vIGdlbmVyYXRlIG1vcnBoZWQgY29sb3JcbiAgICByZXR1cm4gbmV3IFNWRy5Db2xvcih7XG4gICAgICByOiB+fih0aGlzLnIgKyAodGhpcy5kZXN0aW5hdGlvbi5yIC0gdGhpcy5yKSAqIHBvcylcbiAgICAsIGc6IH5+KHRoaXMuZyArICh0aGlzLmRlc3RpbmF0aW9uLmcgLSB0aGlzLmcpICogcG9zKVxuICAgICwgYjogfn4odGhpcy5iICsgKHRoaXMuZGVzdGluYXRpb24uYiAtIHRoaXMuYikgKiBwb3MpXG4gICAgfSlcbiAgfVxuXG59KVxuXG4vLyBUZXN0ZXJzXG5cbi8vIFRlc3QgaWYgZ2l2ZW4gdmFsdWUgaXMgYSBjb2xvciBzdHJpbmdcblNWRy5Db2xvci50ZXN0ID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgY29sb3IgKz0gJydcbiAgcmV0dXJuIFNWRy5yZWdleC5pc0hleC50ZXN0KGNvbG9yKVxuICAgICAgfHwgU1ZHLnJlZ2V4LmlzUmdiLnRlc3QoY29sb3IpXG59XG5cbi8vIFRlc3QgaWYgZ2l2ZW4gdmFsdWUgaXMgYSByZ2Igb2JqZWN0XG5TVkcuQ29sb3IuaXNSZ2IgPSBmdW5jdGlvbihjb2xvcikge1xuICByZXR1cm4gY29sb3IgJiYgdHlwZW9mIGNvbG9yLnIgPT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICYmIHR5cGVvZiBjb2xvci5nID09ICdudW1iZXInXG4gICAgICAgICAgICAgICAmJiB0eXBlb2YgY29sb3IuYiA9PSAnbnVtYmVyJ1xufVxuXG4vLyBUZXN0IGlmIGdpdmVuIHZhbHVlIGlzIGEgY29sb3JcblNWRy5Db2xvci5pc0NvbG9yID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgcmV0dXJuIFNWRy5Db2xvci5pc1JnYihjb2xvcikgfHwgU1ZHLkNvbG9yLnRlc3QoY29sb3IpXG59XG4vLyBNb2R1bGUgZm9yIGFycmF5IGNvbnZlcnNpb25cblNWRy5BcnJheSA9IGZ1bmN0aW9uKGFycmF5LCBmYWxsYmFjaykge1xuICBhcnJheSA9IChhcnJheSB8fCBbXSkudmFsdWVPZigpXG5cbiAgLy8gaWYgYXJyYXkgaXMgZW1wdHkgYW5kIGZhbGxiYWNrIGlzIHByb3ZpZGVkLCB1c2UgZmFsbGJhY2tcbiAgaWYgKGFycmF5Lmxlbmd0aCA9PSAwICYmIGZhbGxiYWNrKVxuICAgIGFycmF5ID0gZmFsbGJhY2sudmFsdWVPZigpXG5cbiAgLy8gcGFyc2UgYXJyYXlcbiAgdGhpcy52YWx1ZSA9IHRoaXMucGFyc2UoYXJyYXkpXG59XG5cblNWRy5leHRlbmQoU1ZHLkFycmF5LCB7XG4gIC8vIE1ha2UgYXJyYXkgbW9ycGhhYmxlXG4gIG1vcnBoOiBmdW5jdGlvbihhcnJheSkge1xuICAgIHRoaXMuZGVzdGluYXRpb24gPSB0aGlzLnBhcnNlKGFycmF5KVxuXG4gICAgLy8gbm9ybWFsaXplIGxlbmd0aCBvZiBhcnJheXNcbiAgICBpZiAodGhpcy52YWx1ZS5sZW5ndGggIT0gdGhpcy5kZXN0aW5hdGlvbi5sZW5ndGgpIHtcbiAgICAgIHZhciBsYXN0VmFsdWUgICAgICAgPSB0aGlzLnZhbHVlW3RoaXMudmFsdWUubGVuZ3RoIC0gMV1cbiAgICAgICAgLCBsYXN0RGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uW3RoaXMuZGVzdGluYXRpb24ubGVuZ3RoIC0gMV1cblxuICAgICAgd2hpbGUodGhpcy52YWx1ZS5sZW5ndGggPiB0aGlzLmRlc3RpbmF0aW9uLmxlbmd0aClcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5wdXNoKGxhc3REZXN0aW5hdGlvbilcbiAgICAgIHdoaWxlKHRoaXMudmFsdWUubGVuZ3RoIDwgdGhpcy5kZXN0aW5hdGlvbi5sZW5ndGgpXG4gICAgICAgIHRoaXMudmFsdWUucHVzaChsYXN0VmFsdWUpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuICAvLyBDbGVhbiB1cCBhbnkgZHVwbGljYXRlIHBvaW50c1xuLCBzZXR0bGU6IGZ1bmN0aW9uKCkge1xuICAgIC8vIGZpbmQgYWxsIHVuaXF1ZSB2YWx1ZXNcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSB0aGlzLnZhbHVlLmxlbmd0aCwgc2VlbiA9IFtdOyBpIDwgaWw7IGkrKylcbiAgICAgIGlmIChzZWVuLmluZGV4T2YodGhpcy52YWx1ZVtpXSkgPT0gLTEpXG4gICAgICAgIHNlZW4ucHVzaCh0aGlzLnZhbHVlW2ldKVxuXG4gICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgIHJldHVybiB0aGlzLnZhbHVlID0gc2VlblxuICB9XG4gIC8vIEdldCBtb3JwaGVkIGFycmF5IGF0IGdpdmVuIHBvc2l0aW9uXG4sIGF0OiBmdW5jdGlvbihwb3MpIHtcbiAgICAvLyBtYWtlIHN1cmUgYSBkZXN0aW5hdGlvbiBpcyBkZWZpbmVkXG4gICAgaWYgKCF0aGlzLmRlc3RpbmF0aW9uKSByZXR1cm4gdGhpc1xuXG4gICAgLy8gZ2VuZXJhdGUgbW9ycGhlZCBhcnJheVxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHRoaXMudmFsdWUubGVuZ3RoLCBhcnJheSA9IFtdOyBpIDwgaWw7IGkrKylcbiAgICAgIGFycmF5LnB1c2godGhpcy52YWx1ZVtpXSArICh0aGlzLmRlc3RpbmF0aW9uW2ldIC0gdGhpcy52YWx1ZVtpXSkgKiBwb3MpXG5cbiAgICByZXR1cm4gbmV3IFNWRy5BcnJheShhcnJheSlcbiAgfVxuICAvLyBDb252ZXJ0IGFycmF5IHRvIHN0cmluZ1xuLCB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUuam9pbignICcpXG4gIH1cbiAgLy8gUmVhbCB2YWx1ZVxuLCB2YWx1ZU9mOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZVxuICB9XG4gIC8vIFBhcnNlIHdoaXRlc3BhY2Ugc2VwYXJhdGVkIHN0cmluZ1xuLCBwYXJzZTogZnVuY3Rpb24oYXJyYXkpIHtcbiAgICBhcnJheSA9IGFycmF5LnZhbHVlT2YoKVxuXG4gICAgLy8gaWYgYWxyZWFkeSBpcyBhbiBhcnJheSwgbm8gbmVlZCB0byBwYXJzZSBpdFxuICAgIGlmIChBcnJheS5pc0FycmF5KGFycmF5KSkgcmV0dXJuIGFycmF5XG5cbiAgICByZXR1cm4gdGhpcy5zcGxpdChhcnJheSlcbiAgfVxuICAvLyBTdHJpcCB1bm5lY2Vzc2FyeSB3aGl0ZXNwYWNlXG4sIHNwbGl0OiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnRyaW0oKS5zcGxpdCgvXFxzKy8pXG4gIH1cbiAgLy8gUmV2ZXJzZSBhcnJheVxuLCByZXZlcnNlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnZhbHVlLnJldmVyc2UoKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG59KVxuLy8gUG9seSBwb2ludHMgYXJyYXlcblNWRy5Qb2ludEFycmF5ID0gZnVuY3Rpb24oYXJyYXksIGZhbGxiYWNrKSB7XG4gIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBhcnJheSwgZmFsbGJhY2sgfHwgW1swLDBdXSlcbn1cblxuLy8gSW5oZXJpdCBmcm9tIFNWRy5BcnJheVxuU1ZHLlBvaW50QXJyYXkucHJvdG90eXBlID0gbmV3IFNWRy5BcnJheVxuXG5TVkcuZXh0ZW5kKFNWRy5Qb2ludEFycmF5LCB7XG4gIC8vIENvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAvLyBjb252ZXJ0IHRvIGEgcG9seSBwb2ludCBzdHJpbmdcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSB0aGlzLnZhbHVlLmxlbmd0aCwgYXJyYXkgPSBbXTsgaSA8IGlsOyBpKyspXG4gICAgICBhcnJheS5wdXNoKHRoaXMudmFsdWVbaV0uam9pbignLCcpKVxuXG4gICAgcmV0dXJuIGFycmF5LmpvaW4oJyAnKVxuICB9XG4gIC8vIENvbnZlcnQgYXJyYXkgdG8gbGluZSBvYmplY3RcbiwgdG9MaW5lOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDE6IHRoaXMudmFsdWVbMF1bMF1cbiAgICAsIHkxOiB0aGlzLnZhbHVlWzBdWzFdXG4gICAgLCB4MjogdGhpcy52YWx1ZVsxXVswXVxuICAgICwgeTI6IHRoaXMudmFsdWVbMV1bMV1cbiAgICB9XG4gIH1cbiAgLy8gR2V0IG1vcnBoZWQgYXJyYXkgYXQgZ2l2ZW4gcG9zaXRpb25cbiwgYXQ6IGZ1bmN0aW9uKHBvcykge1xuICAgIC8vIG1ha2Ugc3VyZSBhIGRlc3RpbmF0aW9uIGlzIGRlZmluZWRcbiAgICBpZiAoIXRoaXMuZGVzdGluYXRpb24pIHJldHVybiB0aGlzXG5cbiAgICAvLyBnZW5lcmF0ZSBtb3JwaGVkIHBvaW50IHN0cmluZ1xuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHRoaXMudmFsdWUubGVuZ3RoLCBhcnJheSA9IFtdOyBpIDwgaWw7IGkrKylcbiAgICAgIGFycmF5LnB1c2goW1xuICAgICAgICB0aGlzLnZhbHVlW2ldWzBdICsgKHRoaXMuZGVzdGluYXRpb25baV1bMF0gLSB0aGlzLnZhbHVlW2ldWzBdKSAqIHBvc1xuICAgICAgLCB0aGlzLnZhbHVlW2ldWzFdICsgKHRoaXMuZGVzdGluYXRpb25baV1bMV0gLSB0aGlzLnZhbHVlW2ldWzFdKSAqIHBvc1xuICAgICAgXSlcblxuICAgIHJldHVybiBuZXcgU1ZHLlBvaW50QXJyYXkoYXJyYXkpXG4gIH1cbiAgLy8gUGFyc2UgcG9pbnQgc3RyaW5nXG4sIHBhcnNlOiBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciBwb2ludHMgPSBbXVxuXG4gICAgYXJyYXkgPSBhcnJheS52YWx1ZU9mKClcblxuICAgIC8vIGlmIGFscmVhZHkgaXMgYW4gYXJyYXksIG5vIG5lZWQgdG8gcGFyc2UgaXRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJheSkpIHJldHVybiBhcnJheVxuXG4gICAgLy8gcGFyc2UgcG9pbnRzXG4gICAgYXJyYXkgPSBhcnJheS50cmltKCkuc3BsaXQoL1xccyt8LC8pXG5cbiAgICAvLyB2YWxpZGF0ZSBwb2ludHMgLSBodHRwczovL3N2Z3dnLm9yZy9zdmcyLWRyYWZ0L3NoYXBlcy5odG1sI0RhdGFUeXBlUG9pbnRzXG4gICAgLy8gT2RkIG51bWJlciBvZiBjb29yZGluYXRlcyBpcyBhbiBlcnJvci4gSW4gc3VjaCBjYXNlcywgZHJvcCB0aGUgbGFzdCBvZGQgY29vcmRpbmF0ZS5cbiAgICBpZiAoYXJyYXkubGVuZ3RoICUgMiAhPT0gMCkgYXJyYXkucG9wKClcblxuICAgIC8vIHdyYXAgcG9pbnRzIGluIHR3by10dXBsZXMgYW5kIHBhcnNlIHBvaW50cyBhcyBmbG9hdHNcbiAgICBmb3IodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkgPSBpICsgMilcbiAgICAgIHBvaW50cy5wdXNoKFsgcGFyc2VGbG9hdChhcnJheVtpXSksIHBhcnNlRmxvYXQoYXJyYXlbaSsxXSkgXSlcblxuICAgIHJldHVybiBwb2ludHNcbiAgfVxuICAvLyBNb3ZlIHBvaW50IHN0cmluZ1xuLCBtb3ZlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIGJveCA9IHRoaXMuYmJveCgpXG5cbiAgICAvLyBnZXQgcmVsYXRpdmUgb2Zmc2V0XG4gICAgeCAtPSBib3gueFxuICAgIHkgLT0gYm94LnlcblxuICAgIC8vIG1vdmUgZXZlcnkgcG9pbnRcbiAgICBpZiAoIWlzTmFOKHgpICYmICFpc05hTih5KSlcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnZhbHVlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICB0aGlzLnZhbHVlW2ldID0gW3RoaXMudmFsdWVbaV1bMF0gKyB4LCB0aGlzLnZhbHVlW2ldWzFdICsgeV1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cbiAgLy8gUmVzaXplIHBvbHkgc3RyaW5nXG4sIHNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgaSwgYm94ID0gdGhpcy5iYm94KClcblxuICAgIC8vIHJlY2FsY3VsYXRlIHBvc2l0aW9uIG9mIGFsbCBwb2ludHMgYWNjb3JkaW5nIHRvIG5ldyBzaXplXG4gICAgZm9yIChpID0gdGhpcy52YWx1ZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy52YWx1ZVtpXVswXSA9ICgodGhpcy52YWx1ZVtpXVswXSAtIGJveC54KSAqIHdpZHRoKSAgLyBib3gud2lkdGggICsgYm94LnhcbiAgICAgIHRoaXMudmFsdWVbaV1bMV0gPSAoKHRoaXMudmFsdWVbaV1bMV0gLSBib3gueSkgKiBoZWlnaHQpIC8gYm94LmhlaWdodCArIGJveC55XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuICAvLyBHZXQgYm91bmRpbmcgYm94IG9mIHBvaW50c1xuLCBiYm94OiBmdW5jdGlvbigpIHtcbiAgICBTVkcucGFyc2VyLnBvbHkuc2V0QXR0cmlidXRlKCdwb2ludHMnLCB0aGlzLnRvU3RyaW5nKCkpXG5cbiAgICByZXR1cm4gU1ZHLnBhcnNlci5wb2x5LmdldEJCb3goKVxuICB9XG5cbn0pXG4vLyBQYXRoIHBvaW50cyBhcnJheVxuU1ZHLlBhdGhBcnJheSA9IGZ1bmN0aW9uKGFycmF5LCBmYWxsYmFjaykge1xuICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgYXJyYXksIGZhbGxiYWNrIHx8IFtbJ00nLCAwLCAwXV0pXG59XG5cbi8vIEluaGVyaXQgZnJvbSBTVkcuQXJyYXlcblNWRy5QYXRoQXJyYXkucHJvdG90eXBlID0gbmV3IFNWRy5BcnJheVxuXG5TVkcuZXh0ZW5kKFNWRy5QYXRoQXJyYXksIHtcbiAgLy8gQ29udmVydCBhcnJheSB0byBzdHJpbmdcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcnJheVRvU3RyaW5nKHRoaXMudmFsdWUpXG4gIH1cbiAgLy8gTW92ZSBwYXRoIHN0cmluZ1xuLCBtb3ZlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgLy8gZ2V0IGJvdW5kaW5nIGJveCBvZiBjdXJyZW50IHNpdHVhdGlvblxuICAgIHZhciBib3ggPSB0aGlzLmJib3goKVxuXG4gICAgLy8gZ2V0IHJlbGF0aXZlIG9mZnNldFxuICAgIHggLT0gYm94LnhcbiAgICB5IC09IGJveC55XG5cbiAgICBpZiAoIWlzTmFOKHgpICYmICFpc05hTih5KSkge1xuICAgICAgLy8gbW92ZSBldmVyeSBwb2ludFxuICAgICAgZm9yICh2YXIgbCwgaSA9IHRoaXMudmFsdWUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbCA9IHRoaXMudmFsdWVbaV1bMF1cblxuICAgICAgICBpZiAobCA9PSAnTScgfHwgbCA9PSAnTCcgfHwgbCA9PSAnVCcpICB7XG4gICAgICAgICAgdGhpcy52YWx1ZVtpXVsxXSArPSB4XG4gICAgICAgICAgdGhpcy52YWx1ZVtpXVsyXSArPSB5XG5cbiAgICAgICAgfSBlbHNlIGlmIChsID09ICdIJykgIHtcbiAgICAgICAgICB0aGlzLnZhbHVlW2ldWzFdICs9IHhcblxuICAgICAgICB9IGVsc2UgaWYgKGwgPT0gJ1YnKSAge1xuICAgICAgICAgIHRoaXMudmFsdWVbaV1bMV0gKz0geVxuXG4gICAgICAgIH0gZWxzZSBpZiAobCA9PSAnQycgfHwgbCA9PSAnUycgfHwgbCA9PSAnUScpICB7XG4gICAgICAgICAgdGhpcy52YWx1ZVtpXVsxXSArPSB4XG4gICAgICAgICAgdGhpcy52YWx1ZVtpXVsyXSArPSB5XG4gICAgICAgICAgdGhpcy52YWx1ZVtpXVszXSArPSB4XG4gICAgICAgICAgdGhpcy52YWx1ZVtpXVs0XSArPSB5XG5cbiAgICAgICAgICBpZiAobCA9PSAnQycpICB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlW2ldWzVdICs9IHhcbiAgICAgICAgICAgIHRoaXMudmFsdWVbaV1bNl0gKz0geVxuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKGwgPT0gJ0EnKSAge1xuICAgICAgICAgIHRoaXMudmFsdWVbaV1bNl0gKz0geFxuICAgICAgICAgIHRoaXMudmFsdWVbaV1bN10gKz0geVxuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG4gIC8vIFJlc2l6ZSBwYXRoIHN0cmluZ1xuLCBzaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgLy8gZ2V0IGJvdW5kaW5nIGJveCBvZiBjdXJyZW50IHNpdHVhdGlvblxuICAgIHZhciBpLCBsLCBib3ggPSB0aGlzLmJib3goKVxuXG4gICAgLy8gcmVjYWxjdWxhdGUgcG9zaXRpb24gb2YgYWxsIHBvaW50cyBhY2NvcmRpbmcgdG8gbmV3IHNpemVcbiAgICBmb3IgKGkgPSB0aGlzLnZhbHVlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBsID0gdGhpcy52YWx1ZVtpXVswXVxuXG4gICAgICBpZiAobCA9PSAnTScgfHwgbCA9PSAnTCcgfHwgbCA9PSAnVCcpICB7XG4gICAgICAgIHRoaXMudmFsdWVbaV1bMV0gPSAoKHRoaXMudmFsdWVbaV1bMV0gLSBib3gueCkgKiB3aWR0aCkgIC8gYm94LndpZHRoICArIGJveC54XG4gICAgICAgIHRoaXMudmFsdWVbaV1bMl0gPSAoKHRoaXMudmFsdWVbaV1bMl0gLSBib3gueSkgKiBoZWlnaHQpIC8gYm94LmhlaWdodCArIGJveC55XG5cbiAgICAgIH0gZWxzZSBpZiAobCA9PSAnSCcpICB7XG4gICAgICAgIHRoaXMudmFsdWVbaV1bMV0gPSAoKHRoaXMudmFsdWVbaV1bMV0gLSBib3gueCkgKiB3aWR0aCkgIC8gYm94LndpZHRoICArIGJveC54XG5cbiAgICAgIH0gZWxzZSBpZiAobCA9PSAnVicpICB7XG4gICAgICAgIHRoaXMudmFsdWVbaV1bMV0gPSAoKHRoaXMudmFsdWVbaV1bMV0gLSBib3gueSkgKiBoZWlnaHQpIC8gYm94LmhlaWdodCArIGJveC55XG5cbiAgICAgIH0gZWxzZSBpZiAobCA9PSAnQycgfHwgbCA9PSAnUycgfHwgbCA9PSAnUScpICB7XG4gICAgICAgIHRoaXMudmFsdWVbaV1bMV0gPSAoKHRoaXMudmFsdWVbaV1bMV0gLSBib3gueCkgKiB3aWR0aCkgIC8gYm94LndpZHRoICArIGJveC54XG4gICAgICAgIHRoaXMudmFsdWVbaV1bMl0gPSAoKHRoaXMudmFsdWVbaV1bMl0gLSBib3gueSkgKiBoZWlnaHQpIC8gYm94LmhlaWdodCArIGJveC55XG4gICAgICAgIHRoaXMudmFsdWVbaV1bM10gPSAoKHRoaXMudmFsdWVbaV1bM10gLSBib3gueCkgKiB3aWR0aCkgIC8gYm94LndpZHRoICArIGJveC54XG4gICAgICAgIHRoaXMudmFsdWVbaV1bNF0gPSAoKHRoaXMudmFsdWVbaV1bNF0gLSBib3gueSkgKiBoZWlnaHQpIC8gYm94LmhlaWdodCArIGJveC55XG5cbiAgICAgICAgaWYgKGwgPT0gJ0MnKSAge1xuICAgICAgICAgIHRoaXMudmFsdWVbaV1bNV0gPSAoKHRoaXMudmFsdWVbaV1bNV0gLSBib3gueCkgKiB3aWR0aCkgIC8gYm94LndpZHRoICArIGJveC54XG4gICAgICAgICAgdGhpcy52YWx1ZVtpXVs2XSA9ICgodGhpcy52YWx1ZVtpXVs2XSAtIGJveC55KSAqIGhlaWdodCkgLyBib3guaGVpZ2h0ICsgYm94LnlcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYgKGwgPT0gJ0EnKSAge1xuICAgICAgICAvLyByZXNpemUgcmFkaWlcbiAgICAgICAgdGhpcy52YWx1ZVtpXVsxXSA9ICh0aGlzLnZhbHVlW2ldWzFdICogd2lkdGgpICAvIGJveC53aWR0aFxuICAgICAgICB0aGlzLnZhbHVlW2ldWzJdID0gKHRoaXMudmFsdWVbaV1bMl0gKiBoZWlnaHQpIC8gYm94LmhlaWdodFxuXG4gICAgICAgIC8vIG1vdmUgcG9zaXRpb24gdmFsdWVzXG4gICAgICAgIHRoaXMudmFsdWVbaV1bNl0gPSAoKHRoaXMudmFsdWVbaV1bNl0gLSBib3gueCkgKiB3aWR0aCkgIC8gYm94LndpZHRoICArIGJveC54XG4gICAgICAgIHRoaXMudmFsdWVbaV1bN10gPSAoKHRoaXMudmFsdWVbaV1bN10gLSBib3gueSkgKiBoZWlnaHQpIC8gYm94LmhlaWdodCArIGJveC55XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG4gIC8vIFRlc3QgaWYgdGhlIHBhc3NlZCBwYXRoIGFycmF5IHVzZSB0aGUgc2FtZSBwYXRoIGRhdGEgY29tbWFuZHMgYXMgdGhpcyBwYXRoIGFycmF5XG4sIGVxdWFsQ29tbWFuZHM6IGZ1bmN0aW9uKHBhdGhBcnJheSkge1xuICAgIHZhciBpLCBpbCwgZXF1YWxDb21tYW5kc1xuXG4gICAgcGF0aEFycmF5ID0gbmV3IFNWRy5QYXRoQXJyYXkocGF0aEFycmF5KVxuXG4gICAgZXF1YWxDb21tYW5kcyA9IHRoaXMudmFsdWUubGVuZ3RoID09PSBwYXRoQXJyYXkudmFsdWUubGVuZ3RoXG4gICAgZm9yKGkgPSAwLCBpbCA9IHRoaXMudmFsdWUubGVuZ3RoOyBlcXVhbENvbW1hbmRzICYmIGkgPCBpbDsgaSsrKSB7XG4gICAgICBlcXVhbENvbW1hbmRzID0gdGhpcy52YWx1ZVtpXVswXSA9PT0gcGF0aEFycmF5LnZhbHVlW2ldWzBdXG4gICAgfVxuXG4gICAgcmV0dXJuIGVxdWFsQ29tbWFuZHNcbiAgfVxuICAvLyBNYWtlIHBhdGggYXJyYXkgbW9ycGhhYmxlXG4sIG1vcnBoOiBmdW5jdGlvbihwYXRoQXJyYXkpIHtcbiAgICBwYXRoQXJyYXkgPSBuZXcgU1ZHLlBhdGhBcnJheShwYXRoQXJyYXkpXG5cbiAgICBpZih0aGlzLmVxdWFsQ29tbWFuZHMocGF0aEFycmF5KSkge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IHBhdGhBcnJheVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbnVsbFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cbiAgLy8gR2V0IG1vcnBoZWQgcGF0aCBhcnJheSBhdCBnaXZlbiBwb3NpdGlvblxuLCBhdDogZnVuY3Rpb24ocG9zKSB7XG4gICAgLy8gbWFrZSBzdXJlIGEgZGVzdGluYXRpb24gaXMgZGVmaW5lZFxuICAgIGlmICghdGhpcy5kZXN0aW5hdGlvbikgcmV0dXJuIHRoaXNcblxuICAgIHZhciBzb3VyY2VBcnJheSA9IHRoaXMudmFsdWVcbiAgICAgICwgZGVzdGluYXRpb25BcnJheSA9IHRoaXMuZGVzdGluYXRpb24udmFsdWVcbiAgICAgICwgYXJyYXkgPSBbXSwgcGF0aEFycmF5ID0gbmV3IFNWRy5QYXRoQXJyYXkoKVxuICAgICAgLCBpLCBpbCwgaiwgamxcblxuICAgIC8vIEFuaW1hdGUgaGFzIHNwZWNpZmllZCBpbiB0aGUgU1ZHIHNwZWNcbiAgICAvLyBTZWU6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9wYXRocy5odG1sI1BhdGhFbGVtZW50XG4gICAgZm9yIChpID0gMCwgaWwgPSBzb3VyY2VBcnJheS5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBhcnJheVtpXSA9IFtzb3VyY2VBcnJheVtpXVswXV1cbiAgICAgIGZvcihqID0gMSwgamwgPSBzb3VyY2VBcnJheVtpXS5sZW5ndGg7IGogPCBqbDsgaisrKSB7XG4gICAgICAgIGFycmF5W2ldW2pdID0gc291cmNlQXJyYXlbaV1bal0gKyAoZGVzdGluYXRpb25BcnJheVtpXVtqXSAtIHNvdXJjZUFycmF5W2ldW2pdKSAqIHBvc1xuICAgICAgfVxuICAgICAgLy8gRm9yIHRoZSB0d28gZmxhZ3Mgb2YgdGhlIGVsbGlwdGljYWwgYXJjIGNvbW1hbmQsIHRoZSBTVkcgc3BlYyBzYXk6XG4gICAgICAvLyBGbGFncyBhbmQgYm9vbGVhbnMgYXJlIGludGVycG9sYXRlZCBhcyBmcmFjdGlvbnMgYmV0d2VlbiB6ZXJvIGFuZCBvbmUsIHdpdGggYW55IG5vbi16ZXJvIHZhbHVlIGNvbnNpZGVyZWQgdG8gYmUgYSB2YWx1ZSBvZiBvbmUvdHJ1ZVxuICAgICAgLy8gRWxsaXB0aWNhbCBhcmMgY29tbWFuZCBhcyBhbiBhcnJheSBmb2xsb3dlZCBieSBjb3JyZXNwb25kaW5nIGluZGV4ZXM6XG4gICAgICAvLyBbJ0EnLCByeCwgcnksIHgtYXhpcy1yb3RhdGlvbiwgbGFyZ2UtYXJjLWZsYWcsIHN3ZWVwLWZsYWcsIHgsIHldXG4gICAgICAvLyAgIDAgICAgMSAgIDIgICAgICAgIDMgICAgICAgICAgICAgICAgIDQgICAgICAgICAgICAgNSAgICAgIDYgIDdcbiAgICAgIGlmKGFycmF5W2ldWzBdID09PSAnQScpIHtcbiAgICAgICAgYXJyYXlbaV1bNF0gPSArKGFycmF5W2ldWzRdICE9IDApXG4gICAgICAgIGFycmF5W2ldWzVdID0gKyhhcnJheVtpXVs1XSAhPSAwKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERpcmVjdGx5IG1vZGlmeSB0aGUgdmFsdWUgb2YgYSBwYXRoIGFycmF5LCB0aGlzIGlzIGRvbmUgdGhpcyB3YXkgZm9yIHBlcmZvcm1hbmNlXG4gICAgcGF0aEFycmF5LnZhbHVlID0gYXJyYXlcbiAgICByZXR1cm4gcGF0aEFycmF5XG4gIH1cbiAgLy8gQWJzb2x1dGl6ZSBhbmQgcGFyc2UgcGF0aCB0byBhcnJheVxuLCBwYXJzZTogZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAvLyBpZiBpdCdzIGFscmVhZHkgYSBwYXRoYXJyYXksIG5vIG5lZWQgdG8gcGFyc2UgaXRcbiAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBTVkcuUGF0aEFycmF5KSByZXR1cm4gYXJyYXkudmFsdWVPZigpXG5cbiAgICAvLyBwcmVwYXJlIGZvciBwYXJzaW5nXG4gICAgdmFyIGksIHgwLCB5MCwgcywgc2VnLCBhcnJcbiAgICAgICwgeCA9IDBcbiAgICAgICwgeSA9IDBcbiAgICAgICwgcGFyYW1DbnQgPSB7ICdNJzoyLCAnTCc6MiwgJ0gnOjEsICdWJzoxLCAnQyc6NiwgJ1MnOjQsICdRJzo0LCAnVCc6MiwgJ0EnOjcgfVxuXG4gICAgaWYodHlwZW9mIGFycmF5ID09ICdzdHJpbmcnKXtcblxuICAgICAgYXJyYXkgPSBhcnJheVxuICAgICAgICAucmVwbGFjZShTVkcucmVnZXgubmVnRXhwLCAnWCcpICAgICAgICAgLy8gcmVwbGFjZSBhbGwgbmVnYXRpdmUgZXhwb25lbnRzIHdpdGggY2VydGFpbiBjaGFyXG4gICAgICAgIC5yZXBsYWNlKFNWRy5yZWdleC5wYXRoTGV0dGVycywgJyAkJiAnKSAvLyBwdXQgc29tZSByb29tIGJldHdlZW4gbGV0dGVycyBhbmQgbnVtYmVyc1xuICAgICAgICAucmVwbGFjZShTVkcucmVnZXguaHlwaGVuLCAnIC0nKSAgICAgICAgLy8gYWRkIHNwYWNlIGJlZm9yZSBoeXBoZW5cbiAgICAgICAgLnJlcGxhY2UoU1ZHLnJlZ2V4LmNvbW1hLCAnICcpICAgICAgICAgIC8vIHVuaWZ5IGFsbCBzcGFjZXNcbiAgICAgICAgLnJlcGxhY2UoU1ZHLnJlZ2V4LlgsICdlLScpICAgICAgICAgICAgIC8vIGFkZCBiYWNrIHRoZSBleHBvZW50XG4gICAgICAgIC50cmltKCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmltXG4gICAgICAgIC5zcGxpdChTVkcucmVnZXgud2hpdGVzcGFjZXMpICAgICAgICAgICAvLyBzcGxpdCBpbnRvIGFycmF5XG5cbiAgICAgIC8vIGF0IHRoaXMgcGxhY2UgdGhlcmUgY291bGQgYmUgcGFydHMgbGlrZSBbJzMuMTI0Ljg1NC4zMiddIGJlY2F1c2Ugd2UgY291bGQgbm90IGRldGVybWluZSB0aGUgcG9pbnQgYXMgc2VwZXJhdG9yIHRpbGwgbm93XG4gICAgICAvLyB3ZSBmaXggdGhpcyBlbGVtZW50cyBpbiB0aGUgbmV4dCBsb29wXG4gICAgICBmb3IoaSA9IGFycmF5Lmxlbmd0aDsgLS1pOyl7XG4gICAgICAgIGlmKGFycmF5W2ldLmluZGV4T2YoJy4nKSAhPSBhcnJheVtpXS5sYXN0SW5kZXhPZignLicpKXtcbiAgICAgICAgICB2YXIgc3BsaXQgPSBhcnJheVtpXS5zcGxpdCgnLicpIC8vIHNwbGl0IGF0IHRoZSBwb2ludFxuICAgICAgICAgIHZhciBmaXJzdCA9IFtzcGxpdC5zaGlmdCgpLCBzcGxpdC5zaGlmdCgpXS5qb2luKCcuJykgLy8gam9pbiB0aGUgZmlyc3QgbnVtYmVyIHRvZ2V0aGVyXG4gICAgICAgICAgYXJyYXkuc3BsaWNlLmFwcGx5KGFycmF5LCBbaSwgMV0uY29uY2F0KGZpcnN0LCBzcGxpdC5tYXAoZnVuY3Rpb24oZWwpeyByZXR1cm4gJy4nK2VsIH0pKSkgLy8gYWRkIGZpcnN0IGFuZCBhbGwgb3RoZXIgZW50cmllcyBiYWNrIHRvIGFycmF5XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH1lbHNle1xuICAgICAgYXJyYXkgPSBhcnJheS5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3Vycil7XG4gICAgICAgIHJldHVybiBbXS5jb25jYXQuYXBwbHkocHJldiwgY3VycilcbiAgICAgIH0sIFtdKVxuICAgIH1cblxuICAgIC8vIGFycmF5IG5vdyBpcyBhbiBhcnJheSBjb250YWluaW5nIGFsbCBwYXJ0cyBvZiBhIHBhdGggZS5nLiBbJ00nLCAnMCcsICcwJywgJ0wnLCAnMzAnLCAnMzAnIC4uLl1cblxuICAgIHZhciBhcnIgPSBbXVxuXG4gICAgZG97XG5cbiAgICAgIC8vIFRlc3QgaWYgd2UgaGF2ZSBhIHBhdGggbGV0dGVyXG4gICAgICBpZihTVkcucmVnZXguaXNQYXRoTGV0dGVyLnRlc3QoYXJyYXlbMF0pKXtcbiAgICAgICAgcyA9IGFycmF5WzBdXG4gICAgICAgIGFycmF5LnNoaWZ0KClcbiAgICAgIC8vIElmIGxhc3QgbGV0dGVyIHdhcyBhIG1vdmUgY29tbWFuZCBhbmQgd2UgZ290IG5vIG5ldywgaXQgZGVmYXVsdHMgdG8gW0xdaW5lXG4gICAgICB9ZWxzZSBpZihzID09ICdNJyl7XG4gICAgICAgIHMgPSAnTCdcbiAgICAgIH1lbHNlIGlmKHMgPT0gJ20nKXtcbiAgICAgICAgcyA9ICdsJ1xuICAgICAgfVxuXG4gICAgICAvLyBhZGQgcGF0aCBsZXR0ZXIgYXMgZmlyc3QgZWxlbWVudFxuICAgICAgc2VnID0gW3MudG9VcHBlckNhc2UoKV1cblxuICAgICAgLy8gcHVzaCBhbGwgbmVjZXNzYXJ5IHBhcmFtZXRlcnMgdG8gc2VnbWVudFxuICAgICAgZm9yKGkgPSAwOyBpIDwgcGFyYW1DbnRbc2VnWzBdXTsgKytpKXtcbiAgICAgICAgc2VnLnB1c2gocGFyc2VGbG9hdChhcnJheS5zaGlmdCgpKSlcbiAgICAgIH1cblxuICAgICAgLy8gdXBwZXIgY2FzZVxuICAgICAgaWYocyA9PSBzZWdbMF0pe1xuXG4gICAgICAgIGlmKHMgPT0gJ00nIHx8IHMgPT0gJ0wnIHx8IHMgPT0gJ0MnIHx8IHMgPT0gJ1EnIHx8IHMgPT0gJ1MnIHx8IHMgPT0gJ1QnKXtcbiAgICAgICAgICB4ID0gc2VnW3BhcmFtQ250W3NlZ1swXV0tMV1cbiAgICAgICAgICB5ID0gc2VnW3BhcmFtQ250W3NlZ1swXV1dXG4gICAgICAgIH1lbHNlIGlmKHMgPT0gJ1YnKXtcbiAgICAgICAgICB5ID0gc2VnWzFdXG4gICAgICAgIH1lbHNlIGlmKHMgPT0gJ0gnKXtcbiAgICAgICAgICB4ID0gc2VnWzFdXG4gICAgICAgIH1lbHNlIGlmKHMgPT0gJ0EnKXtcbiAgICAgICAgICB4ID0gc2VnWzZdXG4gICAgICAgICAgeSA9IHNlZ1s3XVxuICAgICAgICB9XG5cbiAgICAgIC8vIGxvd2VyIGNhc2VcbiAgICAgIH1lbHNle1xuXG4gICAgICAgIC8vIGNvbnZlcnQgcmVsYXRpdmUgdG8gYWJzb2x1dGUgdmFsdWVzXG4gICAgICAgIGlmKHMgPT0gJ20nIHx8IHMgPT0gJ2wnIHx8IHMgPT0gJ2MnIHx8IHMgPT0gJ3MnIHx8IHMgPT0gJ3EnIHx8IHMgPT0gJ3QnKXtcblxuICAgICAgICAgIHNlZ1sxXSArPSB4XG4gICAgICAgICAgc2VnWzJdICs9IHlcblxuICAgICAgICAgIGlmKHNlZ1szXSAhPSBudWxsKXtcbiAgICAgICAgICAgIHNlZ1szXSArPSB4XG4gICAgICAgICAgICBzZWdbNF0gKz0geVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKHNlZ1s1XSAhPSBudWxsKXtcbiAgICAgICAgICAgIHNlZ1s1XSArPSB4XG4gICAgICAgICAgICBzZWdbNl0gKz0geVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIG1vdmUgcG9pbnRlclxuICAgICAgICAgIHggPSBzZWdbcGFyYW1DbnRbc2VnWzBdXS0xXVxuICAgICAgICAgIHkgPSBzZWdbcGFyYW1DbnRbc2VnWzBdXV1cblxuICAgICAgICB9ZWxzZSBpZihzID09ICd2Jyl7XG4gICAgICAgICAgc2VnWzFdICs9IHlcbiAgICAgICAgICB5ID0gc2VnWzFdXG4gICAgICAgIH1lbHNlIGlmKHMgPT0gJ2gnKXtcbiAgICAgICAgICBzZWdbMV0gKz0geFxuICAgICAgICAgIHggPSBzZWdbMV1cbiAgICAgICAgfWVsc2UgaWYocyA9PSAnYScpe1xuICAgICAgICAgIHNlZ1s2XSArPSB4XG4gICAgICAgICAgc2VnWzddICs9IHlcbiAgICAgICAgICB4ID0gc2VnWzZdXG4gICAgICAgICAgeSA9IHNlZ1s3XVxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgaWYoc2VnWzBdID09ICdNJyl7XG4gICAgICAgIHgwID0geFxuICAgICAgICB5MCA9IHlcbiAgICAgIH1cblxuICAgICAgaWYoc2VnWzBdID09ICdaJyl7XG4gICAgICAgIHggPSB4MFxuICAgICAgICB5ID0geTBcbiAgICAgIH1cblxuICAgICAgYXJyLnB1c2goc2VnKVxuXG4gICAgfXdoaWxlKGFycmF5Lmxlbmd0aClcblxuICAgIHJldHVybiBhcnJcblxuICB9XG4gIC8vIEdldCBib3VuZGluZyBib3ggb2YgcGF0aFxuLCBiYm94OiBmdW5jdGlvbigpIHtcbiAgICBTVkcucGFyc2VyLnBhdGguc2V0QXR0cmlidXRlKCdkJywgdGhpcy50b1N0cmluZygpKVxuXG4gICAgcmV0dXJuIFNWRy5wYXJzZXIucGF0aC5nZXRCQm94KClcbiAgfVxuXG59KVxuXG4vLyBNb2R1bGUgZm9yIHVuaXQgY29udmVydGlvbnNcblNWRy5OdW1iZXIgPSBTVkcuaW52ZW50KHtcbiAgLy8gSW5pdGlhbGl6ZVxuICBjcmVhdGU6IGZ1bmN0aW9uKHZhbHVlLCB1bml0KSB7XG4gICAgLy8gaW5pdGlhbGl6ZSBkZWZhdWx0c1xuICAgIHRoaXMudmFsdWUgPSAwXG4gICAgdGhpcy51bml0ICA9IHVuaXQgfHwgJydcblxuICAgIC8vIHBhcnNlIHZhbHVlXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIGVuc3VyZSBhIHZhbGlkIG51bWVyaWMgdmFsdWVcbiAgICAgIHRoaXMudmFsdWUgPSBpc05hTih2YWx1ZSkgPyAwIDogIWlzRmluaXRlKHZhbHVlKSA/ICh2YWx1ZSA8IDAgPyAtMy40ZSszOCA6ICszLjRlKzM4KSA6IHZhbHVlXG5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHVuaXQgPSB2YWx1ZS5tYXRjaChTVkcucmVnZXgubnVtYmVyQW5kVW5pdClcblxuICAgICAgaWYgKHVuaXQpIHtcbiAgICAgICAgLy8gbWFrZSB2YWx1ZSBudW1lcmljXG4gICAgICAgIHRoaXMudmFsdWUgPSBwYXJzZUZsb2F0KHVuaXRbMV0pXG5cbiAgICAgICAgLy8gbm9ybWFsaXplXG4gICAgICAgIGlmICh1bml0WzVdID09ICclJylcbiAgICAgICAgICB0aGlzLnZhbHVlIC89IDEwMFxuICAgICAgICBlbHNlIGlmICh1bml0WzVdID09ICdzJylcbiAgICAgICAgICB0aGlzLnZhbHVlICo9IDEwMDBcblxuICAgICAgICAvLyBzdG9yZSB1bml0XG4gICAgICAgIHRoaXMudW5pdCA9IHVuaXRbNV1cbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTVkcuTnVtYmVyKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZS52YWx1ZU9mKClcbiAgICAgICAgdGhpcy51bml0ICA9IHZhbHVlLnVuaXRcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuICAvLyBBZGQgbWV0aG9kc1xuLCBleHRlbmQ6IHtcbiAgICAvLyBTdHJpbmdhbGl6ZVxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMudW5pdCA9PSAnJScgP1xuICAgICAgICAgIH5+KHRoaXMudmFsdWUgKiAxZTgpIC8gMWU2OlxuICAgICAgICB0aGlzLnVuaXQgPT0gJ3MnID9cbiAgICAgICAgICB0aGlzLnZhbHVlIC8gMWUzIDpcbiAgICAgICAgICB0aGlzLnZhbHVlXG4gICAgICApICsgdGhpcy51bml0XG4gICAgfVxuICAsIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpXG4gICAgfVxuICAsIC8vIENvbnZlcnQgdG8gcHJpbWl0aXZlXG4gICAgdmFsdWVPZjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZVxuICAgIH1cbiAgICAvLyBBZGQgbnVtYmVyXG4gICwgcGx1czogZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgICByZXR1cm4gbmV3IFNWRy5OdW1iZXIodGhpcyArIG5ldyBTVkcuTnVtYmVyKG51bWJlciksIHRoaXMudW5pdClcbiAgICB9XG4gICAgLy8gU3VidHJhY3QgbnVtYmVyXG4gICwgbWludXM6IGZ1bmN0aW9uKG51bWJlcikge1xuICAgICAgcmV0dXJuIHRoaXMucGx1cygtbmV3IFNWRy5OdW1iZXIobnVtYmVyKSlcbiAgICB9XG4gICAgLy8gTXVsdGlwbHkgbnVtYmVyXG4gICwgdGltZXM6IGZ1bmN0aW9uKG51bWJlcikge1xuICAgICAgcmV0dXJuIG5ldyBTVkcuTnVtYmVyKHRoaXMgKiBuZXcgU1ZHLk51bWJlcihudW1iZXIpLCB0aGlzLnVuaXQpXG4gICAgfVxuICAgIC8vIERpdmlkZSBudW1iZXJcbiAgLCBkaXZpZGU6IGZ1bmN0aW9uKG51bWJlcikge1xuICAgICAgcmV0dXJuIG5ldyBTVkcuTnVtYmVyKHRoaXMgLyBuZXcgU1ZHLk51bWJlcihudW1iZXIpLCB0aGlzLnVuaXQpXG4gICAgfVxuICAgIC8vIENvbnZlcnQgdG8gZGlmZmVyZW50IHVuaXRcbiAgLCB0bzogZnVuY3Rpb24odW5pdCkge1xuICAgICAgdmFyIG51bWJlciA9IG5ldyBTVkcuTnVtYmVyKHRoaXMpXG5cbiAgICAgIGlmICh0eXBlb2YgdW5pdCA9PT0gJ3N0cmluZycpXG4gICAgICAgIG51bWJlci51bml0ID0gdW5pdFxuXG4gICAgICByZXR1cm4gbnVtYmVyXG4gICAgfVxuICAgIC8vIE1ha2UgbnVtYmVyIG1vcnBoYWJsZVxuICAsIG1vcnBoOiBmdW5jdGlvbihudW1iZXIpIHtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBuZXcgU1ZHLk51bWJlcihudW1iZXIpXG5cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIC8vIEdldCBtb3JwaGVkIG51bWJlciBhdCBnaXZlbiBwb3NpdGlvblxuICAsIGF0OiBmdW5jdGlvbihwb3MpIHtcbiAgICAgIC8vIE1ha2Ugc3VyZSBhIGRlc3RpbmF0aW9uIGlzIGRlZmluZWRcbiAgICAgIGlmICghdGhpcy5kZXN0aW5hdGlvbikgcmV0dXJuIHRoaXNcblxuICAgICAgLy8gR2VuZXJhdGUgbmV3IG1vcnBoZWQgbnVtYmVyXG4gICAgICByZXR1cm4gbmV3IFNWRy5OdW1iZXIodGhpcy5kZXN0aW5hdGlvbilcbiAgICAgICAgICAubWludXModGhpcylcbiAgICAgICAgICAudGltZXMocG9zKVxuICAgICAgICAgIC5wbHVzKHRoaXMpXG4gICAgfVxuXG4gIH1cbn0pXG5cblNWRy5FbGVtZW50ID0gU1ZHLmludmVudCh7XG4gIC8vIEluaXRpYWxpemUgbm9kZVxuICBjcmVhdGU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAvLyBtYWtlIHN0cm9rZSB2YWx1ZSBhY2Nlc3NpYmxlIGR5bmFtaWNhbGx5XG4gICAgdGhpcy5fc3Ryb2tlID0gU1ZHLmRlZmF1bHRzLmF0dHJzLnN0cm9rZVxuXG4gICAgLy8gaW5pdGlhbGl6ZSBkYXRhIG9iamVjdFxuICAgIHRoaXMuZG9tID0ge31cblxuICAgIC8vIGNyZWF0ZSBjaXJjdWxhciByZWZlcmVuY2VcbiAgICBpZiAodGhpcy5ub2RlID0gbm9kZSkge1xuICAgICAgdGhpcy50eXBlID0gbm9kZS5ub2RlTmFtZVxuICAgICAgdGhpcy5ub2RlLmluc3RhbmNlID0gdGhpc1xuXG4gICAgICAvLyBzdG9yZSBjdXJyZW50IGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAgdGhpcy5fc3Ryb2tlID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ3N0cm9rZScpIHx8IHRoaXMuX3N0cm9rZVxuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4sIGV4dGVuZDoge1xuICAgIC8vIE1vdmUgb3ZlciB4LWF4aXNcbiAgICB4OiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCd4JywgeClcbiAgICB9XG4gICAgLy8gTW92ZSBvdmVyIHktYXhpc1xuICAsIHk6IGZ1bmN0aW9uKHkpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3knLCB5KVxuICAgIH1cbiAgICAvLyBNb3ZlIGJ5IGNlbnRlciBvdmVyIHgtYXhpc1xuICAsIGN4OiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4geCA9PSBudWxsID8gdGhpcy54KCkgKyB0aGlzLndpZHRoKCkgLyAyIDogdGhpcy54KHggLSB0aGlzLndpZHRoKCkgLyAyKVxuICAgIH1cbiAgICAvLyBNb3ZlIGJ5IGNlbnRlciBvdmVyIHktYXhpc1xuICAsIGN5OiBmdW5jdGlvbih5KSB7XG4gICAgICByZXR1cm4geSA9PSBudWxsID8gdGhpcy55KCkgKyB0aGlzLmhlaWdodCgpIC8gMiA6IHRoaXMueSh5IC0gdGhpcy5oZWlnaHQoKSAvIDIpXG4gICAgfVxuICAgIC8vIE1vdmUgZWxlbWVudCB0byBnaXZlbiB4IGFuZCB5IHZhbHVlc1xuICAsIG1vdmU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHJldHVybiB0aGlzLngoeCkueSh5KVxuICAgIH1cbiAgICAvLyBNb3ZlIGVsZW1lbnQgYnkgaXRzIGNlbnRlclxuICAsIGNlbnRlcjogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgcmV0dXJuIHRoaXMuY3goeCkuY3koeSlcbiAgICB9XG4gICAgLy8gU2V0IHdpZHRoIG9mIGVsZW1lbnRcbiAgLCB3aWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3dpZHRoJywgd2lkdGgpXG4gICAgfVxuICAgIC8vIFNldCBoZWlnaHQgb2YgZWxlbWVudFxuICAsIGhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdoZWlnaHQnLCBoZWlnaHQpXG4gICAgfVxuICAgIC8vIFNldCBlbGVtZW50IHNpemUgdG8gZ2l2ZW4gd2lkdGggYW5kIGhlaWdodFxuICAsIHNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHZhciBwID0gcHJvcG9ydGlvbmFsU2l6ZSh0aGlzLCB3aWR0aCwgaGVpZ2h0KVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgICAgICAud2lkdGgobmV3IFNWRy5OdW1iZXIocC53aWR0aCkpXG4gICAgICAgIC5oZWlnaHQobmV3IFNWRy5OdW1iZXIocC5oZWlnaHQpKVxuICAgIH1cbiAgICAvLyBDbG9uZSBlbGVtZW50XG4gICwgY2xvbmU6IGZ1bmN0aW9uKHBhcmVudCkge1xuICAgICAgLy8gY2xvbmUgZWxlbWVudCBhbmQgYXNzaWduIG5ldyBpZFxuICAgICAgdmFyIGNsb25lID0gYXNzaWduTmV3SWQodGhpcy5ub2RlLmNsb25lTm9kZSh0cnVlKSlcblxuICAgICAgLy8gaW5zZXJ0IHRoZSBjbG9uZSBpbiB0aGUgZ2l2ZW4gcGFyZW50IG9yIGFmdGVyIG15c2VsZlxuICAgICAgaWYocGFyZW50KSBwYXJlbnQuYWRkKGNsb25lKVxuICAgICAgZWxzZSB0aGlzLmFmdGVyKGNsb25lKVxuXG4gICAgICByZXR1cm4gY2xvbmVcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGVsZW1lbnRcbiAgLCByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucGFyZW50KCkpXG4gICAgICAgIHRoaXMucGFyZW50KCkucmVtb3ZlRWxlbWVudCh0aGlzKVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICAvLyBSZXBsYWNlIGVsZW1lbnRcbiAgLCByZXBsYWNlOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICB0aGlzLmFmdGVyKGVsZW1lbnQpLnJlbW92ZSgpXG5cbiAgICAgIHJldHVybiBlbGVtZW50XG4gICAgfVxuICAgIC8vIEFkZCBlbGVtZW50IHRvIGdpdmVuIGNvbnRhaW5lciBhbmQgcmV0dXJuIHNlbGZcbiAgLCBhZGRUbzogZnVuY3Rpb24ocGFyZW50KSB7XG4gICAgICByZXR1cm4gcGFyZW50LnB1dCh0aGlzKVxuICAgIH1cbiAgICAvLyBBZGQgZWxlbWVudCB0byBnaXZlbiBjb250YWluZXIgYW5kIHJldHVybiBjb250YWluZXJcbiAgLCBwdXRJbjogZnVuY3Rpb24ocGFyZW50KSB7XG4gICAgICByZXR1cm4gcGFyZW50LmFkZCh0aGlzKVxuICAgIH1cbiAgICAvLyBHZXQgLyBzZXQgaWRcbiAgLCBpZDogZnVuY3Rpb24oaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2lkJywgaWQpXG4gICAgfVxuICAgIC8vIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBwb2ludCBpbnNpZGUgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgZWxlbWVudFxuICAsIGluc2lkZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgdmFyIGJveCA9IHRoaXMuYmJveCgpXG5cbiAgICAgIHJldHVybiB4ID4gYm94LnhcbiAgICAgICAgICAmJiB5ID4gYm94LnlcbiAgICAgICAgICAmJiB4IDwgYm94LnggKyBib3gud2lkdGhcbiAgICAgICAgICAmJiB5IDwgYm94LnkgKyBib3guaGVpZ2h0XG4gICAgfVxuICAgIC8vIFNob3cgZWxlbWVudFxuICAsIHNob3c6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3R5bGUoJ2Rpc3BsYXknLCAnJylcbiAgICB9XG4gICAgLy8gSGlkZSBlbGVtZW50XG4gICwgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHlsZSgnZGlzcGxheScsICdub25lJylcbiAgICB9XG4gICAgLy8gSXMgZWxlbWVudCB2aXNpYmxlP1xuICAsIHZpc2libGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3R5bGUoJ2Rpc3BsYXknKSAhPSAnbm9uZSdcbiAgICB9XG4gICAgLy8gUmV0dXJuIGlkIG9uIHN0cmluZyBjb252ZXJzaW9uXG4gICwgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cignaWQnKVxuICAgIH1cbiAgICAvLyBSZXR1cm4gYXJyYXkgb2YgY2xhc3NlcyBvbiB0aGUgbm9kZVxuICAsIGNsYXNzZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGF0dHIgPSB0aGlzLmF0dHIoJ2NsYXNzJylcblxuICAgICAgcmV0dXJuIGF0dHIgPT0gbnVsbCA/IFtdIDogYXR0ci50cmltKCkuc3BsaXQoL1xccysvKVxuICAgIH1cbiAgICAvLyBSZXR1cm4gdHJ1ZSBpZiBjbGFzcyBleGlzdHMgb24gdGhlIG5vZGUsIGZhbHNlIG90aGVyd2lzZVxuICAsIGhhc0NsYXNzOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbGFzc2VzKCkuaW5kZXhPZihuYW1lKSAhPSAtMVxuICAgIH1cbiAgICAvLyBBZGQgY2xhc3MgdG8gdGhlIG5vZGVcbiAgLCBhZGRDbGFzczogZnVuY3Rpb24obmFtZSkge1xuICAgICAgaWYgKCF0aGlzLmhhc0NsYXNzKG5hbWUpKSB7XG4gICAgICAgIHZhciBhcnJheSA9IHRoaXMuY2xhc3NlcygpXG4gICAgICAgIGFycmF5LnB1c2gobmFtZSlcbiAgICAgICAgdGhpcy5hdHRyKCdjbGFzcycsIGFycmF5LmpvaW4oJyAnKSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGNsYXNzIGZyb20gdGhlIG5vZGVcbiAgLCByZW1vdmVDbGFzczogZnVuY3Rpb24obmFtZSkge1xuICAgICAgaWYgKHRoaXMuaGFzQ2xhc3MobmFtZSkpIHtcbiAgICAgICAgdGhpcy5hdHRyKCdjbGFzcycsIHRoaXMuY2xhc3NlcygpLmZpbHRlcihmdW5jdGlvbihjKSB7XG4gICAgICAgICAgcmV0dXJuIGMgIT0gbmFtZVxuICAgICAgICB9KS5qb2luKCcgJykpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIC8vIFRvZ2dsZSB0aGUgcHJlc2VuY2Ugb2YgYSBjbGFzcyBvbiB0aGUgbm9kZVxuICAsIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXNDbGFzcyhuYW1lKSA/IHRoaXMucmVtb3ZlQ2xhc3MobmFtZSkgOiB0aGlzLmFkZENsYXNzKG5hbWUpXG4gICAgfVxuICAgIC8vIEdldCByZWZlcmVuY2VkIGVsZW1lbnQgZm9ybSBhdHRyaWJ1dGUgdmFsdWVcbiAgLCByZWZlcmVuY2U6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIHJldHVybiBTVkcuZ2V0KHRoaXMuYXR0cihhdHRyKSlcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgcGFyZW50IGVsZW1lbnQgaW5zdGFuY2VcbiAgLCBwYXJlbnQ6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzXG5cbiAgICAgIC8vIGNoZWNrIGZvciBwYXJlbnRcbiAgICAgIGlmKCFwYXJlbnQubm9kZS5wYXJlbnROb2RlKSByZXR1cm4gbnVsbFxuXG4gICAgICAvLyBnZXQgcGFyZW50IGVsZW1lbnRcbiAgICAgIHBhcmVudCA9IFNWRy5hZG9wdChwYXJlbnQubm9kZS5wYXJlbnROb2RlKVxuXG4gICAgICBpZighdHlwZSkgcmV0dXJuIHBhcmVudFxuXG4gICAgICAvLyBsb29wIHRyb3VnaCBhbmNlc3RvcnMgaWYgdHlwZSBpcyBnaXZlblxuICAgICAgd2hpbGUocGFyZW50ICYmIHBhcmVudC5ub2RlIGluc3RhbmNlb2YgU1ZHRWxlbWVudCl7XG4gICAgICAgIGlmKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHBhcmVudC5tYXRjaGVzKHR5cGUpIDogcGFyZW50IGluc3RhbmNlb2YgdHlwZSkgcmV0dXJuIHBhcmVudFxuICAgICAgICBwYXJlbnQgPSBTVkcuYWRvcHQocGFyZW50Lm5vZGUucGFyZW50Tm9kZSlcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gR2V0IHBhcmVudCBkb2N1bWVudFxuICAsIGRvYzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIFNWRy5Eb2MgPyB0aGlzIDogdGhpcy5wYXJlbnQoU1ZHLkRvYylcbiAgICB9XG4gICAgLy8gcmV0dXJuIGFycmF5IG9mIGFsbCBhbmNlc3RvcnMgb2YgZ2l2ZW4gdHlwZSB1cCB0byB0aGUgcm9vdCBzdmdcbiAgLCBwYXJlbnRzOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICB2YXIgcGFyZW50cyA9IFtdLCBwYXJlbnQgPSB0aGlzXG5cbiAgICAgIGRve1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50KHR5cGUpXG4gICAgICAgIGlmKCFwYXJlbnQgfHwgIXBhcmVudC5ub2RlKSBicmVha1xuXG4gICAgICAgIHBhcmVudHMucHVzaChwYXJlbnQpXG4gICAgICB9IHdoaWxlKHBhcmVudC5wYXJlbnQpXG5cbiAgICAgIHJldHVybiBwYXJlbnRzXG4gICAgfVxuICAgIC8vIG1hdGNoZXMgdGhlIGVsZW1lbnQgdnMgYSBjc3Mgc2VsZWN0b3JcbiAgLCBtYXRjaGVzOiBmdW5jdGlvbihzZWxlY3Rvcil7XG4gICAgICByZXR1cm4gbWF0Y2hlcyh0aGlzLm5vZGUsIHNlbGVjdG9yKVxuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBzdmcgbm9kZSB0byBjYWxsIG5hdGl2ZSBzdmcgbWV0aG9kcyBvbiBpdFxuICAsIG5hdGl2ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlXG4gICAgfVxuICAgIC8vIEltcG9ydCByYXcgc3ZnXG4gICwgc3ZnOiBmdW5jdGlvbihzdmcpIHtcbiAgICAgIC8vIGNyZWF0ZSB0ZW1wb3JhcnkgaG9sZGVyXG4gICAgICB2YXIgd2VsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N2ZycpXG5cbiAgICAgIC8vIGFjdCBhcyBhIHNldHRlciBpZiBzdmcgaXMgZ2l2ZW5cbiAgICAgIGlmIChzdmcgJiYgdGhpcyBpbnN0YW5jZW9mIFNWRy5QYXJlbnQpIHtcbiAgICAgICAgLy8gZHVtcCByYXcgc3ZnXG4gICAgICAgIHdlbGwuaW5uZXJIVE1MID0gJzxzdmc+JyArIHN2Zy5yZXBsYWNlKC9cXG4vLCAnJykucmVwbGFjZSgvPChcXHcrKShbXjxdKz8pXFwvPi9nLCAnPCQxJDI+PC8kMT4nKSArICc8L3N2Zz4nXG5cbiAgICAgICAgLy8gdHJhbnNwbGFudCBub2Rlc1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSB3ZWxsLmZpcnN0Q2hpbGQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKVxuICAgICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh3ZWxsLmZpcnN0Q2hpbGQuZmlyc3RDaGlsZClcblxuICAgICAgLy8gb3RoZXJ3aXNlIGFjdCBhcyBhIGdldHRlclxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY3JlYXRlIGEgd3JhcHBpbmcgc3ZnIGVsZW1lbnQgaW4gY2FzZSBvZiBwYXJ0aWFsIGNvbnRlbnRcbiAgICAgICAgd2VsbC5hcHBlbmRDaGlsZChzdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdmcnKSlcblxuICAgICAgICAvLyB3cml0ZSBzdmdqcyBkYXRhIHRvIHRoZSBkb21cbiAgICAgICAgdGhpcy53cml0ZURhdGFUb0RvbSgpXG5cbiAgICAgICAgLy8gaW5zZXJ0IGEgY29weSBvZiB0aGlzIG5vZGVcbiAgICAgICAgc3ZnLmFwcGVuZENoaWxkKHRoaXMubm9kZS5jbG9uZU5vZGUodHJ1ZSkpXG5cbiAgICAgICAgLy8gcmV0dXJuIHRhcmdldCBlbGVtZW50XG4gICAgICAgIHJldHVybiB3ZWxsLmlubmVySFRNTC5yZXBsYWNlKC9ePHN2Zz4vLCAnJykucmVwbGFjZSgvPFxcL3N2Zz4kLywgJycpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAvLyB3cml0ZSBzdmdqcyBkYXRhIHRvIHRoZSBkb21cbiAgLCB3cml0ZURhdGFUb0RvbTogZnVuY3Rpb24oKSB7XG5cbiAgICAgIC8vIGR1bXAgdmFyaWFibGVzIHJlY3Vyc2l2ZWx5XG4gICAgICBpZih0aGlzLmVhY2ggfHwgdGhpcy5saW5lcyl7XG4gICAgICAgIHZhciBmbiA9IHRoaXMuZWFjaCA/IHRoaXMgOiB0aGlzLmxpbmVzKCk7XG4gICAgICAgIGZuLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgICB0aGlzLndyaXRlRGF0YVRvRG9tKClcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlIHByZXZpb3VzbHkgc2V0IGRhdGFcbiAgICAgIHRoaXMubm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ3N2Z2pzOmRhdGEnKVxuXG4gICAgICBpZihPYmplY3Qua2V5cyh0aGlzLmRvbSkubGVuZ3RoKVxuICAgICAgICB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKCdzdmdqczpkYXRhJywgSlNPTi5zdHJpbmdpZnkodGhpcy5kb20pKSAvLyBzZWUgIzQyOFxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgLy8gc2V0IGdpdmVuIGRhdGEgdG8gdGhlIGVsZW1lbnRzIGRhdGEgcHJvcGVydHlcbiAgLCBzZXREYXRhOiBmdW5jdGlvbihvKXtcbiAgICAgIHRoaXMuZG9tID0gb1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICwgaXM6IGZ1bmN0aW9uKG9iail7XG4gICAgICByZXR1cm4gaXModGhpcywgb2JqKVxuICAgIH1cbiAgfVxufSlcblxuU1ZHLmVhc2luZyA9IHtcbiAgJy0nOiBmdW5jdGlvbihwb3Mpe3JldHVybiBwb3N9XG4sICc8Pic6ZnVuY3Rpb24ocG9zKXtyZXR1cm4gLU1hdGguY29zKHBvcyAqIE1hdGguUEkpIC8gMiArIDAuNX1cbiwgJz4nOiBmdW5jdGlvbihwb3Mpe3JldHVybiAgTWF0aC5zaW4ocG9zICogTWF0aC5QSSAvIDIpfVxuLCAnPCc6IGZ1bmN0aW9uKHBvcyl7cmV0dXJuIC1NYXRoLmNvcyhwb3MgKiBNYXRoLlBJIC8gMikgKyAxfVxufVxuXG5TVkcubW9ycGggPSBmdW5jdGlvbihwb3Mpe1xuICByZXR1cm4gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gbmV3IFNWRy5Nb3JwaE9iaihmcm9tLCB0bykuYXQocG9zKVxuICB9XG59XG5cblNWRy5TaXR1YXRpb24gPSBTVkcuaW52ZW50KHtcblxuICBjcmVhdGU6IGZ1bmN0aW9uKG8pe1xuICAgIHRoaXMuaW5pdCA9IGZhbHNlXG4gICAgdGhpcy5yZXZlcnNlZCA9IGZhbHNlXG4gICAgdGhpcy5yZXZlcnNpbmcgPSBmYWxzZVxuXG4gICAgdGhpcy5kdXJhdGlvbiA9IG5ldyBTVkcuTnVtYmVyKG8uZHVyYXRpb24pLnZhbHVlT2YoKVxuICAgIHRoaXMuZGVsYXkgPSBuZXcgU1ZHLk51bWJlcihvLmRlbGF5KS52YWx1ZU9mKClcblxuICAgIHRoaXMuc3RhcnQgPSArbmV3IERhdGUoKSArIHRoaXMuZGVsYXlcbiAgICB0aGlzLmZpbmlzaCA9IHRoaXMuc3RhcnQgKyB0aGlzLmR1cmF0aW9uXG4gICAgdGhpcy5lYXNlID0gby5lYXNlXG5cbiAgICAvLyB0aGlzLmxvb3AgaXMgaW5jcmVtZW50ZWQgZnJvbSAwIHRvIHRoaXMubG9vcHNcbiAgICAvLyBpdCBpcyBhbHNvIGluY3JlbWVudGVkIHdoZW4gaW4gYW4gaW5maW5pdGUgbG9vcCAod2hlbiB0aGlzLmxvb3BzIGlzIHRydWUpXG4gICAgdGhpcy5sb29wID0gMFxuICAgIHRoaXMubG9vcHMgPSBmYWxzZVxuXG4gICAgdGhpcy5hbmltYXRpb25zID0ge1xuICAgICAgLy8gZnVuY3Rpb25Ub0NhbGw6IFtsaXN0IG9mIG1vcnBoYWJsZSBvYmplY3RzXVxuICAgICAgLy8gZS5nLiBtb3ZlOiBbU1ZHLk51bWJlciwgU1ZHLk51bWJlcl1cbiAgICB9XG5cbiAgICB0aGlzLmF0dHJzID0ge1xuICAgICAgLy8gaG9sZHMgYWxsIGF0dHJpYnV0ZXMgd2hpY2ggYXJlIG5vdCByZXByZXNlbnRlZCBmcm9tIGEgZnVuY3Rpb24gc3ZnLmpzIHByb3ZpZGVzXG4gICAgICAvLyBlLmcuIHNvbWVBdHRyOiBTVkcuTnVtYmVyXG4gICAgfVxuXG4gICAgdGhpcy5zdHlsZXMgPSB7XG4gICAgICAvLyBob2xkcyBhbGwgc3R5bGVzIHdoaWNoIHNob3VsZCBiZSBhbmltYXRlZFxuICAgICAgLy8gZS5nLiBmaWxsLWNvbG9yOiBTVkcuQ29sb3JcbiAgICB9XG5cbiAgICB0aGlzLnRyYW5zZm9ybXMgPSBbXG4gICAgICAvLyBob2xkcyBhbGwgdHJhbnNmb3JtYXRpb25zIGFzIHRyYW5zZm9ybWF0aW9uIG9iamVjdHNcbiAgICAgIC8vIGUuZy4gW1NWRy5Sb3RhdGUsIFNWRy5UcmFuc2xhdGUsIFNWRy5NYXRyaXhdXG4gICAgXVxuXG4gICAgdGhpcy5vbmNlID0ge1xuICAgICAgLy8gZnVuY3Rpb25zIHRvIGZpcmUgYXQgYSBzcGVjaWZpYyBwb3NpdGlvblxuICAgICAgLy8gZS5nLiBcIjAuNVwiOiBmdW5jdGlvbiBmb28oKXt9XG4gICAgfVxuXG4gIH1cblxufSlcblxuXG5TVkcuRlggPSBTVkcuaW52ZW50KHtcblxuICBjcmVhdGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICB0aGlzLl90YXJnZXQgPSBlbGVtZW50XG4gICAgdGhpcy5zaXR1YXRpb25zID0gW11cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlXG4gICAgdGhpcy5zaXR1YXRpb24gPSBudWxsXG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZVxuICAgIHRoaXMubGFzdFBvcyA9IDBcbiAgICB0aGlzLnBvcyA9IDBcbiAgICAvLyBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgYW4gYW5pbWF0aW9uIGlzIGl0cyBwb3NpdGlvbiBpbiB0aGUgY29udGV4dCBvZiBpdHMgY29tcGxldGUgZHVyYXRpb24gKGluY2x1ZGluZyBkZWxheSBhbmQgbG9vcHMpXG4gICAgLy8gV2hlbiBwZXJmb3JtaW5nIGEgZGVsYXksIGFic1BvcyBpcyBiZWxvdyAwIGFuZCB3aGVuIHBlcmZvcm1pbmcgYSBsb29wLCBpdHMgdmFsdWUgaXMgYWJvdmUgMVxuICAgIHRoaXMuYWJzUG9zID0gMFxuICAgIHRoaXMuX3NwZWVkID0gMVxuICB9XG5cbiwgZXh0ZW5kOiB7XG5cbiAgICAvKipcbiAgICAgKiBzZXRzIG9yIHJldHVybnMgdGhlIHRhcmdldCBvZiB0aGlzIGFuaW1hdGlvblxuICAgICAqIEBwYXJhbSBvIG9iamVjdCB8fCBudW1iZXIgSW4gY2FzZSBvZiBPYmplY3QgaXQgaG9sZHMgYWxsIHBhcmFtZXRlcnMuIEluIGNhc2Ugb2YgbnVtYmVyIGl0cyB0aGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvblxuICAgICAqIEBwYXJhbSBlYXNlIGZ1bmN0aW9uIHx8IHN0cmluZyBGdW5jdGlvbiB3aGljaCBzaG91bGQgYmUgdXNlZCBmb3IgZWFzaW5nIG9yIGVhc2luZyBrZXl3b3JkXG4gICAgICogQHBhcmFtIGRlbGF5IE51bWJlciBpbmRpY2F0aW5nIHRoZSBkZWxheSBiZWZvcmUgdGhlIGFuaW1hdGlvbiBzdGFydHNcbiAgICAgKiBAcmV0dXJuIHRhcmdldCB8fCB0aGlzXG4gICAgICovXG4gICAgYW5pbWF0ZTogZnVuY3Rpb24obywgZWFzZSwgZGVsYXkpe1xuXG4gICAgICBpZih0eXBlb2YgbyA9PSAnb2JqZWN0Jyl7XG4gICAgICAgIGVhc2UgPSBvLmVhc2VcbiAgICAgICAgZGVsYXkgPSBvLmRlbGF5XG4gICAgICAgIG8gPSBvLmR1cmF0aW9uXG4gICAgICB9XG5cbiAgICAgIHZhciBzaXR1YXRpb24gPSBuZXcgU1ZHLlNpdHVhdGlvbih7XG4gICAgICAgIGR1cmF0aW9uOiBvIHx8IDEwMDAsXG4gICAgICAgIGRlbGF5OiBkZWxheSB8fCAwLFxuICAgICAgICBlYXNlOiBTVkcuZWFzaW5nW2Vhc2UgfHwgJy0nXSB8fCBlYXNlXG4gICAgICB9KVxuXG4gICAgICB0aGlzLnF1ZXVlKHNpdHVhdGlvbilcblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXRzIGEgZGVsYXkgYmVmb3JlIHRoZSBuZXh0IGVsZW1lbnQgb2YgdGhlIHF1ZXVlIGlzIGNhbGxlZFxuICAgICAqIEBwYXJhbSBkZWxheSBEdXJhdGlvbiBvZiBkZWxheSBpbiBtaWxsaXNlY29uZHNcbiAgICAgKiBAcmV0dXJuIHRoaXMudGFyZ2V0KClcbiAgICAgKi9cbiAgLCBkZWxheTogZnVuY3Rpb24oZGVsYXkpe1xuICAgICAgLy8gVGhlIGRlbGF5IGlzIHBlcmZvcm1lZCBieSBhbiBlbXB0eSBzaXR1YXRpb24gd2l0aCBpdHMgZHVyYXRpb25cbiAgICAgIC8vIGF0dHJpYnV0ZSBzZXQgdG8gdGhlIGR1cmF0aW9uIG9mIHRoZSBkZWxheVxuICAgICAgdmFyIHNpdHVhdGlvbiA9IG5ldyBTVkcuU2l0dWF0aW9uKHtcbiAgICAgICAgZHVyYXRpb246IGRlbGF5LFxuICAgICAgICBkZWxheTogMCxcbiAgICAgICAgZWFzZTogU1ZHLmVhc2luZ1snLSddXG4gICAgICB9KVxuXG4gICAgICByZXR1cm4gdGhpcy5xdWV1ZShzaXR1YXRpb24pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0cyBvciByZXR1cm5zIHRoZSB0YXJnZXQgb2YgdGhpcyBhbmltYXRpb25cbiAgICAgKiBAcGFyYW0gbnVsbCB8fCB0YXJnZXQgU1ZHLkVsZW1lbnQgd2hpY2ggc2hvdWxkIGJlIHNldCBhcyBuZXcgdGFyZ2V0XG4gICAgICogQHJldHVybiB0YXJnZXQgfHwgdGhpc1xuICAgICAqL1xuICAsIHRhcmdldDogZnVuY3Rpb24odGFyZ2V0KXtcbiAgICAgIGlmKHRhcmdldCAmJiB0YXJnZXQgaW5zdGFuY2VvZiBTVkcuRWxlbWVudCl7XG4gICAgICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldFxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0XG4gICAgfVxuXG4gICAgLy8gcmV0dXJucyB0aGUgYWJzb2x1dGUgcG9zaXRpb24gYXQgYSBnaXZlbiB0aW1lXG4gICwgdGltZVRvQWJzUG9zOiBmdW5jdGlvbih0aW1lc3RhbXApe1xuICAgICAgcmV0dXJuICh0aW1lc3RhbXAgLSB0aGlzLnNpdHVhdGlvbi5zdGFydCkgLyAodGhpcy5zaXR1YXRpb24uZHVyYXRpb24vdGhpcy5fc3BlZWQpXG4gICAgfVxuXG4gICAgLy8gcmV0dXJucyB0aGUgdGltZXN0YW1wIGZyb20gYSBnaXZlbiBhYnNvbHV0ZSBwb3NpdG9uXG4gICwgYWJzUG9zVG9UaW1lOiBmdW5jdGlvbihhYnNQb3Mpe1xuICAgICAgcmV0dXJuIHRoaXMuc2l0dWF0aW9uLmR1cmF0aW9uL3RoaXMuX3NwZWVkICogYWJzUG9zICsgdGhpcy5zaXR1YXRpb24uc3RhcnRcbiAgICB9XG5cbiAgICAvLyBzdGFydHMgdGhlIGFuaW1hdGlvbmxvb3BcbiAgLCBzdGFydEFuaW1GcmFtZTogZnVuY3Rpb24oKXtcbiAgICAgIHRoaXMuc3RvcEFuaW1GcmFtZSgpXG4gICAgICB0aGlzLmFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7IHRoaXMuc3RlcCgpIH0uYmluZCh0aGlzKSlcbiAgICB9XG5cbiAgICAvLyBjYW5jZWxzIHRoZSBhbmltYXRpb25mcmFtZVxuICAsIHN0b3BBbmltRnJhbWU6IGZ1bmN0aW9uKCl7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvbkZyYW1lKVxuICAgIH1cblxuICAgIC8vIGtpY2tzIG9mZiB0aGUgYW5pbWF0aW9uIC0gb25seSBkb2VzIHNvbWV0aGluZyB3aGVuIHRoZSBxdWV1ZSBpcyBjdXJyZW50bHkgbm90IGFjdGl2ZSBhbmQgYXQgbGVhc3Qgb25lIHNpdHVhdGlvbiBpcyBzZXRcbiAgLCBzdGFydDogZnVuY3Rpb24oKXtcbiAgICAgIC8vIGRvbnQgc3RhcnQgaWYgYWxyZWFkeSBzdGFydGVkXG4gICAgICBpZighdGhpcy5hY3RpdmUgJiYgdGhpcy5zaXR1YXRpb24pe1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWVcbiAgICAgICAgdGhpcy5zdGFydEN1cnJlbnQoKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8vIHN0YXJ0IHRoZSBjdXJyZW50IHNpdHVhdGlvblxuICAsIHN0YXJ0Q3VycmVudDogZnVuY3Rpb24oKXtcbiAgICAgIHRoaXMuc2l0dWF0aW9uLnN0YXJ0ID0gK25ldyBEYXRlICsgdGhpcy5zaXR1YXRpb24uZGVsYXkvdGhpcy5fc3BlZWRcbiAgICAgIHRoaXMuc2l0dWF0aW9uLmZpbmlzaCA9IHRoaXMuc2l0dWF0aW9uLnN0YXJ0ICsgdGhpcy5zaXR1YXRpb24uZHVyYXRpb24vdGhpcy5fc3BlZWRcbiAgICAgIHJldHVybiB0aGlzLmluaXRBbmltYXRpb25zKCkuc3RlcCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWRkcyBhIGZ1bmN0aW9uIC8gU2l0dWF0aW9uIHRvIHRoZSBhbmltYXRpb24gcXVldWVcbiAgICAgKiBAcGFyYW0gZm4gZnVuY3Rpb24gLyBzaXR1YXRpb24gdG8gYWRkXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICwgcXVldWU6IGZ1bmN0aW9uKGZuKXtcbiAgICAgIGlmKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nIHx8IGZuIGluc3RhbmNlb2YgU1ZHLlNpdHVhdGlvbilcbiAgICAgICAgdGhpcy5zaXR1YXRpb25zLnB1c2goZm4pXG5cbiAgICAgIGlmKCF0aGlzLnNpdHVhdGlvbikgdGhpcy5zaXR1YXRpb24gPSB0aGlzLnNpdHVhdGlvbnMuc2hpZnQoKVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHB1bGxzIG5leHQgZWxlbWVudCBmcm9tIHRoZSBxdWV1ZSBhbmQgZXhlY3V0ZSBpdFxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAsIGRlcXVldWU6IGZ1bmN0aW9uKCl7XG4gICAgICAvLyBzdG9wIGN1cnJlbnQgYW5pbWF0aW9uXG4gICAgICB0aGlzLnNpdHVhdGlvbiAmJiB0aGlzLnNpdHVhdGlvbi5zdG9wICYmIHRoaXMuc2l0dWF0aW9uLnN0b3AoKVxuXG4gICAgICAvLyBnZXQgbmV4dCBhbmltYXRpb24gZnJvbSBxdWV1ZVxuICAgICAgdGhpcy5zaXR1YXRpb24gPSB0aGlzLnNpdHVhdGlvbnMuc2hpZnQoKVxuXG4gICAgICBpZih0aGlzLnNpdHVhdGlvbil7XG4gICAgICAgIGlmKHRoaXMuc2l0dWF0aW9uIGluc3RhbmNlb2YgU1ZHLlNpdHVhdGlvbikge1xuICAgICAgICAgIHRoaXMuc3RhcnRDdXJyZW50KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiBpdCBpcyBub3QgYSBTVkcuU2l0dWF0aW9uLCB0aGVuIGl0IGlzIGEgZnVuY3Rpb24sIHdlIGV4ZWN1dGUgaXRcbiAgICAgICAgICB0aGlzLnNpdHVhdGlvbi5jYWxsKHRoaXMpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvLyB1cGRhdGVzIGFsbCBhbmltYXRpb25zIHRvIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBlbGVtZW50XG4gICAgLy8gdGhpcyBpcyBpbXBvcnRhbnQgd2hlbiBvbmUgcHJvcGVydHkgY291bGQgYmUgY2hhbmdlZCBmcm9tIGFub3RoZXIgcHJvcGVydHlcbiAgLCBpbml0QW5pbWF0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaVxuICAgICAgdmFyIHMgPSB0aGlzLnNpdHVhdGlvblxuXG4gICAgICBpZihzLmluaXQpIHJldHVybiB0aGlzXG5cbiAgICAgIGZvcihpIGluIHMuYW5pbWF0aW9ucyl7XG5cbiAgICAgICAgaWYoaSA9PSAndmlld2JveCcpe1xuICAgICAgICAgIHMuYW5pbWF0aW9uc1tpXSA9IHRoaXMudGFyZ2V0KCkudmlld2JveCgpLm1vcnBoKHMuYW5pbWF0aW9uc1tpXSlcbiAgICAgICAgfWVsc2V7XG5cbiAgICAgICAgICAvLyBUT0RPOiB0aGlzIGlzIG5vdCBhIGNsZWFuIGNsb25lIG9mIHRoZSBhcnJheS4gV2UgbWF5IGhhdmUgc29tZSB1bmNoZWNrZWQgcmVmZXJlbmNlc1xuICAgICAgICAgIHMuYW5pbWF0aW9uc1tpXS52YWx1ZSA9IChpID09ICdwbG90JyA/IHRoaXMudGFyZ2V0KCkuYXJyYXkoKS52YWx1ZSA6IHRoaXMudGFyZ2V0KClbaV0oKSlcblxuICAgICAgICAgIC8vIHNvbWV0aW1lcyB3ZSBnZXQgYmFjayBhbiBvYmplY3QgYW5kIG5vdCB0aGUgcmVhbCB2YWx1ZSwgZml4IHRoaXNcbiAgICAgICAgICBpZihzLmFuaW1hdGlvbnNbaV0udmFsdWUudmFsdWUpe1xuICAgICAgICAgICAgcy5hbmltYXRpb25zW2ldLnZhbHVlID0gcy5hbmltYXRpb25zW2ldLnZhbHVlLnZhbHVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYocy5hbmltYXRpb25zW2ldLnJlbGF0aXZlKVxuICAgICAgICAgICAgcy5hbmltYXRpb25zW2ldLmRlc3RpbmF0aW9uLnZhbHVlID0gcy5hbmltYXRpb25zW2ldLmRlc3RpbmF0aW9uLnZhbHVlICsgcy5hbmltYXRpb25zW2ldLnZhbHVlXG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGZvcihpIGluIHMuYXR0cnMpe1xuICAgICAgICBpZihzLmF0dHJzW2ldIGluc3RhbmNlb2YgU1ZHLkNvbG9yKXtcbiAgICAgICAgICB2YXIgY29sb3IgPSBuZXcgU1ZHLkNvbG9yKHRoaXMudGFyZ2V0KCkuYXR0cihpKSlcbiAgICAgICAgICBzLmF0dHJzW2ldLnIgPSBjb2xvci5yXG4gICAgICAgICAgcy5hdHRyc1tpXS5nID0gY29sb3IuZ1xuICAgICAgICAgIHMuYXR0cnNbaV0uYiA9IGNvbG9yLmJcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgcy5hdHRyc1tpXS52YWx1ZSA9IHRoaXMudGFyZ2V0KCkuYXR0cihpKS8vICsgcy5hdHRyc1tpXS52YWx1ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvcihpIGluIHMuc3R5bGVzKXtcbiAgICAgICAgcy5zdHlsZXNbaV0udmFsdWUgPSB0aGlzLnRhcmdldCgpLnN0eWxlKGkpXG4gICAgICB9XG5cbiAgICAgIHMuaW5pdGlhbFRyYW5zZm9ybWF0aW9uID0gdGhpcy50YXJnZXQoKS5tYXRyaXhpZnkoKVxuXG4gICAgICBzLmluaXQgPSB0cnVlXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgLCBjbGVhclF1ZXVlOiBmdW5jdGlvbigpe1xuICAgICAgdGhpcy5zaXR1YXRpb25zID0gW11cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAsIGNsZWFyQ3VycmVudDogZnVuY3Rpb24oKXtcbiAgICAgIHRoaXMuc2l0dWF0aW9uID0gbnVsbFxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgLyoqIHN0b3BzIHRoZSBhbmltYXRpb24gaW1tZWRpYXRlbHlcbiAgICAgKiBAcGFyYW0ganVtcFRvRW5kIEEgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gY29tcGxldGUgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGltbWVkaWF0ZWx5LlxuICAgICAqIEBwYXJhbSBjbGVhclF1ZXVlIEEgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gcmVtb3ZlIHF1ZXVlZCBhbmltYXRpb24gYXMgd2VsbC5cbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgLCBzdG9wOiBmdW5jdGlvbihqdW1wVG9FbmQsIGNsZWFyUXVldWUpe1xuICAgICAgaWYoIXRoaXMuYWN0aXZlKSB0aGlzLnN0YXJ0KClcblxuICAgICAgaWYoY2xlYXJRdWV1ZSl7XG4gICAgICAgIHRoaXMuY2xlYXJRdWV1ZSgpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2VcblxuICAgICAgaWYoanVtcFRvRW5kICYmIHRoaXMuc2l0dWF0aW9uKXtcbiAgICAgICAgdGhpcy5hdEVuZCgpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RvcEFuaW1GcmFtZSgpXG5cbiAgICAgIHJldHVybiB0aGlzLmNsZWFyQ3VycmVudCgpXG4gICAgfVxuXG4gICAgLyoqIHJlc2V0cyB0aGUgZWxlbWVudCB0byB0aGUgc3RhdGUgd2hlcmUgdGhlIGN1cnJlbnQgZWxlbWVudCBoYXMgc3RhcnRlZFxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAsIHJlc2V0OiBmdW5jdGlvbigpe1xuICAgICAgaWYodGhpcy5zaXR1YXRpb24pe1xuICAgICAgICB2YXIgdGVtcCA9IHRoaXMuc2l0dWF0aW9uXG4gICAgICAgIHRoaXMuc3RvcCgpXG4gICAgICAgIHRoaXMuc2l0dWF0aW9uID0gdGVtcFxuICAgICAgICB0aGlzLmF0U3RhcnQoKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvLyBTdG9wIHRoZSBjdXJyZW50bHktcnVubmluZyBhbmltYXRpb24sIHJlbW92ZSBhbGwgcXVldWVkIGFuaW1hdGlvbnMsIGFuZCBjb21wbGV0ZSBhbGwgYW5pbWF0aW9ucyBmb3IgdGhlIGVsZW1lbnQuXG4gICwgZmluaXNoOiBmdW5jdGlvbigpe1xuXG4gICAgICB0aGlzLnN0b3AodHJ1ZSwgZmFsc2UpXG5cbiAgICAgIHdoaWxlKHRoaXMuZGVxdWV1ZSgpLnNpdHVhdGlvbiAmJiB0aGlzLnN0b3AodHJ1ZSwgZmFsc2UpKTtcblxuICAgICAgdGhpcy5jbGVhclF1ZXVlKCkuY2xlYXJDdXJyZW50KClcblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvLyBzZXQgdGhlIGludGVybmFsIGFuaW1hdGlvbiBwb2ludGVyIGF0IHRoZSBzdGFydCBwb3NpdGlvbiwgYmVmb3JlIGFueSBsb29wcywgYW5kIHVwZGF0ZXMgdGhlIHZpc3VhbGlzYXRpb25cbiAgLCBhdFN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5hdCgwLCB0cnVlKVxuICB9XG5cbiAgICAvLyBzZXQgdGhlIGludGVybmFsIGFuaW1hdGlvbiBwb2ludGVyIGF0IHRoZSBlbmQgcG9zaXRpb24sIGFmdGVyIGFsbCB0aGUgbG9vcHMsIGFuZCB1cGRhdGVzIHRoZSB2aXN1YWxpc2F0aW9uXG4gICwgYXRFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnNpdHVhdGlvbi5sb29wcyA9PT0gdHJ1ZSkge1xuICAgICAgLy8gSWYgaW4gYSBpbmZpbml0ZSBsb29wLCB3ZSBlbmQgdGhlIGN1cnJlbnQgaXRlcmF0aW9uXG4gICAgICByZXR1cm4gdGhpcy5hdCh0aGlzLnNpdHVhdGlvbi5sb29wKzEsIHRydWUpXG4gICAgfSBlbHNlIGlmKHR5cGVvZiB0aGlzLnNpdHVhdGlvbi5sb29wcyA9PSAnbnVtYmVyJykge1xuICAgICAgLy8gSWYgcGVyZm9ybWluZyBhIGZpbml0ZSBudW1iZXIgb2YgbG9vcHMsIHdlIGdvIGFmdGVyIGFsbCB0aGUgbG9vcHNcbiAgICAgIHJldHVybiB0aGlzLmF0KHRoaXMuc2l0dWF0aW9uLmxvb3BzLCB0cnVlKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBubyBsb29wcywgd2UganVzdCBnbyBhdCB0aGUgZW5kXG4gICAgICByZXR1cm4gdGhpcy5hdCgxLCB0cnVlKVxuICAgIH1cbiAgfVxuXG4gICAgLy8gc2V0IHRoZSBpbnRlcm5hbCBhbmltYXRpb24gcG9pbnRlciB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uIGFuZCB1cGRhdGVzIHRoZSB2aXN1YWxpc2F0aW9uXG4gICAgLy8gaWYgaXNBYnNQb3MgaXMgdHJ1ZSwgcG9zIGlzIHRyZWF0ZWQgYXMgYW4gYWJzb2x1dGUgcG9zaXRpb25cbiAgLCBhdDogZnVuY3Rpb24ocG9zLCBpc0Fic1Bvcyl7XG4gICAgICB2YXIgZHVyRGl2U3BkID0gdGhpcy5zaXR1YXRpb24uZHVyYXRpb24vdGhpcy5fc3BlZWRcblxuICAgICAgdGhpcy5hYnNQb3MgPSBwb3NcbiAgICAgIC8vIElmIHBvcyBpcyBub3QgYW4gYWJzb2x1dGUgcG9zaXRpb24sIHdlIGNvbnZlcnQgaXQgaW50byBvbmVcbiAgICAgIGlmICghaXNBYnNQb3MpIHtcbiAgICAgICAgaWYgKHRoaXMuc2l0dWF0aW9uLnJldmVyc2VkKSB0aGlzLmFic1BvcyA9IDEgLSB0aGlzLmFic1Bvc1xuICAgICAgICB0aGlzLmFic1BvcyArPSB0aGlzLnNpdHVhdGlvbi5sb29wXG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2l0dWF0aW9uLnN0YXJ0ID0gK25ldyBEYXRlIC0gdGhpcy5hYnNQb3MgKiBkdXJEaXZTcGRcbiAgICAgIHRoaXMuc2l0dWF0aW9uLmZpbmlzaCA9IHRoaXMuc2l0dWF0aW9uLnN0YXJ0ICsgZHVyRGl2U3BkXG5cbiAgICAgIHJldHVybiB0aGlzLnN0ZXAodHJ1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXRzIG9yIHJldHVybnMgdGhlIHNwZWVkIG9mIHRoZSBhbmltYXRpb25zXG4gICAgICogQHBhcmFtIHNwZWVkIG51bGwgfHwgTnVtYmVyIFRoZSBuZXcgc3BlZWQgb2YgdGhlIGFuaW1hdGlvbnNcbiAgICAgKiBAcmV0dXJuIE51bWJlciB8fCB0aGlzXG4gICAgICovXG4gICwgc3BlZWQ6IGZ1bmN0aW9uKHNwZWVkKXtcbiAgICAgIGlmIChzcGVlZCA9PT0gMCkgcmV0dXJuIHRoaXMucGF1c2UoKVxuXG4gICAgICBpZiAoc3BlZWQpIHtcbiAgICAgICAgdGhpcy5fc3BlZWQgPSBzcGVlZFxuICAgICAgICAvLyBXZSB1c2UgYW4gYWJzb2x1dGUgcG9zaXRpb24gaGVyZSBzbyB0aGF0IHNwZWVkIGNhbiBhZmZlY3QgdGhlIGRlbGF5IGJlZm9yZSB0aGUgYW5pbWF0aW9uXG4gICAgICAgIHJldHVybiB0aGlzLmF0KHRoaXMuYWJzUG9zLCB0cnVlKVxuICAgICAgfSBlbHNlIHJldHVybiB0aGlzLl9zcGVlZFxuICAgIH1cblxuICAgIC8vIE1ha2UgbG9vcGFibGVcbiAgLCBsb29wOiBmdW5jdGlvbih0aW1lcywgcmV2ZXJzZSkge1xuICAgICAgdmFyIGMgPSB0aGlzLmxhc3QoKVxuXG4gICAgICAvLyBzdG9yZSB0b3RhbCBsb29wc1xuICAgICAgYy5sb29wcyA9ICh0aW1lcyAhPSBudWxsKSA/IHRpbWVzIDogdHJ1ZVxuICAgICAgYy5sb29wID0gMFxuXG4gICAgICBpZihyZXZlcnNlKSBjLnJldmVyc2luZyA9IHRydWVcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLy8gcGF1c2VzIHRoZSBhbmltYXRpb25cbiAgLCBwYXVzZTogZnVuY3Rpb24oKXtcbiAgICAgIHRoaXMucGF1c2VkID0gdHJ1ZVxuICAgICAgdGhpcy5zdG9wQW5pbUZyYW1lKClcblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvLyB1bnBhdXNlIHRoZSBhbmltYXRpb25cbiAgLCBwbGF5OiBmdW5jdGlvbigpe1xuICAgICAgaWYoIXRoaXMucGF1c2VkKSByZXR1cm4gdGhpc1xuICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZVxuICAgICAgLy8gV2UgdXNlIGFuIGFic29sdXRlIHBvc2l0aW9uIGhlcmUgc28gdGhhdCB0aGUgZGVsYXkgYmVmb3JlIHRoZSBhbmltYXRpb24gY2FuIGJlIHBhdXNlZFxuICAgICAgcmV0dXJuIHRoaXMuYXQodGhpcy5hYnNQb3MsIHRydWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdG9nZ2xlIG9yIHNldCB0aGUgZGlyZWN0aW9uIG9mIHRoZSBhbmltYXRpb25cbiAgICAgKiB0cnVlIHNldHMgZGlyZWN0aW9uIHRvIGJhY2t3YXJkcyB3aGlsZSBmYWxzZSBzZXRzIGl0IHRvIGZvcndhcmRzXG4gICAgICogQHBhcmFtIHJldmVyc2VkIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRvIHJldmVyc2UgdGhlIGFuaW1hdGlvbiBvciBub3QgKGRlZmF1bHQ6IHRvZ2dsZSB0aGUgcmV2ZXJzZSBzdGF0dXMpXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICwgcmV2ZXJzZTogZnVuY3Rpb24ocmV2ZXJzZWQpe1xuICAgICAgdmFyIGMgPSB0aGlzLmxhc3QoKVxuXG4gICAgICBpZih0eXBlb2YgcmV2ZXJzZWQgPT0gJ3VuZGVmaW5lZCcpIGMucmV2ZXJzZWQgPSAhYy5yZXZlcnNlZFxuICAgICAgZWxzZSBjLnJldmVyc2VkID0gcmV2ZXJzZWRcblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgYSBmbG9hdCBmcm9tIDAtMSBpbmRpY2F0aW5nIHRoZSBwcm9ncmVzcyBvZiB0aGUgY3VycmVudCBhbmltYXRpb25cbiAgICAgKiBAcGFyYW0gZWFzZWQgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHJldHVybmVkIHBvc2l0aW9uIHNob3VsZCBiZSBlYXNlZCBvciBub3RcbiAgICAgKiBAcmV0dXJuIG51bWJlclxuICAgICAqL1xuICAsIHByb2dyZXNzOiBmdW5jdGlvbihlYXNlSXQpe1xuICAgICAgcmV0dXJuIGVhc2VJdCA/IHRoaXMuc2l0dWF0aW9uLmVhc2UodGhpcy5wb3MpIDogdGhpcy5wb3NcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhZGRzIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIHdoZW4gdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGlzIGZpbmlzaGVkXG4gICAgICogQHBhcmFtIGZuIEZ1bmN0aW9uIHdoaWNoIHNob3VsZCBiZSBleGVjdXRlZCBhcyBjYWxsYmFja1xuICAgICAqIEByZXR1cm4gbnVtYmVyXG4gICAgICovXG4gICwgYWZ0ZXI6IGZ1bmN0aW9uKGZuKXtcbiAgICAgIHZhciBjID0gdGhpcy5sYXN0KClcbiAgICAgICAgLCB3cmFwcGVyID0gZnVuY3Rpb24gd3JhcHBlcihlKXtcbiAgICAgICAgICAgIGlmKGUuZGV0YWlsLnNpdHVhdGlvbiA9PSBjKXtcbiAgICAgICAgICAgICAgZm4uY2FsbCh0aGlzLCBjKVxuICAgICAgICAgICAgICB0aGlzLm9mZignZmluaXNoZWQuZngnLCB3cmFwcGVyKSAvLyBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICB0aGlzLnRhcmdldCgpLm9uKCdmaW5pc2hlZC5meCcsIHdyYXBwZXIpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8vIGFkZHMgYSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbmV2ZXIgb25lIGFuaW1hdGlvbiBzdGVwIGlzIHBlcmZvcm1lZFxuICAsIGR1cmluZzogZnVuY3Rpb24oZm4pe1xuICAgICAgdmFyIGMgPSB0aGlzLmxhc3QoKVxuICAgICAgICAsIHdyYXBwZXIgPSBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgIGlmKGUuZGV0YWlsLnNpdHVhdGlvbiA9PSBjKXtcbiAgICAgICAgICAgICAgZm4uY2FsbCh0aGlzLCBlLmRldGFpbC5wb3MsIFNWRy5tb3JwaChlLmRldGFpbC5wb3MpLCBlLmRldGFpbC5lYXNlZCwgYylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgIC8vIHNlZSBhYm92ZVxuICAgICAgdGhpcy50YXJnZXQoKS5vZmYoJ2R1cmluZy5meCcsIHdyYXBwZXIpLm9uKCdkdXJpbmcuZngnLCB3cmFwcGVyKVxuXG4gICAgICByZXR1cm4gdGhpcy5hZnRlcihmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLm9mZignZHVyaW5nLmZ4Jywgd3JhcHBlcilcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gY2FsbHMgYWZ0ZXIgQUxMIGFuaW1hdGlvbnMgaW4gdGhlIHF1ZXVlIGFyZSBmaW5pc2hlZFxuICAsIGFmdGVyQWxsOiBmdW5jdGlvbihmbil7XG4gICAgICB2YXIgd3JhcHBlciA9IGZ1bmN0aW9uIHdyYXBwZXIoZSl7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMpXG4gICAgICAgICAgICB0aGlzLm9mZignYWxsZmluaXNoZWQuZngnLCB3cmFwcGVyKVxuICAgICAgICAgIH1cblxuICAgICAgLy8gc2VlIGFib3ZlXG4gICAgICB0aGlzLnRhcmdldCgpLm9mZignYWxsZmluaXNoZWQuZngnLCB3cmFwcGVyKS5vbignYWxsZmluaXNoZWQuZngnLCB3cmFwcGVyKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvLyBjYWxscyBvbiBldmVyeSBhbmltYXRpb24gc3RlcCBmb3IgYWxsIGFuaW1hdGlvbnNcbiAgLCBkdXJpbmdBbGw6IGZ1bmN0aW9uKGZuKXtcbiAgICAgIHZhciB3cmFwcGVyID0gZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMsIGUuZGV0YWlsLnBvcywgU1ZHLm1vcnBoKGUuZGV0YWlsLnBvcyksIGUuZGV0YWlsLmVhc2VkLCBlLmRldGFpbC5zaXR1YXRpb24pXG4gICAgICAgICAgfVxuXG4gICAgICB0aGlzLnRhcmdldCgpLm9mZignZHVyaW5nLmZ4Jywgd3JhcHBlcikub24oJ2R1cmluZy5meCcsIHdyYXBwZXIpXG5cbiAgICAgIHJldHVybiB0aGlzLmFmdGVyQWxsKGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMub2ZmKCdkdXJpbmcuZngnLCB3cmFwcGVyKVxuICAgICAgfSlcbiAgICB9XG5cbiAgLCBsYXN0OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuc2l0dWF0aW9ucy5sZW5ndGggPyB0aGlzLnNpdHVhdGlvbnNbdGhpcy5zaXR1YXRpb25zLmxlbmd0aC0xXSA6IHRoaXMuc2l0dWF0aW9uXG4gICAgfVxuXG4gICAgLy8gYWRkcyBvbmUgcHJvcGVydHkgdG8gdGhlIGFuaW1hdGlvbnNcbiAgLCBhZGQ6IGZ1bmN0aW9uKG1ldGhvZCwgYXJncywgdHlwZSl7XG4gICAgICB0aGlzLmxhc3QoKVt0eXBlIHx8ICdhbmltYXRpb25zJ11bbWV0aG9kXSA9IGFyZ3NcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXt0aGlzLnN0YXJ0KCl9LmJpbmQodGhpcyksIDApXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKiBwZXJmb3JtIG9uZSBzdGVwIG9mIHRoZSBhbmltYXRpb25cbiAgICAgKiAgQHBhcmFtIGlnbm9yZVRpbWUgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gaWdub3JlIHRpbWUgYW5kIHVzZSBwb3NpdGlvbiBkaXJlY3RseSBvciByZWNhbGN1bGF0ZSBwb3NpdGlvbiBiYXNlZCBvbiB0aW1lXG4gICAgICogIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAsIHN0ZXA6IGZ1bmN0aW9uKGlnbm9yZVRpbWUpe1xuXG4gICAgICAvLyBjb252ZXJ0IGN1cnJlbnQgdGltZSB0byBhbiBhYnNvbHV0ZSBwb3NpdGlvblxuICAgICAgaWYoIWlnbm9yZVRpbWUpIHRoaXMuYWJzUG9zID0gdGhpcy50aW1lVG9BYnNQb3MoK25ldyBEYXRlKVxuXG4gICAgICAvLyBUaGlzIHBhcnQgY29udmVydCBhbiBhYnNvbHV0ZSBwb3NpdGlvbiB0byBhIHBvc2l0aW9uXG4gICAgICBpZih0aGlzLnNpdHVhdGlvbi5sb29wcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgdmFyIGFic1BvcywgYWJzUG9zSW50LCBsYXN0TG9vcFxuXG4gICAgICAgIC8vIElmIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBpcyBiZWxvdyAwLCB3ZSBqdXN0IHRyZWF0IGl0IGFzIGlmIGl0IHdhcyAwXG4gICAgICAgIGFic1BvcyA9IE1hdGgubWF4KHRoaXMuYWJzUG9zLCAwKVxuICAgICAgICBhYnNQb3NJbnQgPSBNYXRoLmZsb29yKGFic1BvcylcblxuICAgICAgICBpZih0aGlzLnNpdHVhdGlvbi5sb29wcyA9PT0gdHJ1ZSB8fCBhYnNQb3NJbnQgPCB0aGlzLnNpdHVhdGlvbi5sb29wcykge1xuICAgICAgICAgIHRoaXMucG9zID0gYWJzUG9zIC0gYWJzUG9zSW50XG4gICAgICAgICAgbGFzdExvb3AgPSB0aGlzLnNpdHVhdGlvbi5sb29wXG4gICAgICAgICAgdGhpcy5zaXR1YXRpb24ubG9vcCA9IGFic1Bvc0ludFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYWJzUG9zID0gdGhpcy5zaXR1YXRpb24ubG9vcHNcbiAgICAgICAgICB0aGlzLnBvcyA9IDFcbiAgICAgICAgICAvLyBUaGUgLTEgaGVyZSBpcyBiZWNhdXNlIHdlIGRvbid0IHdhbnQgdG8gdG9nZ2xlIHJldmVyc2VkIHdoZW4gYWxsIHRoZSBsb29wcyBoYXZlIGJlZW4gY29tcGxldGVkXG4gICAgICAgICAgbGFzdExvb3AgPSB0aGlzLnNpdHVhdGlvbi5sb29wIC0gMVxuICAgICAgICAgIHRoaXMuc2l0dWF0aW9uLmxvb3AgPSB0aGlzLnNpdHVhdGlvbi5sb29wc1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5zaXR1YXRpb24ucmV2ZXJzaW5nKSB7XG4gICAgICAgICAgLy8gVG9nZ2xlIHJldmVyc2VkIGlmIGFuIG9kZCBudW1iZXIgb2YgbG9vcHMgYXMgb2NjdXJlZCBzaW5jZSB0aGUgbGFzdCBjYWxsIG9mIHN0ZXBcbiAgICAgICAgICB0aGlzLnNpdHVhdGlvbi5yZXZlcnNlZCA9IHRoaXMuc2l0dWF0aW9uLnJldmVyc2VkICE9IEJvb2xlYW4oKHRoaXMuc2l0dWF0aW9uLmxvb3AgLSBsYXN0TG9vcCkgJSAyKVxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBsb29wLCB0aGUgYWJzb2x1dGUgcG9zaXRpb24gbXVzdCBub3QgYmUgYWJvdmUgMVxuICAgICAgICB0aGlzLmFic1BvcyA9IE1hdGgubWluKHRoaXMuYWJzUG9zLCAxKVxuICAgICAgICB0aGlzLnBvcyA9IHRoaXMuYWJzUG9zXG4gICAgICB9XG5cbiAgICAgIC8vIHdoaWxlIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBjYW4gYmUgYmVsb3cgMCwgdGhlIHBvc2l0aW9uIG11c3Qgbm90IGJlIGJlbG93IDBcbiAgICAgIGlmKHRoaXMucG9zIDwgMCkgdGhpcy5wb3MgPSAwXG5cbiAgICAgIGlmKHRoaXMuc2l0dWF0aW9uLnJldmVyc2VkKSB0aGlzLnBvcyA9IDEgLSB0aGlzLnBvc1xuXG5cbiAgICAgIC8vIGFwcGx5IGVhc2luZ1xuICAgICAgdmFyIGVhc2VkID0gdGhpcy5zaXR1YXRpb24uZWFzZSh0aGlzLnBvcylcblxuICAgICAgLy8gY2FsbCBvbmNlLWNhbGxiYWNrc1xuICAgICAgZm9yKHZhciBpIGluIHRoaXMuc2l0dWF0aW9uLm9uY2Upe1xuICAgICAgICBpZihpID4gdGhpcy5sYXN0UG9zICYmIGkgPD0gZWFzZWQpe1xuICAgICAgICAgIHRoaXMuc2l0dWF0aW9uLm9uY2VbaV0uY2FsbCh0aGlzLnRhcmdldCgpLCB0aGlzLnBvcywgZWFzZWQpXG4gICAgICAgICAgZGVsZXRlIHRoaXMuc2l0dWF0aW9uLm9uY2VbaV1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBmaXJlIGR1cmluZyBjYWxsYmFjayB3aXRoIHBvc2l0aW9uLCBlYXNlZCBwb3NpdGlvbiBhbmQgY3VycmVudCBzaXR1YXRpb24gYXMgcGFyYW1ldGVyXG4gICAgICBpZih0aGlzLmFjdGl2ZSkgdGhpcy50YXJnZXQoKS5maXJlKCdkdXJpbmcnLCB7cG9zOiB0aGlzLnBvcywgZWFzZWQ6IGVhc2VkLCBmeDogdGhpcywgc2l0dWF0aW9uOiB0aGlzLnNpdHVhdGlvbn0pXG5cbiAgICAgIC8vIHRoZSB1c2VyIG1heSBjYWxsIHN0b3Agb3IgZmluaXNoIGluIHRoZSBkdXJpbmcgY2FsbGJhY2tcbiAgICAgIC8vIHNvIG1ha2Ugc3VyZSB0aGF0IHdlIHN0aWxsIGhhdmUgYSB2YWxpZCBzaXR1YXRpb25cbiAgICAgIGlmKCF0aGlzLnNpdHVhdGlvbil7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IHRoZSBhY3R1YWwgYW5pbWF0aW9uIHRvIGV2ZXJ5IHByb3BlcnR5XG4gICAgICB0aGlzLmVhY2hBdCgpXG5cbiAgICAgIC8vIGRvIGZpbmFsIGNvZGUgd2hlbiBzaXR1YXRpb24gaXMgZmluaXNoZWRcbiAgICAgIGlmKCh0aGlzLnBvcyA9PSAxICYmICF0aGlzLnNpdHVhdGlvbi5yZXZlcnNlZCkgfHwgKHRoaXMuc2l0dWF0aW9uLnJldmVyc2VkICYmIHRoaXMucG9zID09IDApKXtcblxuICAgICAgICAvLyBzdG9wIGFuaW1hdGlvbiBjYWxsYmFja1xuICAgICAgICB0aGlzLnN0b3BBbmltRnJhbWUoKVxuXG4gICAgICAgIC8vIGZpcmUgZmluaXNoZWQgY2FsbGJhY2sgd2l0aCBjdXJyZW50IHNpdHVhdGlvbiBhcyBwYXJhbWV0ZXJcbiAgICAgICAgdGhpcy50YXJnZXQoKS5maXJlKCdmaW5pc2hlZCcsIHtmeDp0aGlzLCBzaXR1YXRpb246IHRoaXMuc2l0dWF0aW9ufSlcblxuICAgICAgICBpZighdGhpcy5zaXR1YXRpb25zLmxlbmd0aCl7XG4gICAgICAgICAgdGhpcy50YXJnZXQoKS5maXJlKCdhbGxmaW5pc2hlZCcpXG4gICAgICAgICAgdGhpcy50YXJnZXQoKS5vZmYoJy5meCcpIC8vIHRoZXJlIHNob3VsZG50IGJlIGFueSBiaW5kaW5nIGxlZnQsIGJ1dCB0byBtYWtlIHN1cmUuLi5cbiAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdGFydCBuZXh0IGFuaW1hdGlvblxuICAgICAgICBpZih0aGlzLmFjdGl2ZSkgdGhpcy5kZXF1ZXVlKClcbiAgICAgICAgZWxzZSB0aGlzLmNsZWFyQ3VycmVudCgpXG5cbiAgICAgIH1lbHNlIGlmKCF0aGlzLnBhdXNlZCAmJiB0aGlzLmFjdGl2ZSl7XG4gICAgICAgIC8vIHdlIGNvbnRpbnVlIGFuaW1hdGluZyB3aGVuIHdlIGFyZSBub3QgYXQgdGhlIGVuZFxuICAgICAgICB0aGlzLnN0YXJ0QW5pbUZyYW1lKClcbiAgICAgIH1cblxuICAgICAgLy8gc2F2ZSBsYXN0IGVhc2VkIHBvc2l0aW9uIGZvciBvbmNlIGNhbGxiYWNrIHRyaWdnZXJpbmdcbiAgICAgIHRoaXMubGFzdFBvcyA9IGVhc2VkXG4gICAgICByZXR1cm4gdGhpc1xuXG4gICAgfVxuXG4gICAgLy8gY2FsY3VsYXRlcyB0aGUgc3RlcCBmb3IgZXZlcnkgcHJvcGVydHkgYW5kIGNhbGxzIGJsb2NrIHdpdGggaXRcbiAgLCBlYWNoQXQ6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgaSwgYXQsIHNlbGYgPSB0aGlzLCB0YXJnZXQgPSB0aGlzLnRhcmdldCgpLCBzID0gdGhpcy5zaXR1YXRpb25cblxuICAgICAgLy8gYXBwbHkgYW5pbWF0aW9ucyB3aGljaCBjYW4gYmUgY2FsbGVkIHRyb3VnaCBhIG1ldGhvZFxuICAgICAgZm9yKGkgaW4gcy5hbmltYXRpb25zKXtcblxuICAgICAgICBhdCA9IFtdLmNvbmNhdChzLmFuaW1hdGlvbnNbaV0pLm1hcChmdW5jdGlvbihlbCl7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBlbCAhPT0gJ3N0cmluZycgJiYgZWwuYXQgPyBlbC5hdChzLmVhc2Uoc2VsZi5wb3MpLCBzZWxmLnBvcykgOiBlbFxuICAgICAgICB9KVxuXG4gICAgICAgIHRhcmdldFtpXS5hcHBseSh0YXJnZXQsIGF0KVxuXG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IGFuaW1hdGlvbiB3aGljaCBoYXMgdG8gYmUgYXBwbGllZCB3aXRoIGF0dHIoKVxuICAgICAgZm9yKGkgaW4gcy5hdHRycyl7XG5cbiAgICAgICAgYXQgPSBbaV0uY29uY2F0KHMuYXR0cnNbaV0pLm1hcChmdW5jdGlvbihlbCl7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBlbCAhPT0gJ3N0cmluZycgJiYgZWwuYXQgPyBlbC5hdChzLmVhc2Uoc2VsZi5wb3MpLCBzZWxmLnBvcykgOiBlbFxuICAgICAgICB9KVxuXG4gICAgICAgIHRhcmdldC5hdHRyLmFwcGx5KHRhcmdldCwgYXQpXG5cbiAgICAgIH1cblxuICAgICAgLy8gYXBwbHkgYW5pbWF0aW9uIHdoaWNoIGhhcyB0byBiZSBhcHBsaWVkIHdpdGggc3R5bGUoKVxuICAgICAgZm9yKGkgaW4gcy5zdHlsZXMpe1xuXG4gICAgICAgIGF0ID0gW2ldLmNvbmNhdChzLnN0eWxlc1tpXSkubWFwKGZ1bmN0aW9uKGVsKXtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIGVsICE9PSAnc3RyaW5nJyAmJiBlbC5hdCA/IGVsLmF0KHMuZWFzZShzZWxmLnBvcyksIHNlbGYucG9zKSA6IGVsXG4gICAgICAgIH0pXG5cbiAgICAgICAgdGFyZ2V0LnN0eWxlLmFwcGx5KHRhcmdldCwgYXQpXG5cbiAgICAgIH1cblxuICAgICAgLy8gYW5pbWF0ZSBpbml0aWFsVHJhbnNmb3JtYXRpb24gd2hpY2ggaGFzIHRvIGJlIGNoYWluZWRcbiAgICAgIGlmKHMudHJhbnNmb3Jtcy5sZW5ndGgpe1xuXG4gICAgICAgIC8vIGdldCBpbml0aWFsIGluaXRpYWxUcmFuc2Zvcm1hdGlvblxuICAgICAgICBhdCA9IHMuaW5pdGlhbFRyYW5zZm9ybWF0aW9uXG4gICAgICAgIGZvcihpID0gMCwgbGVuID0gcy50cmFuc2Zvcm1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKXtcblxuICAgICAgICAgIC8vIGdldCBuZXh0IHRyYW5zZm9ybWF0aW9uIGluIGNoYWluXG4gICAgICAgICAgdmFyIGEgPSBzLnRyYW5zZm9ybXNbaV1cblxuICAgICAgICAgIC8vIG11bHRpcGx5IG1hdHJpeCBkaXJlY3RseVxuICAgICAgICAgIGlmKGEgaW5zdGFuY2VvZiBTVkcuTWF0cml4KXtcblxuICAgICAgICAgICAgaWYoYS5yZWxhdGl2ZSl7XG4gICAgICAgICAgICAgIGF0ID0gYXQubXVsdGlwbHkobmV3IFNWRy5NYXRyaXgoKS5tb3JwaChhKS5hdChzLmVhc2UodGhpcy5wb3MpKSlcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICBhdCA9IGF0Lm1vcnBoKGEpLmF0KHMuZWFzZSh0aGlzLnBvcykpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHdoZW4gdHJhbnNmb3JtYXRpb24gaXMgYWJzb2x1dGUgd2UgaGF2ZSB0byByZXNldCB0aGUgbmVlZGVkIHRyYW5zZm9ybWF0aW9uIGZpcnN0XG4gICAgICAgICAgaWYoIWEucmVsYXRpdmUpXG4gICAgICAgICAgICBhLnVuZG8oYXQuZXh0cmFjdCgpKVxuXG4gICAgICAgICAgLy8gYW5kIHJlYXBwbHkgaXQgYWZ0ZXJcbiAgICAgICAgICBhdCA9IGF0Lm11bHRpcGx5KGEuYXQocy5lYXNlKHRoaXMucG9zKSkpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCBuZXcgbWF0cml4IG9uIGVsZW1lbnRcbiAgICAgICAgdGFyZ2V0Lm1hdHJpeChhdClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXNcblxuICAgIH1cblxuXG4gICAgLy8gYWRkcyBhbiBvbmNlLWNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhdCBhIHNwZWNpZmljIHBvc2l0aW9uIGFuZCBuZXZlciBhZ2FpblxuICAsIG9uY2U6IGZ1bmN0aW9uKHBvcywgZm4sIGlzRWFzZWQpe1xuXG4gICAgICBpZighaXNFYXNlZClwb3MgPSB0aGlzLnNpdHVhdGlvbi5lYXNlKHBvcylcblxuICAgICAgdGhpcy5zaXR1YXRpb24ub25jZVtwb3NdID0gZm5cblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgfVxuXG4sIHBhcmVudDogU1ZHLkVsZW1lbnRcblxuICAvLyBBZGQgbWV0aG9kIHRvIHBhcmVudCBlbGVtZW50c1xuLCBjb25zdHJ1Y3Q6IHtcbiAgICAvLyBHZXQgZnggbW9kdWxlIG9yIGNyZWF0ZSBhIG5ldyBvbmUsIHRoZW4gYW5pbWF0ZSB3aXRoIGdpdmVuIGR1cmF0aW9uIGFuZCBlYXNlXG4gICAgYW5pbWF0ZTogZnVuY3Rpb24obywgZWFzZSwgZGVsYXkpIHtcbiAgICAgIHJldHVybiAodGhpcy5meCB8fCAodGhpcy5meCA9IG5ldyBTVkcuRlgodGhpcykpKS5hbmltYXRlKG8sIGVhc2UsIGRlbGF5KVxuICAgIH1cbiAgLCBkZWxheTogZnVuY3Rpb24oZGVsYXkpe1xuICAgICAgcmV0dXJuICh0aGlzLmZ4IHx8ICh0aGlzLmZ4ID0gbmV3IFNWRy5GWCh0aGlzKSkpLmRlbGF5KGRlbGF5KVxuICAgIH1cbiAgLCBzdG9wOiBmdW5jdGlvbihqdW1wVG9FbmQsIGNsZWFyUXVldWUpIHtcbiAgICAgIGlmICh0aGlzLmZ4KVxuICAgICAgICB0aGlzLmZ4LnN0b3AoanVtcFRvRW5kLCBjbGVhclF1ZXVlKVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgLCBmaW5pc2g6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZngpXG4gICAgICAgIHRoaXMuZnguZmluaXNoKClcblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgLy8gUGF1c2UgY3VycmVudCBhbmltYXRpb25cbiAgLCBwYXVzZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5meClcbiAgICAgICAgdGhpcy5meC5wYXVzZSgpXG5cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIC8vIFBsYXkgcGF1c2VkIGN1cnJlbnQgYW5pbWF0aW9uXG4gICwgcGxheTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5meClcbiAgICAgICAgdGhpcy5meC5wbGF5KClcblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgLy8gU2V0L0dldCB0aGUgc3BlZWQgb2YgdGhlIGFuaW1hdGlvbnNcbiAgLCBzcGVlZDogZnVuY3Rpb24oc3BlZWQpIHtcbiAgICAgIGlmICh0aGlzLmZ4KVxuICAgICAgICBpZiAoc3BlZWQgPT0gbnVsbClcbiAgICAgICAgICByZXR1cm4gdGhpcy5meC5zcGVlZCgpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aGlzLmZ4LnNwZWVkKHNwZWVkKVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgfVxuXG59KVxuXG4vLyBNb3JwaE9iaiBpcyB1c2VkIHdoZW5ldmVyIG5vIG1vcnBoYWJsZSBvYmplY3QgaXMgZ2l2ZW5cblNWRy5Nb3JwaE9iaiA9IFNWRy5pbnZlbnQoe1xuXG4gIGNyZWF0ZTogZnVuY3Rpb24oZnJvbSwgdG8pe1xuICAgIC8vIHByZXBhcmUgY29sb3IgZm9yIG1vcnBoaW5nXG4gICAgaWYoU1ZHLkNvbG9yLmlzQ29sb3IodG8pKSByZXR1cm4gbmV3IFNWRy5Db2xvcihmcm9tKS5tb3JwaCh0bylcbiAgICAvLyBwcmVwYXJlIG51bWJlciBmb3IgbW9ycGhpbmdcbiAgICBpZihTVkcucmVnZXgubnVtYmVyQW5kVW5pdC50ZXN0KHRvKSkgcmV0dXJuIG5ldyBTVkcuTnVtYmVyKGZyb20pLm1vcnBoKHRvKVxuXG4gICAgLy8gcHJlcGFyZSBmb3IgcGxhaW4gbW9ycGhpbmdcbiAgICB0aGlzLnZhbHVlID0gMFxuICAgIHRoaXMuZGVzdGluYXRpb24gPSB0b1xuICB9XG5cbiwgZXh0ZW5kOiB7XG4gICAgYXQ6IGZ1bmN0aW9uKHBvcywgcmVhbCl7XG4gICAgICByZXR1cm4gcmVhbCA8IDEgPyB0aGlzLnZhbHVlIDogdGhpcy5kZXN0aW5hdGlvblxuICAgIH0sXG5cbiAgICB2YWx1ZU9mOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWVcbiAgICB9XG4gIH1cblxufSlcblxuU1ZHLmV4dGVuZChTVkcuRlgsIHtcbiAgLy8gQWRkIGFuaW1hdGFibGUgYXR0cmlidXRlc1xuICBhdHRyOiBmdW5jdGlvbihhLCB2LCByZWxhdGl2ZSkge1xuICAgIC8vIGFwcGx5IGF0dHJpYnV0ZXMgaW5kaXZpZHVhbGx5XG4gICAgaWYgKHR5cGVvZiBhID09ICdvYmplY3QnKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gYSlcbiAgICAgICAgdGhpcy5hdHRyKGtleSwgYVtrZXldKVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRoZSBNb3JwaE9iaiB0YWtlcyBjYXJlIGFib3V0IHRoZSByaWdodCBmdW5jdGlvbiB1c2VkXG4gICAgICB0aGlzLmFkZChhLCBuZXcgU1ZHLk1vcnBoT2JqKG51bGwsIHYpLCAnYXR0cnMnKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cbiAgLy8gQWRkIGFuaW1hdGFibGUgc3R5bGVzXG4sIHN0eWxlOiBmdW5jdGlvbihzLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBzID09ICdvYmplY3QnKVxuICAgICAgZm9yICh2YXIga2V5IGluIHMpXG4gICAgICAgIHRoaXMuc3R5bGUoa2V5LCBzW2tleV0pXG5cbiAgICBlbHNlXG4gICAgICB0aGlzLmFkZChzLCBuZXcgU1ZHLk1vcnBoT2JqKG51bGwsIHYpLCAnc3R5bGVzJylcblxuICAgIHJldHVybiB0aGlzXG4gIH1cbiAgLy8gQW5pbWF0YWJsZSB4LWF4aXNcbiwgeDogZnVuY3Rpb24oeCwgcmVsYXRpdmUpIHtcbiAgICBpZih0aGlzLnRhcmdldCgpIGluc3RhbmNlb2YgU1ZHLkcpe1xuICAgICAgdGhpcy50cmFuc2Zvcm0oe3g6eH0sIHJlbGF0aXZlKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICB2YXIgbnVtID0gbmV3IFNWRy5OdW1iZXIoKS5tb3JwaCh4KVxuICAgIG51bS5yZWxhdGl2ZSA9IHJlbGF0aXZlXG4gICAgcmV0dXJuIHRoaXMuYWRkKCd4JywgbnVtKVxuICB9XG4gIC8vIEFuaW1hdGFibGUgeS1heGlzXG4sIHk6IGZ1bmN0aW9uKHksIHJlbGF0aXZlKSB7XG4gICAgaWYodGhpcy50YXJnZXQoKSBpbnN0YW5jZW9mIFNWRy5HKXtcbiAgICAgIHRoaXMudHJhbnNmb3JtKHt5Onl9LCByZWxhdGl2ZSlcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgdmFyIG51bSA9IG5ldyBTVkcuTnVtYmVyKCkubW9ycGgoeSlcbiAgICBudW0ucmVsYXRpdmUgPSByZWxhdGl2ZVxuICAgIHJldHVybiB0aGlzLmFkZCgneScsIG51bSlcbiAgfVxuICAvLyBBbmltYXRhYmxlIGNlbnRlciB4LWF4aXNcbiwgY3g6IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gdGhpcy5hZGQoJ2N4JywgbmV3IFNWRy5OdW1iZXIoKS5tb3JwaCh4KSlcbiAgfVxuICAvLyBBbmltYXRhYmxlIGNlbnRlciB5LWF4aXNcbiwgY3k6IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gdGhpcy5hZGQoJ2N5JywgbmV3IFNWRy5OdW1iZXIoKS5tb3JwaCh5KSlcbiAgfVxuICAvLyBBZGQgYW5pbWF0YWJsZSBtb3ZlXG4sIG1vdmU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy54KHgpLnkoeSlcbiAgfVxuICAvLyBBZGQgYW5pbWF0YWJsZSBjZW50ZXJcbiwgY2VudGVyOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuY3goeCkuY3koeSlcbiAgfVxuICAvLyBBZGQgYW5pbWF0YWJsZSBzaXplXG4sIHNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAodGhpcy50YXJnZXQoKSBpbnN0YW5jZW9mIFNWRy5UZXh0KSB7XG4gICAgICAvLyBhbmltYXRlIGZvbnQgc2l6ZSBmb3IgVGV4dCBlbGVtZW50c1xuICAgICAgdGhpcy5hdHRyKCdmb250LXNpemUnLCB3aWR0aClcblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhbmltYXRlIGJib3ggYmFzZWQgc2l6ZSBmb3IgYWxsIG90aGVyIGVsZW1lbnRzXG4gICAgICB2YXIgYm94XG5cbiAgICAgIGlmKCF3aWR0aCB8fCAhaGVpZ2h0KXtcbiAgICAgICAgYm94ID0gdGhpcy50YXJnZXQoKS5iYm94KClcbiAgICAgIH1cblxuICAgICAgaWYoIXdpZHRoKXtcbiAgICAgICAgd2lkdGggPSBib3gud2lkdGggLyBib3guaGVpZ2h0ICAqIGhlaWdodFxuICAgICAgfVxuXG4gICAgICBpZighaGVpZ2h0KXtcbiAgICAgICAgaGVpZ2h0ID0gYm94LmhlaWdodCAvIGJveC53aWR0aCAgKiB3aWR0aFxuICAgICAgfVxuXG4gICAgICB0aGlzLmFkZCgnd2lkdGgnICwgbmV3IFNWRy5OdW1iZXIoKS5tb3JwaCh3aWR0aCkpXG4gICAgICAgICAgLmFkZCgnaGVpZ2h0JywgbmV3IFNWRy5OdW1iZXIoKS5tb3JwaChoZWlnaHQpKVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuICAvLyBBZGQgYW5pbWF0YWJsZSBwbG90XG4sIHBsb3Q6IGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gdGhpcy5hZGQoJ3Bsb3QnLCB0aGlzLnRhcmdldCgpLmFycmF5KCkubW9ycGgocCkpXG4gIH1cbiAgLy8gQWRkIGxlYWRpbmcgbWV0aG9kXG4sIGxlYWRpbmc6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMudGFyZ2V0KCkubGVhZGluZyA/XG4gICAgICB0aGlzLmFkZCgnbGVhZGluZycsIG5ldyBTVkcuTnVtYmVyKCkubW9ycGgodmFsdWUpKSA6XG4gICAgICB0aGlzXG4gIH1cbiAgLy8gQWRkIGFuaW1hdGFibGUgdmlld2JveFxuLCB2aWV3Ym94OiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKHRoaXMudGFyZ2V0KCkgaW5zdGFuY2VvZiBTVkcuQ29udGFpbmVyKSB7XG4gICAgICB0aGlzLmFkZCgndmlld2JveCcsIG5ldyBTVkcuVmlld0JveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG4sIHVwZGF0ZTogZnVuY3Rpb24obykge1xuICAgIGlmICh0aGlzLnRhcmdldCgpIGluc3RhbmNlb2YgU1ZHLlN0b3ApIHtcbiAgICAgIGlmICh0eXBlb2YgbyA9PSAnbnVtYmVyJyB8fCBvIGluc3RhbmNlb2YgU1ZHLk51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoe1xuICAgICAgICAgIG9mZnNldDogIGFyZ3VtZW50c1swXVxuICAgICAgICAsIGNvbG9yOiAgIGFyZ3VtZW50c1sxXVxuICAgICAgICAsIG9wYWNpdHk6IGFyZ3VtZW50c1syXVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBpZiAoby5vcGFjaXR5ICE9IG51bGwpIHRoaXMuYXR0cignc3RvcC1vcGFjaXR5Jywgby5vcGFjaXR5KVxuICAgICAgaWYgKG8uY29sb3IgICAhPSBudWxsKSB0aGlzLmF0dHIoJ3N0b3AtY29sb3InLCBvLmNvbG9yKVxuICAgICAgaWYgKG8ub2Zmc2V0ICAhPSBudWxsKSB0aGlzLmF0dHIoJ29mZnNldCcsIG8ub2Zmc2V0KVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cbn0pXG5cblNWRy5CQm94ID0gU1ZHLmludmVudCh7XG4gIC8vIEluaXRpYWxpemVcbiAgY3JlYXRlOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgLy8gZ2V0IHZhbHVlcyBpZiBlbGVtZW50IGlzIGdpdmVuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBib3hcblxuICAgICAgLy8geWVzIHRoaXMgaXMgdWdseSwgYnV0IEZpcmVmb3ggY2FuIGJlIGEgYml0Y2ggd2hlbiBpdCBjb21lcyB0byBlbGVtZW50cyB0aGF0IGFyZSBub3QgeWV0IHJlbmRlcmVkXG4gICAgICB0cnkge1xuXG4gICAgICAgIC8vIHRoZSBlbGVtZW50IGlzIE5PVCBpbiB0aGUgZG9tLCB0aHJvdyBlcnJvclxuICAgICAgICBpZighZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKGVsZW1lbnQubm9kZSkpIHRocm93IG5ldyBFeGNlcHRpb24oJ0VsZW1lbnQgbm90IGluIHRoZSBkb20nKVxuXG4gICAgICAgIC8vIGZpbmQgbmF0aXZlIGJib3hcbiAgICAgICAgYm94ID0gZWxlbWVudC5ub2RlLmdldEJCb3goKVxuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGlmKGVsZW1lbnQgaW5zdGFuY2VvZiBTVkcuU2hhcGUpe1xuICAgICAgICAgIHZhciBjbG9uZSA9IGVsZW1lbnQuY2xvbmUoU1ZHLnBhcnNlci5kcmF3KS5zaG93KClcbiAgICAgICAgICBib3ggPSBjbG9uZS5iYm94KClcbiAgICAgICAgICBjbG9uZS5yZW1vdmUoKVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBib3ggPSB7XG4gICAgICAgICAgICB4OiAgICAgIGVsZW1lbnQubm9kZS5jbGllbnRMZWZ0XG4gICAgICAgICAgLCB5OiAgICAgIGVsZW1lbnQubm9kZS5jbGllbnRUb3BcbiAgICAgICAgICAsIHdpZHRoOiAgZWxlbWVudC5ub2RlLmNsaWVudFdpZHRoXG4gICAgICAgICAgLCBoZWlnaHQ6IGVsZW1lbnQubm9kZS5jbGllbnRIZWlnaHRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcGxhaW4geCBhbmQgeVxuICAgICAgdGhpcy54ID0gYm94LnhcbiAgICAgIHRoaXMueSA9IGJveC55XG5cbiAgICAgIC8vIHBsYWluIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgIHRoaXMud2lkdGggID0gYm94LndpZHRoXG4gICAgICB0aGlzLmhlaWdodCA9IGJveC5oZWlnaHRcbiAgICB9XG5cbiAgICAvLyBhZGQgY2VudGVyLCByaWdodCBhbmQgYm90dG9tXG4gICAgZnVsbEJveCh0aGlzKVxuICB9XG5cbiAgLy8gRGVmaW5lIFBhcmVudFxuLCBwYXJlbnQ6IFNWRy5FbGVtZW50XG5cbiAgLy8gQ29uc3RydWN0b3JcbiwgY29uc3RydWN0OiB7XG4gICAgLy8gR2V0IGJvdW5kaW5nIGJveFxuICAgIGJib3g6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBTVkcuQkJveCh0aGlzKVxuICAgIH1cbiAgfVxuXG59KVxuXG5TVkcuVEJveCA9IFNWRy5pbnZlbnQoe1xuICAvLyBJbml0aWFsaXplXG4gIGNyZWF0ZTogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIC8vIGdldCB2YWx1ZXMgaWYgZWxlbWVudCBpcyBnaXZlblxuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgdCAgID0gZWxlbWVudC5jdG0oKS5leHRyYWN0KClcbiAgICAgICAgLCBib3ggPSBlbGVtZW50LmJib3goKVxuXG4gICAgICAvLyB3aWR0aCBhbmQgaGVpZ2h0IGluY2x1ZGluZyB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgIHRoaXMud2lkdGggID0gYm94LndpZHRoICAqIHQuc2NhbGVYXG4gICAgICB0aGlzLmhlaWdodCA9IGJveC5oZWlnaHQgKiB0LnNjYWxlWVxuXG4gICAgICAvLyB4IGFuZCB5IGluY2x1ZGluZyB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgIHRoaXMueCA9IGJveC54ICsgdC54XG4gICAgICB0aGlzLnkgPSBib3gueSArIHQueVxuICAgIH1cblxuICAgIC8vIGFkZCBjZW50ZXIsIHJpZ2h0IGFuZCBib3R0b21cbiAgICBmdWxsQm94KHRoaXMpXG4gIH1cblxuICAvLyBEZWZpbmUgUGFyZW50XG4sIHBhcmVudDogU1ZHLkVsZW1lbnRcblxuICAvLyBDb25zdHJ1Y3RvclxuLCBjb25zdHJ1Y3Q6IHtcbiAgICAvLyBHZXQgdHJhbnNmb3JtZWQgYm91bmRpbmcgYm94XG4gICAgdGJveDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IFNWRy5UQm94KHRoaXMpXG4gICAgfVxuICB9XG5cbn0pXG5cblxuU1ZHLlJCb3ggPSBTVkcuaW52ZW50KHtcbiAgLy8gSW5pdGlhbGl6ZVxuICBjcmVhdGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIGUgICAgPSBlbGVtZW50LmRvYygpLnBhcmVudCgpXG4gICAgICAgICwgYm94ICA9IGVsZW1lbnQubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICAsIHpvb20gPSAxXG5cbiAgICAgIC8vIGdldCBzY3JlZW4gb2Zmc2V0XG4gICAgICB0aGlzLnggPSBib3gubGVmdFxuICAgICAgdGhpcy55ID0gYm94LnRvcFxuXG4gICAgICAvLyBzdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0XG4gICAgICB0aGlzLnggLT0gZS5vZmZzZXRMZWZ0XG4gICAgICB0aGlzLnkgLT0gZS5vZmZzZXRUb3BcblxuICAgICAgd2hpbGUgKGUgPSBlLm9mZnNldFBhcmVudCkge1xuICAgICAgICB0aGlzLnggLT0gZS5vZmZzZXRMZWZ0XG4gICAgICAgIHRoaXMueSAtPSBlLm9mZnNldFRvcFxuICAgICAgfVxuXG4gICAgICAvLyBjYWxjdWxhdGUgY3VtdWxhdGl2ZSB6b29tIGZyb20gc3ZnIGRvY3VtZW50c1xuICAgICAgZSA9IGVsZW1lbnRcbiAgICAgIHdoaWxlIChlLnBhcmVudCAmJiAoZSA9IGUucGFyZW50KCkpKSB7XG4gICAgICAgIGlmIChlLnZpZXdib3gpIHtcbiAgICAgICAgICB6b29tICo9IGUudmlld2JveCgpLnpvb21cbiAgICAgICAgICB0aGlzLnggLT0gZS54KCkgfHwgMFxuICAgICAgICAgIHRoaXMueSAtPSBlLnkoKSB8fCAwXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcmVjYWxjdWxhdGUgdmlld2JveCBkaXN0b3J0aW9uXG4gICAgICB0aGlzLndpZHRoICA9IGJveC53aWR0aCAgLz0gem9vbVxuICAgICAgdGhpcy5oZWlnaHQgPSBib3guaGVpZ2h0IC89IHpvb21cbiAgICB9XG5cbiAgICAvLyBhZGQgY2VudGVyLCByaWdodCBhbmQgYm90dG9tXG4gICAgZnVsbEJveCh0aGlzKVxuXG4gICAgLy8gb2Zmc2V0IGJ5IHdpbmRvdyBzY3JvbGwgcG9zaXRpb24sIGJlY2F1c2UgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGNoYW5nZXMgd2hlbiB3aW5kb3cgaXMgc2Nyb2xsZWRcbiAgICB0aGlzLnggKz0gd2luZG93LnBhZ2VYT2Zmc2V0XG4gICAgdGhpcy55ICs9IHdpbmRvdy5wYWdlWU9mZnNldFxuICB9XG5cbiAgLy8gZGVmaW5lIFBhcmVudFxuLCBwYXJlbnQ6IFNWRy5FbGVtZW50XG5cbiAgLy8gQ29uc3RydWN0b3JcbiwgY29uc3RydWN0OiB7XG4gICAgLy8gR2V0IHJlY3QgYm94XG4gICAgcmJveDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IFNWRy5SQm94KHRoaXMpXG4gICAgfVxuICB9XG5cbn0pXG5cbi8vIEFkZCB1bml2ZXJzYWwgbWVyZ2UgbWV0aG9kXG47W1NWRy5CQm94LCBTVkcuVEJveCwgU1ZHLlJCb3hdLmZvckVhY2goZnVuY3Rpb24oYykge1xuXG4gIFNWRy5leHRlbmQoYywge1xuICAgIC8vIE1lcmdlIHJlY3QgYm94IHdpdGggYW5vdGhlciwgcmV0dXJuIGEgbmV3IGluc3RhbmNlXG4gICAgbWVyZ2U6IGZ1bmN0aW9uKGJveCkge1xuICAgICAgdmFyIGIgPSBuZXcgYygpXG5cbiAgICAgIC8vIG1lcmdlIGJveGVzXG4gICAgICBiLnggICAgICA9IE1hdGgubWluKHRoaXMueCwgYm94LngpXG4gICAgICBiLnkgICAgICA9IE1hdGgubWluKHRoaXMueSwgYm94LnkpXG4gICAgICBiLndpZHRoICA9IE1hdGgubWF4KHRoaXMueCArIHRoaXMud2lkdGgsICBib3gueCArIGJveC53aWR0aCkgIC0gYi54XG4gICAgICBiLmhlaWdodCA9IE1hdGgubWF4KHRoaXMueSArIHRoaXMuaGVpZ2h0LCBib3gueSArIGJveC5oZWlnaHQpIC0gYi55XG5cbiAgICAgIHJldHVybiBmdWxsQm94KGIpXG4gICAgfVxuXG4gIH0pXG5cbn0pXG5cblNWRy5NYXRyaXggPSBTVkcuaW52ZW50KHtcbiAgLy8gSW5pdGlhbGl6ZVxuICBjcmVhdGU6IGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgIHZhciBpLCBiYXNlID0gYXJyYXlUb01hdHJpeChbMSwgMCwgMCwgMSwgMCwgMF0pXG5cbiAgICAvLyBlbnN1cmUgc291cmNlIGFzIG9iamVjdFxuICAgIHNvdXJjZSA9IHNvdXJjZSBpbnN0YW5jZW9mIFNWRy5FbGVtZW50ID9cbiAgICAgIHNvdXJjZS5tYXRyaXhpZnkoKSA6XG4gICAgdHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgP1xuICAgICAgc3RyaW5nVG9NYXRyaXgoc291cmNlKSA6XG4gICAgYXJndW1lbnRzLmxlbmd0aCA9PSA2ID9cbiAgICAgIGFycmF5VG9NYXRyaXgoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKSA6XG4gICAgdHlwZW9mIHNvdXJjZSA9PT0gJ29iamVjdCcgP1xuICAgICAgc291cmNlIDogYmFzZVxuXG4gICAgLy8gbWVyZ2Ugc291cmNlXG4gICAgZm9yIChpID0gYWJjZGVmLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKVxuICAgICAgdGhpc1thYmNkZWZbaV1dID0gc291cmNlICYmIHR5cGVvZiBzb3VyY2VbYWJjZGVmW2ldXSA9PT0gJ251bWJlcicgP1xuICAgICAgICBzb3VyY2VbYWJjZGVmW2ldXSA6IGJhc2VbYWJjZGVmW2ldXVxuICB9XG5cbiAgLy8gQWRkIG1ldGhvZHNcbiwgZXh0ZW5kOiB7XG4gICAgLy8gRXh0cmFjdCBpbmRpdmlkdWFsIHRyYW5zZm9ybWF0aW9uc1xuICAgIGV4dHJhY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gZmluZCBkZWx0YSB0cmFuc2Zvcm0gcG9pbnRzXG4gICAgICB2YXIgcHggICAgPSBkZWx0YVRyYW5zZm9ybVBvaW50KHRoaXMsIDAsIDEpXG4gICAgICAgICwgcHkgICAgPSBkZWx0YVRyYW5zZm9ybVBvaW50KHRoaXMsIDEsIDApXG4gICAgICAgICwgc2tld1ggPSAxODAgLyBNYXRoLlBJICogTWF0aC5hdGFuMihweC55LCBweC54KSAtIDkwXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vIHRyYW5zbGF0aW9uXG4gICAgICAgIHg6ICAgICAgICB0aGlzLmVcbiAgICAgICwgeTogICAgICAgIHRoaXMuZlxuICAgICAgLCB0cmFuc2Zvcm1lZFg6KHRoaXMuZSAqIE1hdGguY29zKHNrZXdYICogTWF0aC5QSSAvIDE4MCkgKyB0aGlzLmYgKiBNYXRoLnNpbihza2V3WCAqIE1hdGguUEkgLyAxODApKSAvIE1hdGguc3FydCh0aGlzLmEgKiB0aGlzLmEgKyB0aGlzLmIgKiB0aGlzLmIpXG4gICAgICAsIHRyYW5zZm9ybWVkWToodGhpcy5mICogTWF0aC5jb3Moc2tld1ggKiBNYXRoLlBJIC8gMTgwKSArIHRoaXMuZSAqIE1hdGguc2luKC1za2V3WCAqIE1hdGguUEkgLyAxODApKSAvIE1hdGguc3FydCh0aGlzLmMgKiB0aGlzLmMgKyB0aGlzLmQgKiB0aGlzLmQpXG4gICAgICAgIC8vIHNrZXdcbiAgICAgICwgc2tld1g6ICAgIC1za2V3WFxuICAgICAgLCBza2V3WTogICAgMTgwIC8gTWF0aC5QSSAqIE1hdGguYXRhbjIocHkueSwgcHkueClcbiAgICAgICAgLy8gc2NhbGVcbiAgICAgICwgc2NhbGVYOiAgIE1hdGguc3FydCh0aGlzLmEgKiB0aGlzLmEgKyB0aGlzLmIgKiB0aGlzLmIpXG4gICAgICAsIHNjYWxlWTogICBNYXRoLnNxcnQodGhpcy5jICogdGhpcy5jICsgdGhpcy5kICogdGhpcy5kKVxuICAgICAgICAvLyByb3RhdGlvblxuICAgICAgLCByb3RhdGlvbjogc2tld1hcbiAgICAgICwgYTogdGhpcy5hXG4gICAgICAsIGI6IHRoaXMuYlxuICAgICAgLCBjOiB0aGlzLmNcbiAgICAgICwgZDogdGhpcy5kXG4gICAgICAsIGU6IHRoaXMuZVxuICAgICAgLCBmOiB0aGlzLmZcbiAgICAgICwgbWF0cml4OiBuZXcgU1ZHLk1hdHJpeCh0aGlzKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBDbG9uZSBtYXRyaXhcbiAgLCBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IFNWRy5NYXRyaXgodGhpcylcbiAgICB9XG4gICAgLy8gTW9ycGggb25lIG1hdHJpeCBpbnRvIGFub3RoZXJcbiAgLCBtb3JwaDogZnVuY3Rpb24obWF0cml4KSB7XG4gICAgICAvLyBzdG9yZSBuZXcgZGVzdGluYXRpb25cbiAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBuZXcgU1ZHLk1hdHJpeChtYXRyaXgpXG5cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIC8vIEdldCBtb3JwaGVkIG1hdHJpeCBhdCBhIGdpdmVuIHBvc2l0aW9uXG4gICwgYXQ6IGZ1bmN0aW9uKHBvcykge1xuICAgICAgLy8gbWFrZSBzdXJlIGEgZGVzdGluYXRpb24gaXMgZGVmaW5lZFxuICAgICAgaWYgKCF0aGlzLmRlc3RpbmF0aW9uKSByZXR1cm4gdGhpc1xuXG4gICAgICAvLyBjYWxjdWxhdGUgbW9ycGhlZCBtYXRyaXggYXQgYSBnaXZlbiBwb3NpdGlvblxuICAgICAgdmFyIG1hdHJpeCA9IG5ldyBTVkcuTWF0cml4KHtcbiAgICAgICAgYTogdGhpcy5hICsgKHRoaXMuZGVzdGluYXRpb24uYSAtIHRoaXMuYSkgKiBwb3NcbiAgICAgICwgYjogdGhpcy5iICsgKHRoaXMuZGVzdGluYXRpb24uYiAtIHRoaXMuYikgKiBwb3NcbiAgICAgICwgYzogdGhpcy5jICsgKHRoaXMuZGVzdGluYXRpb24uYyAtIHRoaXMuYykgKiBwb3NcbiAgICAgICwgZDogdGhpcy5kICsgKHRoaXMuZGVzdGluYXRpb24uZCAtIHRoaXMuZCkgKiBwb3NcbiAgICAgICwgZTogdGhpcy5lICsgKHRoaXMuZGVzdGluYXRpb24uZSAtIHRoaXMuZSkgKiBwb3NcbiAgICAgICwgZjogdGhpcy5mICsgKHRoaXMuZGVzdGluYXRpb24uZiAtIHRoaXMuZikgKiBwb3NcbiAgICAgIH0pXG5cbiAgICAgIC8vIHByb2Nlc3MgcGFyYW1ldHJpYyByb3RhdGlvbiBpZiBwcmVzZW50XG4gICAgICBpZiAodGhpcy5wYXJhbSAmJiB0aGlzLnBhcmFtLnRvKSB7XG4gICAgICAgIC8vIGNhbGN1bGF0ZSBjdXJyZW50IHBhcmFtZXRyaWMgcG9zaXRpb25cbiAgICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICAgIHJvdGF0aW9uOiB0aGlzLnBhcmFtLmZyb20ucm90YXRpb24gKyAodGhpcy5wYXJhbS50by5yb3RhdGlvbiAtIHRoaXMucGFyYW0uZnJvbS5yb3RhdGlvbikgKiBwb3NcbiAgICAgICAgLCBjeDogICAgICAgdGhpcy5wYXJhbS5mcm9tLmN4XG4gICAgICAgICwgY3k6ICAgICAgIHRoaXMucGFyYW0uZnJvbS5jeVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcm90YXRlIG1hdHJpeFxuICAgICAgICBtYXRyaXggPSBtYXRyaXgucm90YXRlKFxuICAgICAgICAgICh0aGlzLnBhcmFtLnRvLnJvdGF0aW9uIC0gdGhpcy5wYXJhbS5mcm9tLnJvdGF0aW9uICogMikgKiBwb3NcbiAgICAgICAgLCBwYXJhbS5jeFxuICAgICAgICAsIHBhcmFtLmN5XG4gICAgICAgIClcblxuICAgICAgICAvLyBzdG9yZSBjdXJyZW50IHBhcmFtZXRyaWMgdmFsdWVzXG4gICAgICAgIG1hdHJpeC5wYXJhbSA9IHBhcmFtXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXRyaXhcbiAgICB9XG4gICAgLy8gTXVsdGlwbGllcyBieSBnaXZlbiBtYXRyaXhcbiAgLCBtdWx0aXBseTogZnVuY3Rpb24obWF0cml4KSB7XG4gICAgICByZXR1cm4gbmV3IFNWRy5NYXRyaXgodGhpcy5uYXRpdmUoKS5tdWx0aXBseShwYXJzZU1hdHJpeChtYXRyaXgpLm5hdGl2ZSgpKSlcbiAgICB9XG4gICAgLy8gSW52ZXJzZXMgbWF0cml4XG4gICwgaW52ZXJzZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IFNWRy5NYXRyaXgodGhpcy5uYXRpdmUoKS5pbnZlcnNlKCkpXG4gICAgfVxuICAgIC8vIFRyYW5zbGF0ZSBtYXRyaXhcbiAgLCB0cmFuc2xhdGU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHJldHVybiBuZXcgU1ZHLk1hdHJpeCh0aGlzLm5hdGl2ZSgpLnRyYW5zbGF0ZSh4IHx8IDAsIHkgfHwgMCkpXG4gICAgfVxuICAgIC8vIFNjYWxlIG1hdHJpeFxuICAsIHNjYWxlOiBmdW5jdGlvbih4LCB5LCBjeCwgY3kpIHtcbiAgICAgIC8vIHN1cHBvcnQgdW5pZm9ybWFsIHNjYWxlXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHkgPSB4XG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMykge1xuICAgICAgICBjeSA9IGN4XG4gICAgICAgIGN4ID0geVxuICAgICAgICB5ID0geFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5hcm91bmQoY3gsIGN5LCBuZXcgU1ZHLk1hdHJpeCh4LCAwLCAwLCB5LCAwLCAwKSlcbiAgICB9XG4gICAgLy8gUm90YXRlIG1hdHJpeFxuICAsIHJvdGF0ZTogZnVuY3Rpb24ociwgY3gsIGN5KSB7XG4gICAgICAvLyBjb252ZXJ0IGRlZ3JlZXMgdG8gcmFkaWFuc1xuICAgICAgciA9IFNWRy51dGlscy5yYWRpYW5zKHIpXG5cbiAgICAgIHJldHVybiB0aGlzLmFyb3VuZChjeCwgY3ksIG5ldyBTVkcuTWF0cml4KE1hdGguY29zKHIpLCBNYXRoLnNpbihyKSwgLU1hdGguc2luKHIpLCBNYXRoLmNvcyhyKSwgMCwgMCkpXG4gICAgfVxuICAgIC8vIEZsaXAgbWF0cml4IG9uIHggb3IgeSwgYXQgYSBnaXZlbiBvZmZzZXRcbiAgLCBmbGlwOiBmdW5jdGlvbihhLCBvKSB7XG4gICAgICByZXR1cm4gYSA9PSAneCcgPyB0aGlzLnNjYWxlKC0xLCAxLCBvLCAwKSA6IHRoaXMuc2NhbGUoMSwgLTEsIDAsIG8pXG4gICAgfVxuICAgIC8vIFNrZXdcbiAgLCBza2V3OiBmdW5jdGlvbih4LCB5LCBjeCwgY3kpIHtcbiAgICAgIC8vIHN1cHBvcnQgdW5pZm9ybWFsIHNrZXdcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgeSA9IHhcbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAzKSB7XG4gICAgICAgIGN5ID0gY3hcbiAgICAgICAgY3ggPSB5XG4gICAgICAgIHkgPSB4XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbnZlcnQgZGVncmVlcyB0byByYWRpYW5zXG4gICAgICB4ID0gU1ZHLnV0aWxzLnJhZGlhbnMoeClcbiAgICAgIHkgPSBTVkcudXRpbHMucmFkaWFucyh5KVxuXG4gICAgICByZXR1cm4gdGhpcy5hcm91bmQoY3gsIGN5LCBuZXcgU1ZHLk1hdHJpeCgxLCBNYXRoLnRhbih5KSwgTWF0aC50YW4oeCksIDEsIDAsIDApKVxuICAgIH1cbiAgICAvLyBTa2V3WFxuICAsIHNrZXdYOiBmdW5jdGlvbih4LCBjeCwgY3kpIHtcbiAgICAgIHJldHVybiB0aGlzLnNrZXcoeCwgMCwgY3gsIGN5KVxuICAgIH1cbiAgICAvLyBTa2V3WVxuICAsIHNrZXdZOiBmdW5jdGlvbih5LCBjeCwgY3kpIHtcbiAgICAgIHJldHVybiB0aGlzLnNrZXcoMCwgeSwgY3gsIGN5KVxuICAgIH1cbiAgICAvLyBUcmFuc2Zvcm0gYXJvdW5kIGEgY2VudGVyIHBvaW50XG4gICwgYXJvdW5kOiBmdW5jdGlvbihjeCwgY3ksIG1hdHJpeCkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgLm11bHRpcGx5KG5ldyBTVkcuTWF0cml4KDEsIDAsIDAsIDEsIGN4IHx8IDAsIGN5IHx8IDApKVxuICAgICAgICAubXVsdGlwbHkobWF0cml4KVxuICAgICAgICAubXVsdGlwbHkobmV3IFNWRy5NYXRyaXgoMSwgMCwgMCwgMSwgLWN4IHx8IDAsIC1jeSB8fCAwKSlcbiAgICB9XG4gICAgLy8gQ29udmVydCB0byBuYXRpdmUgU1ZHTWF0cml4XG4gICwgbmF0aXZlOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGNyZWF0ZSBuZXcgbWF0cml4XG4gICAgICB2YXIgbWF0cml4ID0gU1ZHLnBhcnNlci5uYXRpdmUuY3JlYXRlU1ZHTWF0cml4KClcblxuICAgICAgLy8gdXBkYXRlIHdpdGggY3VycmVudCB2YWx1ZXNcbiAgICAgIGZvciAodmFyIGkgPSBhYmNkZWYubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIG1hdHJpeFthYmNkZWZbaV1dID0gdGhpc1thYmNkZWZbaV1dXG5cbiAgICAgIHJldHVybiBtYXRyaXhcbiAgICB9XG4gICAgLy8gQ29udmVydCBtYXRyaXggdG8gc3RyaW5nXG4gICwgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICdtYXRyaXgoJyArIHRoaXMuYSArICcsJyArIHRoaXMuYiArICcsJyArIHRoaXMuYyArICcsJyArIHRoaXMuZCArICcsJyArIHRoaXMuZSArICcsJyArIHRoaXMuZiArICcpJ1xuICAgIH1cbiAgfVxuXG4gIC8vIERlZmluZSBwYXJlbnRcbiwgcGFyZW50OiBTVkcuRWxlbWVudFxuXG4gIC8vIEFkZCBwYXJlbnQgbWV0aG9kXG4sIGNvbnN0cnVjdDoge1xuICAgIC8vIEdldCBjdXJyZW50IG1hdHJpeFxuICAgIGN0bTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IFNWRy5NYXRyaXgodGhpcy5ub2RlLmdldENUTSgpKVxuICAgIH0sXG4gICAgLy8gR2V0IGN1cnJlbnQgc2NyZWVuIG1hdHJpeFxuICAgIHNjcmVlbkNUTTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IFNWRy5NYXRyaXgodGhpcy5ub2RlLmdldFNjcmVlbkNUTSgpKVxuICAgIH1cblxuICB9XG5cbn0pXG5cblNWRy5Qb2ludCA9IFNWRy5pbnZlbnQoe1xuICAvLyBJbml0aWFsaXplXG4gIGNyZWF0ZTogZnVuY3Rpb24oeCx5KSB7XG4gICAgdmFyIGksIHNvdXJjZSwgYmFzZSA9IHt4OjAsIHk6MH1cblxuICAgIC8vIGVuc3VyZSBzb3VyY2UgYXMgb2JqZWN0XG4gICAgc291cmNlID0gQXJyYXkuaXNBcnJheSh4KSA/XG4gICAgICB7eDp4WzBdLCB5OnhbMV19IDpcbiAgICB0eXBlb2YgeCA9PT0gJ29iamVjdCcgP1xuICAgICAge3g6eC54LCB5OngueX0gOlxuICAgIHggIT0gbnVsbCA/XG4gICAgICB7eDp4LCB5Oih5ICE9IG51bGwgPyB5IDogeCl9IDogYmFzZSAvLyBJZiB5IGhhcyBubyB2YWx1ZSwgdGhlbiB4IGlzIHVzZWQgaGFzIGl0cyB2YWx1ZVxuXG4gICAgLy8gbWVyZ2Ugc291cmNlXG4gICAgdGhpcy54ID0gc291cmNlLnhcbiAgICB0aGlzLnkgPSBzb3VyY2UueVxuICB9XG5cbiAgLy8gQWRkIG1ldGhvZHNcbiwgZXh0ZW5kOiB7XG4gICAgLy8gQ2xvbmUgcG9pbnRcbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IFNWRy5Qb2ludCh0aGlzKVxuICAgIH1cbiAgICAvLyBNb3JwaCBvbmUgcG9pbnQgaW50byBhbm90aGVyXG4gICwgbW9ycGg6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIC8vIHN0b3JlIG5ldyBkZXN0aW5hdGlvblxuICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTVkcuUG9pbnQoeCwgeSlcblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgLy8gR2V0IG1vcnBoZWQgcG9pbnQgYXQgYSBnaXZlbiBwb3NpdGlvblxuICAsIGF0OiBmdW5jdGlvbihwb3MpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSBhIGRlc3RpbmF0aW9uIGlzIGRlZmluZWRcbiAgICAgIGlmICghdGhpcy5kZXN0aW5hdGlvbikgcmV0dXJuIHRoaXNcblxuICAgICAgLy8gY2FsY3VsYXRlIG1vcnBoZWQgbWF0cml4IGF0IGEgZ2l2ZW4gcG9zaXRpb25cbiAgICAgIHZhciBwb2ludCA9IG5ldyBTVkcuUG9pbnQoe1xuICAgICAgICB4OiB0aGlzLnggKyAodGhpcy5kZXN0aW5hdGlvbi54IC0gdGhpcy54KSAqIHBvc1xuICAgICAgLCB5OiB0aGlzLnkgKyAodGhpcy5kZXN0aW5hdGlvbi55IC0gdGhpcy55KSAqIHBvc1xuICAgICAgfSlcblxuICAgICAgcmV0dXJuIHBvaW50XG4gICAgfVxuICAgIC8vIENvbnZlcnQgdG8gbmF0aXZlIFNWR1BvaW50XG4gICwgbmF0aXZlOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGNyZWF0ZSBuZXcgcG9pbnRcbiAgICAgIHZhciBwb2ludCA9IFNWRy5wYXJzZXIubmF0aXZlLmNyZWF0ZVNWR1BvaW50KClcblxuICAgICAgLy8gdXBkYXRlIHdpdGggY3VycmVudCB2YWx1ZXNcbiAgICAgIHBvaW50LnggPSB0aGlzLnhcbiAgICAgIHBvaW50LnkgPSB0aGlzLnlcblxuICAgICAgcmV0dXJuIHBvaW50XG4gICAgfVxuICAgIC8vIHRyYW5zZm9ybSBwb2ludCB3aXRoIG1hdHJpeFxuICAsIHRyYW5zZm9ybTogZnVuY3Rpb24obWF0cml4KSB7XG4gICAgICByZXR1cm4gbmV3IFNWRy5Qb2ludCh0aGlzLm5hdGl2ZSgpLm1hdHJpeFRyYW5zZm9ybShtYXRyaXgubmF0aXZlKCkpKVxuICAgIH1cblxuICB9XG5cbn0pXG5cblNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcblxuICAvLyBHZXQgcG9pbnRcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gbmV3IFNWRy5Qb2ludCh4LHkpLnRyYW5zZm9ybSh0aGlzLnNjcmVlbkNUTSgpLmludmVyc2UoKSk7XG4gIH1cblxufSlcblxuU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwge1xuICAvLyBTZXQgc3ZnIGVsZW1lbnQgYXR0cmlidXRlXG4gIGF0dHI6IGZ1bmN0aW9uKGEsIHYsIG4pIHtcbiAgICAvLyBhY3QgYXMgZnVsbCBnZXR0ZXJcbiAgICBpZiAoYSA9PSBudWxsKSB7XG4gICAgICAvLyBnZXQgYW4gb2JqZWN0IG9mIGF0dHJpYnV0ZXNcbiAgICAgIGEgPSB7fVxuICAgICAgdiA9IHRoaXMubm9kZS5hdHRyaWJ1dGVzXG4gICAgICBmb3IgKG4gPSB2Lmxlbmd0aCAtIDE7IG4gPj0gMDsgbi0tKVxuICAgICAgICBhW3Zbbl0ubm9kZU5hbWVdID0gU1ZHLnJlZ2V4LmlzTnVtYmVyLnRlc3QodltuXS5ub2RlVmFsdWUpID8gcGFyc2VGbG9hdCh2W25dLm5vZGVWYWx1ZSkgOiB2W25dLm5vZGVWYWx1ZVxuXG4gICAgICByZXR1cm4gYVxuXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYSA9PSAnb2JqZWN0Jykge1xuICAgICAgLy8gYXBwbHkgZXZlcnkgYXR0cmlidXRlIGluZGl2aWR1YWxseSBpZiBhbiBvYmplY3QgaXMgcGFzc2VkXG4gICAgICBmb3IgKHYgaW4gYSkgdGhpcy5hdHRyKHYsIGFbdl0pXG5cbiAgICB9IGVsc2UgaWYgKHYgPT09IG51bGwpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHZhbHVlXG4gICAgICAgIHRoaXMubm9kZS5yZW1vdmVBdHRyaWJ1dGUoYSlcblxuICAgIH0gZWxzZSBpZiAodiA9PSBudWxsKSB7XG4gICAgICAvLyBhY3QgYXMgYSBnZXR0ZXIgaWYgdGhlIGZpcnN0IGFuZCBvbmx5IGFyZ3VtZW50IGlzIG5vdCBhbiBvYmplY3RcbiAgICAgIHYgPSB0aGlzLm5vZGUuZ2V0QXR0cmlidXRlKGEpXG4gICAgICByZXR1cm4gdiA9PSBudWxsID9cbiAgICAgICAgU1ZHLmRlZmF1bHRzLmF0dHJzW2FdIDpcbiAgICAgIFNWRy5yZWdleC5pc051bWJlci50ZXN0KHYpID9cbiAgICAgICAgcGFyc2VGbG9hdCh2KSA6IHZcblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCVUcgRklYOiBzb21lIGJyb3dzZXJzIHdpbGwgcmVuZGVyIGEgc3Ryb2tlIGlmIGEgY29sb3IgaXMgZ2l2ZW4gZXZlbiB0aG91Z2ggc3Ryb2tlIHdpZHRoIGlzIDBcbiAgICAgIGlmIChhID09ICdzdHJva2Utd2lkdGgnKVxuICAgICAgICB0aGlzLmF0dHIoJ3N0cm9rZScsIHBhcnNlRmxvYXQodikgPiAwID8gdGhpcy5fc3Ryb2tlIDogbnVsbClcbiAgICAgIGVsc2UgaWYgKGEgPT0gJ3N0cm9rZScpXG4gICAgICAgIHRoaXMuX3N0cm9rZSA9IHZcblxuICAgICAgLy8gY29udmVydCBpbWFnZSBmaWxsIGFuZCBzdHJva2UgdG8gcGF0dGVybnNcbiAgICAgIGlmIChhID09ICdmaWxsJyB8fCBhID09ICdzdHJva2UnKSB7XG4gICAgICAgIGlmIChTVkcucmVnZXguaXNJbWFnZS50ZXN0KHYpKVxuICAgICAgICAgIHYgPSB0aGlzLmRvYygpLmRlZnMoKS5pbWFnZSh2LCAwLCAwKVxuXG4gICAgICAgIGlmICh2IGluc3RhbmNlb2YgU1ZHLkltYWdlKVxuICAgICAgICAgIHYgPSB0aGlzLmRvYygpLmRlZnMoKS5wYXR0ZXJuKDAsIDAsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5hZGQodilcbiAgICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICAvLyBlbnN1cmUgY29ycmVjdCBudW1lcmljIHZhbHVlcyAoYWxzbyBhY2NlcHRzIE5hTiBhbmQgSW5maW5pdHkpXG4gICAgICBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInKVxuICAgICAgICB2ID0gbmV3IFNWRy5OdW1iZXIodilcblxuICAgICAgLy8gZW5zdXJlIGZ1bGwgaGV4IGNvbG9yXG4gICAgICBlbHNlIGlmIChTVkcuQ29sb3IuaXNDb2xvcih2KSlcbiAgICAgICAgdiA9IG5ldyBTVkcuQ29sb3IodilcblxuICAgICAgLy8gcGFyc2UgYXJyYXkgdmFsdWVzXG4gICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHYpKVxuICAgICAgICB2ID0gbmV3IFNWRy5BcnJheSh2KVxuXG4gICAgICAvLyBzdG9yZSBwYXJhbWV0cmljIHRyYW5zZm9ybWF0aW9uIHZhbHVlcyBsb2NhbGx5XG4gICAgICBlbHNlIGlmICh2IGluc3RhbmNlb2YgU1ZHLk1hdHJpeCAmJiB2LnBhcmFtKVxuICAgICAgICB0aGlzLnBhcmFtID0gdi5wYXJhbVxuXG4gICAgICAvLyBpZiB0aGUgcGFzc2VkIGF0dHJpYnV0ZSBpcyBsZWFkaW5nLi4uXG4gICAgICBpZiAoYSA9PSAnbGVhZGluZycpIHtcbiAgICAgICAgLy8gLi4uIGNhbGwgdGhlIGxlYWRpbmcgbWV0aG9kIGluc3RlYWRcbiAgICAgICAgaWYgKHRoaXMubGVhZGluZylcbiAgICAgICAgICB0aGlzLmxlYWRpbmcodilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHNldCBnaXZlbiBhdHRyaWJ1dGUgb24gbm9kZVxuICAgICAgICB0eXBlb2YgbiA9PT0gJ3N0cmluZycgP1xuICAgICAgICAgIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGVOUyhuLCBhLCB2LnRvU3RyaW5nKCkpIDpcbiAgICAgICAgICB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKGEsIHYudG9TdHJpbmcoKSlcbiAgICAgIH1cblxuICAgICAgLy8gcmVidWlsZCBpZiByZXF1aXJlZFxuICAgICAgaWYgKHRoaXMucmVidWlsZCAmJiAoYSA9PSAnZm9udC1zaXplJyB8fCBhID09ICd4JykpXG4gICAgICAgIHRoaXMucmVidWlsZChhLCB2KVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cbn0pXG5TVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XG4gIC8vIEFkZCB0cmFuc2Zvcm1hdGlvbnNcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbihvLCByZWxhdGl2ZSkge1xuICAgIC8vIGdldCB0YXJnZXQgaW4gY2FzZSBvZiB0aGUgZnggbW9kdWxlLCBvdGhlcndpc2UgcmVmZXJlbmNlIHRoaXNcbiAgICB2YXIgdGFyZ2V0ID0gdGhpc1xuICAgICAgLCBtYXRyaXhcblxuICAgIC8vIGFjdCBhcyBhIGdldHRlclxuICAgIGlmICh0eXBlb2YgbyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIGdldCBjdXJyZW50IG1hdHJpeFxuICAgICAgbWF0cml4ID0gbmV3IFNWRy5NYXRyaXgodGFyZ2V0KS5leHRyYWN0KClcblxuICAgICAgcmV0dXJuIHR5cGVvZiBvID09PSAnc3RyaW5nJyA/IG1hdHJpeFtvXSA6IG1hdHJpeFxuICAgIH1cblxuICAgIC8vIGdldCBjdXJyZW50IG1hdHJpeFxuICAgIG1hdHJpeCA9IG5ldyBTVkcuTWF0cml4KHRhcmdldClcblxuICAgIC8vIGVuc3VyZSByZWxhdGl2ZSBmbGFnXG4gICAgcmVsYXRpdmUgPSAhIXJlbGF0aXZlIHx8ICEhby5yZWxhdGl2ZVxuXG4gICAgLy8gYWN0IG9uIG1hdHJpeFxuICAgIGlmIChvLmEgIT0gbnVsbCkge1xuICAgICAgbWF0cml4ID0gcmVsYXRpdmUgP1xuICAgICAgICAvLyByZWxhdGl2ZVxuICAgICAgICBtYXRyaXgubXVsdGlwbHkobmV3IFNWRy5NYXRyaXgobykpIDpcbiAgICAgICAgLy8gYWJzb2x1dGVcbiAgICAgICAgbmV3IFNWRy5NYXRyaXgobylcblxuICAgIC8vIGFjdCBvbiByb3RhdGlvblxuICAgIH0gZWxzZSBpZiAoby5yb3RhdGlvbiAhPSBudWxsKSB7XG4gICAgICAvLyBlbnN1cmUgY2VudHJlIHBvaW50XG4gICAgICBlbnN1cmVDZW50cmUobywgdGFyZ2V0KVxuXG4gICAgICAvLyBhcHBseSB0cmFuc2Zvcm1hdGlvblxuICAgICAgbWF0cml4ID0gcmVsYXRpdmUgP1xuICAgICAgICAvLyByZWxhdGl2ZVxuICAgICAgICBtYXRyaXgucm90YXRlKG8ucm90YXRpb24sIG8uY3gsIG8uY3kpIDpcbiAgICAgICAgLy8gYWJzb2x1dGVcbiAgICAgICAgbWF0cml4LnJvdGF0ZShvLnJvdGF0aW9uIC0gbWF0cml4LmV4dHJhY3QoKS5yb3RhdGlvbiwgby5jeCwgby5jeSlcblxuICAgIC8vIGFjdCBvbiBzY2FsZVxuICAgIH0gZWxzZSBpZiAoby5zY2FsZSAhPSBudWxsIHx8IG8uc2NhbGVYICE9IG51bGwgfHwgby5zY2FsZVkgIT0gbnVsbCkge1xuICAgICAgLy8gZW5zdXJlIGNlbnRyZSBwb2ludFxuICAgICAgZW5zdXJlQ2VudHJlKG8sIHRhcmdldClcblxuICAgICAgLy8gZW5zdXJlIHNjYWxlIHZhbHVlcyBvbiBib3RoIGF4ZXNcbiAgICAgIG8uc2NhbGVYID0gby5zY2FsZSAhPSBudWxsID8gby5zY2FsZSA6IG8uc2NhbGVYICE9IG51bGwgPyBvLnNjYWxlWCA6IDFcbiAgICAgIG8uc2NhbGVZID0gby5zY2FsZSAhPSBudWxsID8gby5zY2FsZSA6IG8uc2NhbGVZICE9IG51bGwgPyBvLnNjYWxlWSA6IDFcblxuICAgICAgaWYgKCFyZWxhdGl2ZSkge1xuICAgICAgICAvLyBhYnNvbHV0ZTsgbXVsdGlwbHkgaW52ZXJzZWQgdmFsdWVzXG4gICAgICAgIHZhciBlID0gbWF0cml4LmV4dHJhY3QoKVxuICAgICAgICBvLnNjYWxlWCA9IG8uc2NhbGVYICogMSAvIGUuc2NhbGVYXG4gICAgICAgIG8uc2NhbGVZID0gby5zY2FsZVkgKiAxIC8gZS5zY2FsZVlcbiAgICAgIH1cblxuICAgICAgbWF0cml4ID0gbWF0cml4LnNjYWxlKG8uc2NhbGVYLCBvLnNjYWxlWSwgby5jeCwgby5jeSlcblxuICAgIC8vIGFjdCBvbiBza2V3XG4gICAgfSBlbHNlIGlmIChvLnNrZXcgIT0gbnVsbCB8fCBvLnNrZXdYICE9IG51bGwgfHwgby5za2V3WSAhPSBudWxsKSB7XG4gICAgICAvLyBlbnN1cmUgY2VudHJlIHBvaW50XG4gICAgICBlbnN1cmVDZW50cmUobywgdGFyZ2V0KVxuXG4gICAgICAvLyBlbnN1cmUgc2tldyB2YWx1ZXMgb24gYm90aCBheGVzXG4gICAgICBvLnNrZXdYID0gby5za2V3ICE9IG51bGwgPyBvLnNrZXcgOiBvLnNrZXdYICE9IG51bGwgPyBvLnNrZXdYIDogMFxuICAgICAgby5za2V3WSA9IG8uc2tldyAhPSBudWxsID8gby5za2V3IDogby5za2V3WSAhPSBudWxsID8gby5za2V3WSA6IDBcblxuICAgICAgaWYgKCFyZWxhdGl2ZSkge1xuICAgICAgICAvLyBhYnNvbHV0ZTsgcmVzZXQgc2tldyB2YWx1ZXNcbiAgICAgICAgdmFyIGUgPSBtYXRyaXguZXh0cmFjdCgpXG4gICAgICAgIG1hdHJpeCA9IG1hdHJpeC5tdWx0aXBseShuZXcgU1ZHLk1hdHJpeCgpLnNrZXcoZS5za2V3WCwgZS5za2V3WSwgby5jeCwgby5jeSkuaW52ZXJzZSgpKVxuICAgICAgfVxuXG4gICAgICBtYXRyaXggPSBtYXRyaXguc2tldyhvLnNrZXdYLCBvLnNrZXdZLCBvLmN4LCBvLmN5KVxuXG4gICAgLy8gYWN0IG9uIGZsaXBcbiAgICB9IGVsc2UgaWYgKG8uZmxpcCkge1xuICAgICAgbWF0cml4ID0gbWF0cml4LmZsaXAoXG4gICAgICAgIG8uZmxpcFxuICAgICAgLCBvLm9mZnNldCA9PSBudWxsID8gdGFyZ2V0LmJib3goKVsnYycgKyBvLmZsaXBdIDogby5vZmZzZXRcbiAgICAgIClcblxuICAgIC8vIGFjdCBvbiB0cmFuc2xhdGVcbiAgICB9IGVsc2UgaWYgKG8ueCAhPSBudWxsIHx8IG8ueSAhPSBudWxsKSB7XG4gICAgICBpZiAocmVsYXRpdmUpIHtcbiAgICAgICAgLy8gcmVsYXRpdmVcbiAgICAgICAgbWF0cml4ID0gbWF0cml4LnRyYW5zbGF0ZShvLngsIG8ueSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFic29sdXRlXG4gICAgICAgIGlmIChvLnggIT0gbnVsbCkgbWF0cml4LmUgPSBvLnhcbiAgICAgICAgaWYgKG8ueSAhPSBudWxsKSBtYXRyaXguZiA9IG8ueVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmF0dHIoJ3RyYW5zZm9ybScsIG1hdHJpeClcbiAgfVxufSlcblxuU1ZHLmV4dGVuZChTVkcuRlgsIHtcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbihvLCByZWxhdGl2ZSkge1xuICAgIC8vIGdldCB0YXJnZXQgaW4gY2FzZSBvZiB0aGUgZnggbW9kdWxlLCBvdGhlcndpc2UgcmVmZXJlbmNlIHRoaXNcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQoKVxuICAgICAgLCBtYXRyaXhcblxuICAgIC8vIGFjdCBhcyBhIGdldHRlclxuICAgIGlmICh0eXBlb2YgbyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIGdldCBjdXJyZW50IG1hdHJpeFxuICAgICAgbWF0cml4ID0gbmV3IFNWRy5NYXRyaXgodGFyZ2V0KS5leHRyYWN0KClcblxuICAgICAgcmV0dXJuIHR5cGVvZiBvID09PSAnc3RyaW5nJyA/IG1hdHJpeFtvXSA6IG1hdHJpeFxuICAgIH1cblxuICAgIC8vIGVuc3VyZSByZWxhdGl2ZSBmbGFnXG4gICAgcmVsYXRpdmUgPSAhIXJlbGF0aXZlIHx8ICEhby5yZWxhdGl2ZVxuXG4gICAgLy8gYWN0IG9uIG1hdHJpeFxuICAgIGlmIChvLmEgIT0gbnVsbCkge1xuICAgICAgbWF0cml4ID0gbmV3IFNWRy5NYXRyaXgobylcblxuICAgIC8vIGFjdCBvbiByb3RhdGlvblxuICAgIH0gZWxzZSBpZiAoby5yb3RhdGlvbiAhPSBudWxsKSB7XG4gICAgICAvLyBlbnN1cmUgY2VudHJlIHBvaW50XG4gICAgICBlbnN1cmVDZW50cmUobywgdGFyZ2V0KVxuXG4gICAgICAvLyBhcHBseSB0cmFuc2Zvcm1hdGlvblxuICAgICAgbWF0cml4ID0gbmV3IFNWRy5Sb3RhdGUoby5yb3RhdGlvbiwgby5jeCwgby5jeSlcblxuICAgIC8vIGFjdCBvbiBzY2FsZVxuICAgIH0gZWxzZSBpZiAoby5zY2FsZSAhPSBudWxsIHx8IG8uc2NhbGVYICE9IG51bGwgfHwgby5zY2FsZVkgIT0gbnVsbCkge1xuICAgICAgLy8gZW5zdXJlIGNlbnRyZSBwb2ludFxuICAgICAgZW5zdXJlQ2VudHJlKG8sIHRhcmdldClcblxuICAgICAgLy8gZW5zdXJlIHNjYWxlIHZhbHVlcyBvbiBib3RoIGF4ZXNcbiAgICAgIG8uc2NhbGVYID0gby5zY2FsZSAhPSBudWxsID8gby5zY2FsZSA6IG8uc2NhbGVYICE9IG51bGwgPyBvLnNjYWxlWCA6IDFcbiAgICAgIG8uc2NhbGVZID0gby5zY2FsZSAhPSBudWxsID8gby5zY2FsZSA6IG8uc2NhbGVZICE9IG51bGwgPyBvLnNjYWxlWSA6IDFcblxuICAgICAgbWF0cml4ID0gbmV3IFNWRy5TY2FsZShvLnNjYWxlWCwgby5zY2FsZVksIG8uY3gsIG8uY3kpXG5cbiAgICAvLyBhY3Qgb24gc2tld1xuICAgIH0gZWxzZSBpZiAoby5za2V3WCAhPSBudWxsIHx8IG8uc2tld1kgIT0gbnVsbCkge1xuICAgICAgLy8gZW5zdXJlIGNlbnRyZSBwb2ludFxuICAgICAgZW5zdXJlQ2VudHJlKG8sIHRhcmdldClcblxuICAgICAgLy8gZW5zdXJlIHNrZXcgdmFsdWVzIG9uIGJvdGggYXhlc1xuICAgICAgby5za2V3WCA9IG8uc2tld1ggIT0gbnVsbCA/IG8uc2tld1ggOiAwXG4gICAgICBvLnNrZXdZID0gby5za2V3WSAhPSBudWxsID8gby5za2V3WSA6IDBcblxuICAgICAgbWF0cml4ID0gbmV3IFNWRy5Ta2V3KG8uc2tld1gsIG8uc2tld1ksIG8uY3gsIG8uY3kpXG5cbiAgICAvLyBhY3Qgb24gZmxpcFxuICAgIH0gZWxzZSBpZiAoby5mbGlwKSB7XG4gICAgICBtYXRyaXggPSBuZXcgU1ZHLk1hdHJpeCgpLm1vcnBoKG5ldyBTVkcuTWF0cml4KCkuZmxpcChcbiAgICAgICAgby5mbGlwXG4gICAgICAsIG8ub2Zmc2V0ID09IG51bGwgPyB0YXJnZXQuYmJveCgpWydjJyArIG8uZmxpcF0gOiBvLm9mZnNldFxuICAgICAgKSlcblxuICAgIC8vIGFjdCBvbiB0cmFuc2xhdGVcbiAgICB9IGVsc2UgaWYgKG8ueCAhPSBudWxsIHx8IG8ueSAhPSBudWxsKSB7XG4gICAgICBtYXRyaXggPSBuZXcgU1ZHLlRyYW5zbGF0ZShvLngsIG8ueSlcbiAgICB9XG5cbiAgICBpZighbWF0cml4KSByZXR1cm4gdGhpc1xuXG4gICAgbWF0cml4LnJlbGF0aXZlID0gcmVsYXRpdmVcblxuICAgIHRoaXMubGFzdCgpLnRyYW5zZm9ybXMucHVzaChtYXRyaXgpXG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhpcy5zdGFydCgpfS5iaW5kKHRoaXMpLCAwKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufSlcblxuU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwge1xuICAvLyBSZXNldCBhbGwgdHJhbnNmb3JtYXRpb25zXG4gIHVudHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCd0cmFuc2Zvcm0nLCBudWxsKVxuICB9LFxuICAvLyBtZXJnZSB0aGUgd2hvbGUgdHJhbnNmb3JtYXRpb24gY2hhaW4gaW50byBvbmUgbWF0cml4IGFuZCByZXR1cm5zIGl0XG4gIG1hdHJpeGlmeTogZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgbWF0cml4ID0gKHRoaXMuYXR0cigndHJhbnNmb3JtJykgfHwgJycpXG4gICAgICAvLyBzcGxpdCB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgIC5zcGxpdCgvXFwpXFxzKiw/XFxzKi8pLnNsaWNlKDAsLTEpLm1hcChmdW5jdGlvbihzdHIpe1xuICAgICAgICAvLyBnZW5lcmF0ZSBrZXkgPT4gdmFsdWUgcGFpcnNcbiAgICAgICAgdmFyIGt2ID0gc3RyLnRyaW0oKS5zcGxpdCgnKCcpXG4gICAgICAgIHJldHVybiBba3ZbMF0sIGt2WzFdLnNwbGl0KFNWRy5yZWdleC5tYXRyaXhFbGVtZW50cykubWFwKGZ1bmN0aW9uKHN0cil7IHJldHVybiBwYXJzZUZsb2F0KHN0cikgfSldXG4gICAgICB9KVxuICAgICAgLy8gY2FsY3VsYXRlIGV2ZXJ5IHRyYW5zZm9ybWF0aW9uIGludG8gb25lIG1hdHJpeFxuICAgICAgLnJlZHVjZShmdW5jdGlvbihtYXRyaXgsIHRyYW5zZm9ybSl7XG5cbiAgICAgICAgaWYodHJhbnNmb3JtWzBdID09ICdtYXRyaXgnKSByZXR1cm4gbWF0cml4Lm11bHRpcGx5KGFycmF5VG9NYXRyaXgodHJhbnNmb3JtWzFdKSlcbiAgICAgICAgcmV0dXJuIG1hdHJpeFt0cmFuc2Zvcm1bMF1dLmFwcGx5KG1hdHJpeCwgdHJhbnNmb3JtWzFdKVxuXG4gICAgICB9LCBuZXcgU1ZHLk1hdHJpeCgpKVxuXG4gICAgcmV0dXJuIG1hdHJpeFxuICB9LFxuICAvLyBhZGQgYW4gZWxlbWVudCB0byBhbm90aGVyIHBhcmVudCB3aXRob3V0IGNoYW5naW5nIHRoZSB2aXN1YWwgcmVwcmVzZW50YXRpb24gb24gdGhlIHNjcmVlblxuICB0b1BhcmVudDogZnVuY3Rpb24ocGFyZW50KSB7XG4gICAgaWYodGhpcyA9PSBwYXJlbnQpIHJldHVybiB0aGlzXG4gICAgdmFyIGN0bSA9IHRoaXMuc2NyZWVuQ1RNKClcbiAgICB2YXIgdGVtcCA9IHBhcmVudC5yZWN0KDEsMSlcbiAgICB2YXIgcEN0bSA9IHRlbXAuc2NyZWVuQ1RNKCkuaW52ZXJzZSgpXG4gICAgdGVtcC5yZW1vdmUoKVxuXG4gICAgdGhpcy5hZGRUbyhwYXJlbnQpLnVudHJhbnNmb3JtKCkudHJhbnNmb3JtKHBDdG0ubXVsdGlwbHkoY3RtKSlcblxuICAgIHJldHVybiB0aGlzXG4gIH0sXG4gIC8vIHNhbWUgYXMgYWJvdmUgd2l0aCBwYXJlbnQgZXF1YWxzIHJvb3Qtc3ZnXG4gIHRvRG9jOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50b1BhcmVudCh0aGlzLmRvYygpKVxuICB9XG5cbn0pXG5cblNWRy5UcmFuc2Zvcm1hdGlvbiA9IFNWRy5pbnZlbnQoe1xuXG4gIGNyZWF0ZTogZnVuY3Rpb24oc291cmNlLCBpbnZlcnNlZCl7XG5cbiAgICBpZihhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgaW52ZXJzZWQgIT0gJ2Jvb2xlYW4nKXtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZShbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgfVxuXG4gICAgaWYodHlwZW9mIHNvdXJjZSA9PSAnb2JqZWN0Jyl7XG4gICAgICBmb3IodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSl7XG4gICAgICAgIHRoaXNbdGhpcy5hcmd1bWVudHNbaV1dID0gc291cmNlW3RoaXMuYXJndW1lbnRzW2ldXVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmKEFycmF5LmlzQXJyYXkoc291cmNlKSl7XG4gICAgICBmb3IodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSl7XG4gICAgICAgIHRoaXNbdGhpcy5hcmd1bWVudHNbaV1dID0gc291cmNlW2ldXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5pbnZlcnNlZCA9IGZhbHNlXG5cbiAgICBpZihpbnZlcnNlZCA9PT0gdHJ1ZSl7XG4gICAgICB0aGlzLmludmVyc2VkID0gdHJ1ZVxuICAgIH1cblxuICB9XG5cbiwgZXh0ZW5kOiB7XG5cbiAgICBhdDogZnVuY3Rpb24ocG9zKXtcblxuICAgICAgdmFyIHBhcmFtcyA9IFtdXG5cbiAgICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IHRoaXMuYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKXtcbiAgICAgICAgcGFyYW1zLnB1c2godGhpc1t0aGlzLmFyZ3VtZW50c1tpXV0pXG4gICAgICB9XG5cbiAgICAgIHZhciBtID0gdGhpcy5fdW5kbyB8fCBuZXcgU1ZHLk1hdHJpeCgpXG5cbiAgICAgIG0gPSBuZXcgU1ZHLk1hdHJpeCgpLm1vcnBoKFNWRy5NYXRyaXgucHJvdG90eXBlW3RoaXMubWV0aG9kXS5hcHBseShtLCBwYXJhbXMpKS5hdChwb3MpXG5cbiAgICAgIHJldHVybiB0aGlzLmludmVyc2VkID8gbS5pbnZlcnNlKCkgOiBtXG5cbiAgICB9XG5cbiAgLCB1bmRvOiBmdW5jdGlvbihvKXtcbiAgICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IHRoaXMuYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKXtcbiAgICAgICAgb1t0aGlzLmFyZ3VtZW50c1tpXV0gPSB0eXBlb2YgdGhpc1t0aGlzLmFyZ3VtZW50c1tpXV0gPT0gJ3VuZGVmaW5lZCcgPyAwIDogb1t0aGlzLmFyZ3VtZW50c1tpXV1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIG1ldGhvZCBTVkcuTWF0cml4LmV4dHJhY3Qgd2hpY2ggd2FzIHVzZWQgYmVmb3JlIGNhbGxpbmcgdGhpc1xuICAgICAgLy8gbWV0aG9kIHRvIG9idGFpbiBhIHZhbHVlIGZvciB0aGUgcGFyYW1ldGVyIG8gZG9lc24ndCByZXR1cm4gYSBjeCBhbmRcbiAgICAgIC8vIGEgY3kgc28gd2UgdXNlIHRoZSBvbmVzIHRoYXQgd2VyZSBwcm92aWRlZCB0byB0aGlzIG9iamVjdCBhdCBpdHMgY3JlYXRpb25cbiAgICAgIG8uY3ggPSB0aGlzLmN4XG4gICAgICBvLmN5ID0gdGhpcy5jeVxuXG4gICAgICB0aGlzLl91bmRvID0gbmV3IFNWR1tjYXBpdGFsaXplKHRoaXMubWV0aG9kKV0obywgdHJ1ZSkuYXQoMSlcblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgfVxuXG59KVxuXG5TVkcuVHJhbnNsYXRlID0gU1ZHLmludmVudCh7XG5cbiAgcGFyZW50OiBTVkcuTWF0cml4XG4sIGluaGVyaXQ6IFNWRy5UcmFuc2Zvcm1hdGlvblxuXG4sIGNyZWF0ZTogZnVuY3Rpb24oc291cmNlLCBpbnZlcnNlZCl7XG4gICAgaWYodHlwZW9mIHNvdXJjZSA9PSAnb2JqZWN0JykgdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHNvdXJjZSwgaW52ZXJzZWQpXG4gICAgZWxzZSB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICB9XG5cbiwgZXh0ZW5kOiB7XG4gICAgYXJndW1lbnRzOiBbJ3RyYW5zZm9ybWVkWCcsICd0cmFuc2Zvcm1lZFknXVxuICAsIG1ldGhvZDogJ3RyYW5zbGF0ZSdcbiAgfVxuXG59KVxuXG5TVkcuUm90YXRlID0gU1ZHLmludmVudCh7XG5cbiAgcGFyZW50OiBTVkcuTWF0cml4XG4sIGluaGVyaXQ6IFNWRy5UcmFuc2Zvcm1hdGlvblxuXG4sIGNyZWF0ZTogZnVuY3Rpb24oc291cmNlLCBpbnZlcnNlZCl7XG4gICAgaWYodHlwZW9mIHNvdXJjZSA9PSAnb2JqZWN0JykgdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHNvdXJjZSwgaW52ZXJzZWQpXG4gICAgZWxzZSB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICB9XG5cbiwgZXh0ZW5kOiB7XG4gICAgYXJndW1lbnRzOiBbJ3JvdGF0aW9uJywgJ2N4JywgJ2N5J11cbiAgLCBtZXRob2Q6ICdyb3RhdGUnXG4gICwgYXQ6IGZ1bmN0aW9uKHBvcyl7XG4gICAgICB2YXIgbSA9IG5ldyBTVkcuTWF0cml4KCkucm90YXRlKG5ldyBTVkcuTnVtYmVyKCkubW9ycGgodGhpcy5yb3RhdGlvbiAtICh0aGlzLl91bmRvID8gdGhpcy5fdW5kby5yb3RhdGlvbiA6IDApKS5hdChwb3MpLCB0aGlzLmN4LCB0aGlzLmN5KVxuICAgICAgcmV0dXJuIHRoaXMuaW52ZXJzZWQgPyBtLmludmVyc2UoKSA6IG1cbiAgICB9XG4gICwgdW5kbzogZnVuY3Rpb24obyl7XG4gICAgICB0aGlzLl91bmRvID0gb1xuICAgIH1cbiAgfVxuXG59KVxuXG5TVkcuU2NhbGUgPSBTVkcuaW52ZW50KHtcblxuICBwYXJlbnQ6IFNWRy5NYXRyaXhcbiwgaW5oZXJpdDogU1ZHLlRyYW5zZm9ybWF0aW9uXG5cbiwgY3JlYXRlOiBmdW5jdGlvbihzb3VyY2UsIGludmVyc2VkKXtcbiAgICBpZih0eXBlb2Ygc291cmNlID09ICdvYmplY3QnKSB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgc291cmNlLCBpbnZlcnNlZClcbiAgICBlbHNlIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gIH1cblxuLCBleHRlbmQ6IHtcbiAgICBhcmd1bWVudHM6IFsnc2NhbGVYJywgJ3NjYWxlWScsICdjeCcsICdjeSddXG4gICwgbWV0aG9kOiAnc2NhbGUnXG4gIH1cblxufSlcblxuU1ZHLlNrZXcgPSBTVkcuaW52ZW50KHtcblxuICBwYXJlbnQ6IFNWRy5NYXRyaXhcbiwgaW5oZXJpdDogU1ZHLlRyYW5zZm9ybWF0aW9uXG5cbiwgY3JlYXRlOiBmdW5jdGlvbihzb3VyY2UsIGludmVyc2VkKXtcbiAgICBpZih0eXBlb2Ygc291cmNlID09ICdvYmplY3QnKSB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgc291cmNlLCBpbnZlcnNlZClcbiAgICBlbHNlIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gIH1cblxuLCBleHRlbmQ6IHtcbiAgICBhcmd1bWVudHM6IFsnc2tld1gnLCAnc2tld1knLCAnY3gnLCAnY3knXVxuICAsIG1ldGhvZDogJ3NrZXcnXG4gIH1cblxufSlcblxuU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwge1xuICAvLyBEeW5hbWljIHN0eWxlIGdlbmVyYXRvclxuICBzdHlsZTogZnVuY3Rpb24ocywgdikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDApIHtcbiAgICAgIC8vIGdldCBmdWxsIHN0eWxlXG4gICAgICByZXR1cm4gdGhpcy5ub2RlLnN0eWxlLmNzc1RleHQgfHwgJydcblxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIC8vIGFwcGx5IGV2ZXJ5IHN0eWxlIGluZGl2aWR1YWxseSBpZiBhbiBvYmplY3QgaXMgcGFzc2VkXG4gICAgICBpZiAodHlwZW9mIHMgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2IGluIHMpIHRoaXMuc3R5bGUodiwgc1t2XSlcblxuICAgICAgfSBlbHNlIGlmIChTVkcucmVnZXguaXNDc3MudGVzdChzKSkge1xuICAgICAgICAvLyBwYXJzZSBjc3Mgc3RyaW5nXG4gICAgICAgIHMgPSBzLnNwbGl0KCc7JylcblxuICAgICAgICAvLyBhcHBseSBldmVyeSBkZWZpbml0aW9uIGluZGl2aWR1YWxseVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2ID0gc1tpXS5zcGxpdCgnOicpXG4gICAgICAgICAgdGhpcy5zdHlsZSh2WzBdLnJlcGxhY2UoL1xccysvZywgJycpLCB2WzFdKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBhY3QgYXMgYSBnZXR0ZXIgaWYgdGhlIGZpcnN0IGFuZCBvbmx5IGFyZ3VtZW50IGlzIG5vdCBhbiBvYmplY3RcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5zdHlsZVtjYW1lbENhc2UocyldXG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ub2RlLnN0eWxlW2NhbWVsQ2FzZShzKV0gPSB2ID09PSBudWxsIHx8IFNWRy5yZWdleC5pc0JsYW5rLnRlc3QodikgPyAnJyA6IHZcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG59KVxuU1ZHLlBhcmVudCA9IFNWRy5pbnZlbnQoe1xuICAvLyBJbml0aWFsaXplIG5vZGVcbiAgY3JlYXRlOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIGVsZW1lbnQpXG4gIH1cblxuICAvLyBJbmhlcml0IGZyb21cbiwgaW5oZXJpdDogU1ZHLkVsZW1lbnRcblxuICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuLCBleHRlbmQ6IHtcbiAgICAvLyBSZXR1cm5zIGFsbCBjaGlsZCBlbGVtZW50c1xuICAgIGNoaWxkcmVuOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBTVkcudXRpbHMubWFwKFNWRy51dGlscy5maWx0ZXJTVkdFbGVtZW50cyh0aGlzLm5vZGUuY2hpbGROb2RlcyksIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFNWRy5hZG9wdChub2RlKVxuICAgICAgfSlcbiAgICB9XG4gICAgLy8gQWRkIGdpdmVuIGVsZW1lbnQgYXQgYSBwb3NpdGlvblxuICAsIGFkZDogZnVuY3Rpb24oZWxlbWVudCwgaSkge1xuICAgICAgaWYgKGkgPT0gbnVsbClcbiAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKGVsZW1lbnQubm9kZSlcbiAgICAgIGVsc2UgaWYgKGVsZW1lbnQubm9kZSAhPSB0aGlzLm5vZGUuY2hpbGROb2Rlc1tpXSlcbiAgICAgICAgdGhpcy5ub2RlLmluc2VydEJlZm9yZShlbGVtZW50Lm5vZGUsIHRoaXMubm9kZS5jaGlsZE5vZGVzW2ldKVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICAvLyBCYXNpY2FsbHkgZG9lcyB0aGUgc2FtZSBhcyBgYWRkKClgIGJ1dCByZXR1cm5zIHRoZSBhZGRlZCBlbGVtZW50IGluc3RlYWRcbiAgLCBwdXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIGkpIHtcbiAgICAgIHRoaXMuYWRkKGVsZW1lbnQsIGkpXG4gICAgICByZXR1cm4gZWxlbWVudFxuICAgIH1cbiAgICAvLyBDaGVja3MgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaXMgYSBjaGlsZFxuICAsIGhhczogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZXgoZWxlbWVudCkgPj0gMFxuICAgIH1cbiAgICAvLyBHZXRzIGluZGV4IG9mIGdpdmVuIGVsZW1lbnRcbiAgLCBpbmRleDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwodGhpcy5ub2RlLmNoaWxkTm9kZXMpLmluZGV4T2YoZWxlbWVudC5ub2RlKVxuICAgIH1cbiAgICAvLyBHZXQgYSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxuICAsIGdldDogZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFNWRy5hZG9wdCh0aGlzLm5vZGUuY2hpbGROb2Rlc1tpXSlcbiAgICB9XG4gICAgLy8gR2V0IGZpcnN0IGNoaWxkXG4gICwgZmlyc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KDApXG4gICAgfVxuICAgIC8vIEdldCB0aGUgbGFzdCBjaGlsZFxuICAsIGxhc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMubm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDEpXG4gICAgfVxuICAgIC8vIEl0ZXJhdGVzIG92ZXIgYWxsIGNoaWxkcmVuIGFuZCBpbnZva2VzIGEgZ2l2ZW4gYmxvY2tcbiAgLCBlYWNoOiBmdW5jdGlvbihibG9jaywgZGVlcCkge1xuICAgICAgdmFyIGksIGlsXG4gICAgICAgICwgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuKClcblxuICAgICAgZm9yIChpID0gMCwgaWwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGlmIChjaGlsZHJlbltpXSBpbnN0YW5jZW9mIFNWRy5FbGVtZW50KVxuICAgICAgICAgIGJsb2NrLmFwcGx5KGNoaWxkcmVuW2ldLCBbaSwgY2hpbGRyZW5dKVxuXG4gICAgICAgIGlmIChkZWVwICYmIChjaGlsZHJlbltpXSBpbnN0YW5jZW9mIFNWRy5Db250YWluZXIpKVxuICAgICAgICAgIGNoaWxkcmVuW2ldLmVhY2goYmxvY2ssIGRlZXApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIC8vIFJlbW92ZSBhIGdpdmVuIGNoaWxkXG4gICwgcmVtb3ZlRWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgdGhpcy5ub2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQubm9kZSlcblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGFsbCBlbGVtZW50cyBpbiB0aGlzIGNvbnRhaW5lclxuICAsIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIHJlbW92ZSBjaGlsZHJlblxuICAgICAgd2hpbGUodGhpcy5ub2RlLmhhc0NoaWxkTm9kZXMoKSlcbiAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUNoaWxkKHRoaXMubm9kZS5sYXN0Q2hpbGQpXG5cbiAgICAgIC8vIHJlbW92ZSBkZWZzIHJlZmVyZW5jZVxuICAgICAgZGVsZXRlIHRoaXMuX2RlZnNcblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICwgLy8gR2V0IGRlZnNcbiAgICBkZWZzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmRvYygpLmRlZnMoKVxuICAgIH1cbiAgfVxuXG59KVxuXG5TVkcuZXh0ZW5kKFNWRy5QYXJlbnQsIHtcblxuICB1bmdyb3VwOiBmdW5jdGlvbihwYXJlbnQsIGRlcHRoKSB7XG4gICAgaWYoZGVwdGggPT09IDAgfHwgdGhpcyBpbnN0YW5jZW9mIFNWRy5EZWZzKSByZXR1cm4gdGhpc1xuXG4gICAgcGFyZW50ID0gcGFyZW50IHx8ICh0aGlzIGluc3RhbmNlb2YgU1ZHLkRvYyA/IHRoaXMgOiB0aGlzLnBhcmVudChTVkcuUGFyZW50KSlcbiAgICBkZXB0aCA9IGRlcHRoIHx8IEluZmluaXR5XG5cbiAgICB0aGlzLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgIGlmKHRoaXMgaW5zdGFuY2VvZiBTVkcuRGVmcykgcmV0dXJuIHRoaXNcbiAgICAgIGlmKHRoaXMgaW5zdGFuY2VvZiBTVkcuUGFyZW50KSByZXR1cm4gdGhpcy51bmdyb3VwKHBhcmVudCwgZGVwdGgtMSlcbiAgICAgIHJldHVybiB0aGlzLnRvUGFyZW50KHBhcmVudClcbiAgICB9KVxuXG4gICAgdGhpcy5ub2RlLmZpcnN0Q2hpbGQgfHwgdGhpcy5yZW1vdmUoKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcblxuICBmbGF0dGVuOiBmdW5jdGlvbihwYXJlbnQsIGRlcHRoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5ncm91cChwYXJlbnQsIGRlcHRoKVxuICB9XG5cbn0pXG5TVkcuQ29udGFpbmVyID0gU1ZHLmludmVudCh7XG4gIC8vIEluaXRpYWxpemUgbm9kZVxuICBjcmVhdGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgZWxlbWVudClcbiAgfVxuXG4gIC8vIEluaGVyaXQgZnJvbVxuLCBpbmhlcml0OiBTVkcuUGFyZW50XG5cbn0pXG5cblNWRy5WaWV3Qm94ID0gU1ZHLmludmVudCh7XG5cbiAgY3JlYXRlOiBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICB2YXIgaSwgYmFzZSA9IFswLCAwLCAwLCAwXVxuXG4gICAgdmFyIHgsIHksIHdpZHRoLCBoZWlnaHQsIGJveCwgdmlldywgd2UsIGhlXG4gICAgICAsIHdtICAgPSAxIC8vIHdpZHRoIG11bHRpcGxpZXJcbiAgICAgICwgaG0gICA9IDEgLy8gaGVpZ2h0IG11bHRpcGxpZXJcbiAgICAgICwgcmVnICA9IC9bKy1dPyg/OlxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykoPzplWystXT9cXGQrKT8vZ2lcblxuICAgIGlmKHNvdXJjZSBpbnN0YW5jZW9mIFNWRy5FbGVtZW50KXtcblxuICAgICAgd2UgPSBzb3VyY2VcbiAgICAgIGhlID0gc291cmNlXG4gICAgICB2aWV3ID0gKHNvdXJjZS5hdHRyKCd2aWV3Qm94JykgfHwgJycpLm1hdGNoKHJlZylcbiAgICAgIGJveCA9IHNvdXJjZS5iYm94XG5cbiAgICAgIC8vIGdldCBkaW1lbnNpb25zIG9mIGN1cnJlbnQgbm9kZVxuICAgICAgd2lkdGggID0gbmV3IFNWRy5OdW1iZXIoc291cmNlLndpZHRoKCkpXG4gICAgICBoZWlnaHQgPSBuZXcgU1ZHLk51bWJlcihzb3VyY2UuaGVpZ2h0KCkpXG5cbiAgICAgIC8vIGZpbmQgbmVhcmVzdCBub24tcGVyY2VudHVhbCBkaW1lbnNpb25zXG4gICAgICB3aGlsZSAod2lkdGgudW5pdCA9PSAnJScpIHtcbiAgICAgICAgd20gKj0gd2lkdGgudmFsdWVcbiAgICAgICAgd2lkdGggPSBuZXcgU1ZHLk51bWJlcih3ZSBpbnN0YW5jZW9mIFNWRy5Eb2MgPyB3ZS5wYXJlbnQoKS5vZmZzZXRXaWR0aCA6IHdlLnBhcmVudCgpLndpZHRoKCkpXG4gICAgICAgIHdlID0gd2UucGFyZW50KClcbiAgICAgIH1cbiAgICAgIHdoaWxlIChoZWlnaHQudW5pdCA9PSAnJScpIHtcbiAgICAgICAgaG0gKj0gaGVpZ2h0LnZhbHVlXG4gICAgICAgIGhlaWdodCA9IG5ldyBTVkcuTnVtYmVyKGhlIGluc3RhbmNlb2YgU1ZHLkRvYyA/IGhlLnBhcmVudCgpLm9mZnNldEhlaWdodCA6IGhlLnBhcmVudCgpLmhlaWdodCgpKVxuICAgICAgICBoZSA9IGhlLnBhcmVudCgpXG4gICAgICB9XG5cbiAgICAgIC8vIGVuc3VyZSBkZWZhdWx0c1xuICAgICAgdGhpcy54ICAgICAgPSAwXG4gICAgICB0aGlzLnkgICAgICA9IDBcbiAgICAgIHRoaXMud2lkdGggID0gd2lkdGggICogd21cbiAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICogaG1cbiAgICAgIHRoaXMuem9vbSAgID0gMVxuXG4gICAgICBpZiAodmlldykge1xuICAgICAgICAvLyBnZXQgd2lkdGggYW5kIGhlaWdodCBmcm9tIHZpZXdib3hcbiAgICAgICAgeCAgICAgID0gcGFyc2VGbG9hdCh2aWV3WzBdKVxuICAgICAgICB5ICAgICAgPSBwYXJzZUZsb2F0KHZpZXdbMV0pXG4gICAgICAgIHdpZHRoICA9IHBhcnNlRmxvYXQodmlld1syXSlcbiAgICAgICAgaGVpZ2h0ID0gcGFyc2VGbG9hdCh2aWV3WzNdKVxuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB6b29tIGFjY29yaW5nIHRvIHZpZXdib3hcbiAgICAgICAgdGhpcy56b29tID0gKCh0aGlzLndpZHRoIC8gdGhpcy5oZWlnaHQpID4gKHdpZHRoIC8gaGVpZ2h0KSkgP1xuICAgICAgICAgIHRoaXMuaGVpZ2h0IC8gaGVpZ2h0IDpcbiAgICAgICAgICB0aGlzLndpZHRoICAvIHdpZHRoXG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHJlYWwgcGl4ZWwgZGltZW5zaW9ucyBvbiBwYXJlbnQgU1ZHLkRvYyBlbGVtZW50XG4gICAgICAgIHRoaXMueCAgICAgID0geFxuICAgICAgICB0aGlzLnkgICAgICA9IHlcbiAgICAgICAgdGhpcy53aWR0aCAgPSB3aWR0aFxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodFxuXG4gICAgICB9XG5cbiAgICB9ZWxzZXtcblxuICAgICAgLy8gZW5zdXJlIHNvdXJjZSBhcyBvYmplY3RcbiAgICAgIHNvdXJjZSA9IHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnID9cbiAgICAgICAgc291cmNlLm1hdGNoKHJlZykubWFwKGZ1bmN0aW9uKGVsKXsgcmV0dXJuIHBhcnNlRmxvYXQoZWwpIH0pIDpcbiAgICAgIEFycmF5LmlzQXJyYXkoc291cmNlKSA/XG4gICAgICAgIHNvdXJjZSA6XG4gICAgICB0eXBlb2Ygc291cmNlID09ICdvYmplY3QnID9cbiAgICAgICAgW3NvdXJjZS54LCBzb3VyY2UueSwgc291cmNlLndpZHRoLCBzb3VyY2UuaGVpZ2h0XSA6XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID09IDQgP1xuICAgICAgICBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykgOlxuICAgICAgICBiYXNlXG5cbiAgICAgIHRoaXMueCA9IHNvdXJjZVswXVxuICAgICAgdGhpcy55ID0gc291cmNlWzFdXG4gICAgICB0aGlzLndpZHRoID0gc291cmNlWzJdXG4gICAgICB0aGlzLmhlaWdodCA9IHNvdXJjZVszXVxuICAgIH1cblxuXG4gIH1cblxuLCBleHRlbmQ6IHtcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnggKyAnICcgKyB0aGlzLnkgKyAnICcgKyB0aGlzLndpZHRoICsgJyAnICsgdGhpcy5oZWlnaHRcbiAgICB9XG4gICwgbW9ycGg6IGZ1bmN0aW9uKHYpe1xuXG4gICAgICB2YXIgdiA9IGFyZ3VtZW50cy5sZW5ndGggPT0gMSA/XG4gICAgICAgIFt2LngsIHYueSwgdi53aWR0aCwgdi5oZWlnaHRdIDpcbiAgICAgICAgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpXG5cbiAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBuZXcgU1ZHLlZpZXdCb3godilcblxuICAgICAgcmV0dXJuIHRoaXNcblxuICAgIH1cblxuICAsIGF0OiBmdW5jdGlvbihwb3MpIHtcblxuICAgIGlmKCF0aGlzLmRlc3RpbmF0aW9uKSByZXR1cm4gdGhpc1xuXG4gICAgcmV0dXJuIG5ldyBTVkcuVmlld0JveChbXG4gICAgICAgIHRoaXMueCArICh0aGlzLmRlc3RpbmF0aW9uLnggLSB0aGlzLngpICogcG9zXG4gICAgICAsIHRoaXMueSArICh0aGlzLmRlc3RpbmF0aW9uLnkgLSB0aGlzLnkpICogcG9zXG4gICAgICAsIHRoaXMud2lkdGggKyAodGhpcy5kZXN0aW5hdGlvbi53aWR0aCAtIHRoaXMud2lkdGgpICogcG9zXG4gICAgICAsIHRoaXMuaGVpZ2h0ICsgKHRoaXMuZGVzdGluYXRpb24uaGVpZ2h0IC0gdGhpcy5oZWlnaHQpICogcG9zXG4gICAgXSlcblxuICAgIH1cblxuICB9XG5cbiAgLy8gRGVmaW5lIHBhcmVudFxuLCBwYXJlbnQ6IFNWRy5Db250YWluZXJcblxuICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuLCBjb25zdHJ1Y3Q6IHtcblxuICAgIC8vIGdldC9zZXQgdmlld2JveFxuICAgIHZpZXdib3g6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDApXG4gICAgICAgIC8vIGFjdCBhcyBhIGdldHRlciBpZiB0aGVyZSBhcmUgbm8gYXJndW1lbnRzXG4gICAgICAgIHJldHVybiBuZXcgU1ZHLlZpZXdCb3godGhpcylcblxuICAgICAgLy8gb3RoZXJ3aXNlIGFjdCBhcyBhIHNldHRlclxuICAgICAgdiA9IGFyZ3VtZW50cy5sZW5ndGggPT0gMSA/XG4gICAgICAgIFt2LngsIHYueSwgdi53aWR0aCwgdi5oZWlnaHRdIDpcbiAgICAgICAgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpXG5cbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3ZpZXdCb3gnLCB2KVxuICAgIH1cblxuICB9XG5cbn0pXG4vLyBBZGQgZXZlbnRzIHRvIGVsZW1lbnRzXG47WyAgJ2NsaWNrJ1xuICAsICdkYmxjbGljaydcbiAgLCAnbW91c2Vkb3duJ1xuICAsICdtb3VzZXVwJ1xuICAsICdtb3VzZW92ZXInXG4gICwgJ21vdXNlb3V0J1xuICAsICdtb3VzZW1vdmUnXG4gIC8vICwgJ21vdXNlZW50ZXInIC0+IG5vdCBzdXBwb3J0ZWQgYnkgSUVcbiAgLy8gLCAnbW91c2VsZWF2ZScgLT4gbm90IHN1cHBvcnRlZCBieSBJRVxuICAsICd0b3VjaHN0YXJ0J1xuICAsICd0b3VjaG1vdmUnXG4gICwgJ3RvdWNobGVhdmUnXG4gICwgJ3RvdWNoZW5kJ1xuICAsICd0b3VjaGNhbmNlbCcgXS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgLy8gYWRkIGV2ZW50IHRvIFNWRy5FbGVtZW50XG4gIFNWRy5FbGVtZW50LnByb3RvdHlwZVtldmVudF0gPSBmdW5jdGlvbihmKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgICAvLyBiaW5kIGV2ZW50IHRvIGVsZW1lbnQgcmF0aGVyIHRoYW4gZWxlbWVudCBub2RlXG4gICAgdGhpcy5ub2RlWydvbicgKyBldmVudF0gPSB0eXBlb2YgZiA9PSAnZnVuY3Rpb24nID9cbiAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gZi5hcHBseShzZWxmLCBhcmd1bWVudHMpIH0gOiBudWxsXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbn0pXG5cbi8vIEluaXRpYWxpemUgbGlzdGVuZXJzIHN0YWNrXG5TVkcubGlzdGVuZXJzID0gW11cblNWRy5oYW5kbGVyTWFwID0gW11cblNWRy5saXN0ZW5lcklkID0gMFxuXG4vLyBBZGQgZXZlbnQgYmluZGVyIGluIHRoZSBTVkcgbmFtZXNwYWNlXG5TVkcub24gPSBmdW5jdGlvbihub2RlLCBldmVudCwgbGlzdGVuZXIsIGJpbmRpbmcpIHtcbiAgLy8gY3JlYXRlIGxpc3RlbmVyLCBnZXQgb2JqZWN0LWluZGV4XG4gIHZhciBsICAgICA9IGxpc3RlbmVyLmJpbmQoYmluZGluZyB8fCBub2RlLmluc3RhbmNlIHx8IG5vZGUpXG4gICAgLCBpbmRleCA9IChTVkcuaGFuZGxlck1hcC5pbmRleE9mKG5vZGUpICsgMSB8fCBTVkcuaGFuZGxlck1hcC5wdXNoKG5vZGUpKSAtIDFcbiAgICAsIGV2ICAgID0gZXZlbnQuc3BsaXQoJy4nKVswXVxuICAgICwgbnMgICAgPSBldmVudC5zcGxpdCgnLicpWzFdIHx8ICcqJ1xuXG5cbiAgLy8gZW5zdXJlIHZhbGlkIG9iamVjdFxuICBTVkcubGlzdGVuZXJzW2luZGV4XSAgICAgICAgID0gU1ZHLmxpc3RlbmVyc1tpbmRleF0gICAgICAgICB8fCB7fVxuICBTVkcubGlzdGVuZXJzW2luZGV4XVtldl0gICAgID0gU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdICAgICB8fCB7fVxuICBTVkcubGlzdGVuZXJzW2luZGV4XVtldl1bbnNdID0gU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdW25zXSB8fCB7fVxuXG4gIGlmKCFsaXN0ZW5lci5fc3ZnanNMaXN0ZW5lcklkKVxuICAgIGxpc3RlbmVyLl9zdmdqc0xpc3RlbmVySWQgPSArK1NWRy5saXN0ZW5lcklkXG5cbiAgLy8gcmVmZXJlbmNlIGxpc3RlbmVyXG4gIFNWRy5saXN0ZW5lcnNbaW5kZXhdW2V2XVtuc11bbGlzdGVuZXIuX3N2Z2pzTGlzdGVuZXJJZF0gPSBsXG5cbiAgLy8gYWRkIGxpc3RlbmVyXG4gIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldiwgbCwgZmFsc2UpXG59XG5cbi8vIEFkZCBldmVudCB1bmJpbmRlciBpbiB0aGUgU1ZHIG5hbWVzcGFjZVxuU1ZHLm9mZiA9IGZ1bmN0aW9uKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xuICB2YXIgaW5kZXggPSBTVkcuaGFuZGxlck1hcC5pbmRleE9mKG5vZGUpXG4gICAgLCBldiAgICA9IGV2ZW50ICYmIGV2ZW50LnNwbGl0KCcuJylbMF1cbiAgICAsIG5zICAgID0gZXZlbnQgJiYgZXZlbnQuc3BsaXQoJy4nKVsxXVxuXG4gIGlmKGluZGV4ID09IC0xKSByZXR1cm5cblxuICBpZiAobGlzdGVuZXIpIHtcbiAgICBpZih0eXBlb2YgbGlzdGVuZXIgPT0gJ2Z1bmN0aW9uJykgbGlzdGVuZXIgPSBsaXN0ZW5lci5fc3ZnanNMaXN0ZW5lcklkXG4gICAgaWYoIWxpc3RlbmVyKSByZXR1cm5cblxuICAgIC8vIHJlbW92ZSBsaXN0ZW5lciByZWZlcmVuY2VcbiAgICBpZiAoU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdICYmIFNWRy5saXN0ZW5lcnNbaW5kZXhdW2V2XVtucyB8fCAnKiddKSB7XG4gICAgICAvLyByZW1vdmUgbGlzdGVuZXJcbiAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldiwgU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdW25zIHx8ICcqJ11bbGlzdGVuZXJdLCBmYWxzZSlcblxuICAgICAgZGVsZXRlIFNWRy5saXN0ZW5lcnNbaW5kZXhdW2V2XVtucyB8fCAnKiddW2xpc3RlbmVyXVxuICAgIH1cblxuICB9IGVsc2UgaWYgKG5zICYmIGV2KSB7XG4gICAgLy8gcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yIGEgbmFtZXNwYWNlZCBldmVudFxuICAgIGlmIChTVkcubGlzdGVuZXJzW2luZGV4XVtldl0gJiYgU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdW25zXSkge1xuICAgICAgZm9yIChsaXN0ZW5lciBpbiBTVkcubGlzdGVuZXJzW2luZGV4XVtldl1bbnNdKVxuICAgICAgICBTVkcub2ZmKG5vZGUsIFtldiwgbnNdLmpvaW4oJy4nKSwgbGlzdGVuZXIpXG5cbiAgICAgIGRlbGV0ZSBTVkcubGlzdGVuZXJzW2luZGV4XVtldl1bbnNdXG4gICAgfVxuXG4gIH0gZWxzZSBpZiAobnMpe1xuICAgIC8vIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciBhIHNwZWNpZmljIG5hbWVzcGFjZVxuICAgIGZvcihldmVudCBpbiBTVkcubGlzdGVuZXJzW2luZGV4XSl7XG4gICAgICAgIGZvcihuYW1lc3BhY2UgaW4gU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZlbnRdKXtcbiAgICAgICAgICAgIGlmKG5zID09PSBuYW1lc3BhY2Upe1xuICAgICAgICAgICAgICAgIFNWRy5vZmYobm9kZSwgW2V2ZW50LCBuc10uam9pbignLicpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gIH0gZWxzZSBpZiAoZXYpIHtcbiAgICAvLyByZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgdGhlIGV2ZW50XG4gICAgaWYgKFNWRy5saXN0ZW5lcnNbaW5kZXhdW2V2XSkge1xuICAgICAgZm9yIChuYW1lc3BhY2UgaW4gU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdKVxuICAgICAgICBTVkcub2ZmKG5vZGUsIFtldiwgbmFtZXNwYWNlXS5qb2luKCcuJykpXG5cbiAgICAgIGRlbGV0ZSBTVkcubGlzdGVuZXJzW2luZGV4XVtldl1cbiAgICB9XG5cbiAgfSBlbHNlIHtcbiAgICAvLyByZW1vdmUgYWxsIGxpc3RlbmVycyBvbiBhIGdpdmVuIG5vZGVcbiAgICBmb3IgKGV2ZW50IGluIFNWRy5saXN0ZW5lcnNbaW5kZXhdKVxuICAgICAgU1ZHLm9mZihub2RlLCBldmVudClcblxuICAgIGRlbGV0ZSBTVkcubGlzdGVuZXJzW2luZGV4XVxuXG4gIH1cbn1cblxuLy9cblNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcbiAgLy8gQmluZCBnaXZlbiBldmVudCB0byBsaXN0ZW5lclxuICBvbjogZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyLCBiaW5kaW5nKSB7XG4gICAgU1ZHLm9uKHRoaXMubm9kZSwgZXZlbnQsIGxpc3RlbmVyLCBiaW5kaW5nKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuICAvLyBVbmJpbmQgZXZlbnQgZnJvbSBsaXN0ZW5lclxuLCBvZmY6IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIFNWRy5vZmYodGhpcy5ub2RlLCBldmVudCwgbGlzdGVuZXIpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG4gIC8vIEZpcmUgZ2l2ZW4gZXZlbnRcbiwgZmlyZTogZnVuY3Rpb24oZXZlbnQsIGRhdGEpIHtcblxuICAgIC8vIERpc3BhdGNoIGV2ZW50XG4gICAgaWYoZXZlbnQgaW5zdGFuY2VvZiBFdmVudCl7XG4gICAgICAgIHRoaXMubm9kZS5kaXNwYXRjaEV2ZW50KGV2ZW50KVxuICAgIH1lbHNle1xuICAgICAgICB0aGlzLm5vZGUuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoZXZlbnQsIHtkZXRhaWw6ZGF0YX0pKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cbn0pXG5cblNWRy5EZWZzID0gU1ZHLmludmVudCh7XG4gIC8vIEluaXRpYWxpemUgbm9kZVxuICBjcmVhdGU6ICdkZWZzJ1xuXG4gIC8vIEluaGVyaXQgZnJvbVxuLCBpbmhlcml0OiBTVkcuQ29udGFpbmVyXG5cbn0pXG5TVkcuRyA9IFNWRy5pbnZlbnQoe1xuICAvLyBJbml0aWFsaXplIG5vZGVcbiAgY3JlYXRlOiAnZydcblxuICAvLyBJbmhlcml0IGZyb21cbiwgaW5oZXJpdDogU1ZHLkNvbnRhaW5lclxuXG4gIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4sIGV4dGVuZDoge1xuICAgIC8vIE1vdmUgb3ZlciB4LWF4aXNcbiAgICB4OiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4geCA9PSBudWxsID8gdGhpcy50cmFuc2Zvcm0oJ3gnKSA6IHRoaXMudHJhbnNmb3JtKHsgeDogeCAtIHRoaXMueCgpIH0sIHRydWUpXG4gICAgfVxuICAgIC8vIE1vdmUgb3ZlciB5LWF4aXNcbiAgLCB5OiBmdW5jdGlvbih5KSB7XG4gICAgICByZXR1cm4geSA9PSBudWxsID8gdGhpcy50cmFuc2Zvcm0oJ3knKSA6IHRoaXMudHJhbnNmb3JtKHsgeTogeSAtIHRoaXMueSgpIH0sIHRydWUpXG4gICAgfVxuICAgIC8vIE1vdmUgYnkgY2VudGVyIG92ZXIgeC1heGlzXG4gICwgY3g6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB4ID09IG51bGwgPyB0aGlzLmdib3goKS5jeCA6IHRoaXMueCh4IC0gdGhpcy5nYm94KCkud2lkdGggLyAyKVxuICAgIH1cbiAgICAvLyBNb3ZlIGJ5IGNlbnRlciBvdmVyIHktYXhpc1xuICAsIGN5OiBmdW5jdGlvbih5KSB7XG4gICAgICByZXR1cm4geSA9PSBudWxsID8gdGhpcy5nYm94KCkuY3kgOiB0aGlzLnkoeSAtIHRoaXMuZ2JveCgpLmhlaWdodCAvIDIpXG4gICAgfVxuICAsIGdib3g6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgYmJveCAgPSB0aGlzLmJib3goKVxuICAgICAgICAsIHRyYW5zID0gdGhpcy50cmFuc2Zvcm0oKVxuXG4gICAgICBiYm94LnggICs9IHRyYW5zLnhcbiAgICAgIGJib3gueDIgKz0gdHJhbnMueFxuICAgICAgYmJveC5jeCArPSB0cmFucy54XG5cbiAgICAgIGJib3gueSAgKz0gdHJhbnMueVxuICAgICAgYmJveC55MiArPSB0cmFucy55XG4gICAgICBiYm94LmN5ICs9IHRyYW5zLnlcblxuICAgICAgcmV0dXJuIGJib3hcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuLCBjb25zdHJ1Y3Q6IHtcbiAgICAvLyBDcmVhdGUgYSBncm91cCBlbGVtZW50XG4gICAgZ3JvdXA6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuRylcbiAgICB9XG4gIH1cbn0pXG5cbi8vICMjIyBUaGlzIG1vZHVsZSBhZGRzIGJhY2t3YXJkIC8gZm9yd2FyZCBmdW5jdGlvbmFsaXR5IHRvIGVsZW1lbnRzLlxuXG4vL1xuU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwge1xuICAvLyBHZXQgYWxsIHNpYmxpbmdzLCBpbmNsdWRpbmcgbXlzZWxmXG4gIHNpYmxpbmdzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQoKS5jaGlsZHJlbigpXG4gIH1cbiAgLy8gR2V0IHRoZSBjdXJlbnQgcG9zaXRpb24gc2libGluZ3NcbiwgcG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBhcmVudCgpLmluZGV4KHRoaXMpXG4gIH1cbiAgLy8gR2V0IHRoZSBuZXh0IGVsZW1lbnQgKHdpbGwgcmV0dXJuIG51bGwgaWYgdGhlcmUgaXMgbm9uZSlcbiwgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2libGluZ3MoKVt0aGlzLnBvc2l0aW9uKCkgKyAxXVxuICB9XG4gIC8vIEdldCB0aGUgbmV4dCBlbGVtZW50ICh3aWxsIHJldHVybiBudWxsIGlmIHRoZXJlIGlzIG5vbmUpXG4sIHByZXZpb3VzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zaWJsaW5ncygpW3RoaXMucG9zaXRpb24oKSAtIDFdXG4gIH1cbiAgLy8gU2VuZCBnaXZlbiBlbGVtZW50IG9uZSBzdGVwIGZvcndhcmRcbiwgZm9yd2FyZDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGkgPSB0aGlzLnBvc2l0aW9uKCkgKyAxXG4gICAgICAsIHAgPSB0aGlzLnBhcmVudCgpXG5cbiAgICAvLyBtb3ZlIG5vZGUgb25lIHN0ZXAgZm9yd2FyZFxuICAgIHAucmVtb3ZlRWxlbWVudCh0aGlzKS5hZGQodGhpcywgaSlcblxuICAgIC8vIG1ha2Ugc3VyZSBkZWZzIG5vZGUgaXMgYWx3YXlzIGF0IHRoZSB0b3BcbiAgICBpZiAocCBpbnN0YW5jZW9mIFNWRy5Eb2MpXG4gICAgICBwLm5vZGUuYXBwZW5kQ2hpbGQocC5kZWZzKCkubm9kZSlcblxuICAgIHJldHVybiB0aGlzXG4gIH1cbiAgLy8gU2VuZCBnaXZlbiBlbGVtZW50IG9uZSBzdGVwIGJhY2t3YXJkXG4sIGJhY2t3YXJkOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgaSA9IHRoaXMucG9zaXRpb24oKVxuXG4gICAgaWYgKGkgPiAwKVxuICAgICAgdGhpcy5wYXJlbnQoKS5yZW1vdmVFbGVtZW50KHRoaXMpLmFkZCh0aGlzLCBpIC0gMSlcblxuICAgIHJldHVybiB0aGlzXG4gIH1cbiAgLy8gU2VuZCBnaXZlbiBlbGVtZW50IGFsbCB0aGUgd2F5IHRvIHRoZSBmcm9udFxuLCBmcm9udDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhcmVudCgpXG5cbiAgICAvLyBNb3ZlIG5vZGUgZm9yd2FyZFxuICAgIHAubm9kZS5hcHBlbmRDaGlsZCh0aGlzLm5vZGUpXG5cbiAgICAvLyBNYWtlIHN1cmUgZGVmcyBub2RlIGlzIGFsd2F5cyBhdCB0aGUgdG9wXG4gICAgaWYgKHAgaW5zdGFuY2VvZiBTVkcuRG9jKVxuICAgICAgcC5ub2RlLmFwcGVuZENoaWxkKHAuZGVmcygpLm5vZGUpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG4gIC8vIFNlbmQgZ2l2ZW4gZWxlbWVudCBhbGwgdGhlIHdheSB0byB0aGUgYmFja1xuLCBiYWNrOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5wb3NpdGlvbigpID4gMClcbiAgICAgIHRoaXMucGFyZW50KCkucmVtb3ZlRWxlbWVudCh0aGlzKS5hZGQodGhpcywgMClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cbiAgLy8gSW5zZXJ0cyBhIGdpdmVuIGVsZW1lbnQgYmVmb3JlIHRoZSB0YXJnZXRlZCBlbGVtZW50XG4sIGJlZm9yZTogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIGVsZW1lbnQucmVtb3ZlKClcblxuICAgIHZhciBpID0gdGhpcy5wb3NpdGlvbigpXG5cbiAgICB0aGlzLnBhcmVudCgpLmFkZChlbGVtZW50LCBpKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuICAvLyBJbnN0ZXJzIGEgZ2l2ZW4gZWxlbWVudCBhZnRlciB0aGUgdGFyZ2V0ZWQgZWxlbWVudFxuLCBhZnRlcjogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIGVsZW1lbnQucmVtb3ZlKClcblxuICAgIHZhciBpID0gdGhpcy5wb3NpdGlvbigpXG5cbiAgICB0aGlzLnBhcmVudCgpLmFkZChlbGVtZW50LCBpICsgMSlcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxufSlcblNWRy5NYXNrID0gU1ZHLmludmVudCh7XG4gIC8vIEluaXRpYWxpemUgbm9kZVxuICBjcmVhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBTVkcuY3JlYXRlKCdtYXNrJykpXG5cbiAgICAvLyBrZWVwIHJlZmVyZW5jZXMgdG8gbWFza2VkIGVsZW1lbnRzXG4gICAgdGhpcy50YXJnZXRzID0gW11cbiAgfVxuXG4gIC8vIEluaGVyaXQgZnJvbVxuLCBpbmhlcml0OiBTVkcuQ29udGFpbmVyXG5cbiAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiwgZXh0ZW5kOiB7XG4gICAgLy8gVW5tYXNrIGFsbCBtYXNrZWQgZWxlbWVudHMgYW5kIHJlbW92ZSBpdHNlbGZcbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gdW5tYXNrIGFsbCB0YXJnZXRzXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50YXJnZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAodGhpcy50YXJnZXRzW2ldKVxuICAgICAgICAgIHRoaXMudGFyZ2V0c1tpXS51bm1hc2soKVxuICAgICAgdGhpcy50YXJnZXRzID0gW11cblxuICAgICAgLy8gcmVtb3ZlIG1hc2sgZnJvbSBwYXJlbnRcbiAgICAgIHRoaXMucGFyZW50KCkucmVtb3ZlRWxlbWVudCh0aGlzKVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBwYXJlbnQgbWV0aG9kXG4sIGNvbnN0cnVjdDoge1xuICAgIC8vIENyZWF0ZSBtYXNraW5nIGVsZW1lbnRcbiAgICBtYXNrOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlZnMoKS5wdXQobmV3IFNWRy5NYXNrKVxuICAgIH1cbiAgfVxufSlcblxuXG5TVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XG4gIC8vIERpc3RyaWJ1dGUgbWFzayB0byBzdmcgZWxlbWVudFxuICBtYXNrV2l0aDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIC8vIHVzZSBnaXZlbiBtYXNrIG9yIGNyZWF0ZSBhIG5ldyBvbmVcbiAgICB0aGlzLm1hc2tlciA9IGVsZW1lbnQgaW5zdGFuY2VvZiBTVkcuTWFzayA/IGVsZW1lbnQgOiB0aGlzLnBhcmVudCgpLm1hc2soKS5hZGQoZWxlbWVudClcblxuICAgIC8vIHN0b3JlIHJldmVyZW5jZSBvbiBzZWxmIGluIG1hc2tcbiAgICB0aGlzLm1hc2tlci50YXJnZXRzLnB1c2godGhpcylcblxuICAgIC8vIGFwcGx5IG1hc2tcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdtYXNrJywgJ3VybChcIiMnICsgdGhpcy5tYXNrZXIuYXR0cignaWQnKSArICdcIiknKVxuICB9XG4gIC8vIFVubWFzayBlbGVtZW50XG4sIHVubWFzazogZnVuY3Rpb24oKSB7XG4gICAgZGVsZXRlIHRoaXMubWFza2VyXG4gICAgcmV0dXJuIHRoaXMuYXR0cignbWFzaycsIG51bGwpXG4gIH1cblxufSlcblxuU1ZHLkNsaXBQYXRoID0gU1ZHLmludmVudCh7XG4gIC8vIEluaXRpYWxpemUgbm9kZVxuICBjcmVhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBTVkcuY3JlYXRlKCdjbGlwUGF0aCcpKVxuXG4gICAgLy8ga2VlcCByZWZlcmVuY2VzIHRvIGNsaXBwZWQgZWxlbWVudHNcbiAgICB0aGlzLnRhcmdldHMgPSBbXVxuICB9XG5cbiAgLy8gSW5oZXJpdCBmcm9tXG4sIGluaGVyaXQ6IFNWRy5Db250YWluZXJcblxuICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuLCBleHRlbmQ6IHtcbiAgICAvLyBVbmNsaXAgYWxsIGNsaXBwZWQgZWxlbWVudHMgYW5kIHJlbW92ZSBpdHNlbGZcbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gdW5jbGlwIGFsbCB0YXJnZXRzXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50YXJnZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAodGhpcy50YXJnZXRzW2ldKVxuICAgICAgICAgIHRoaXMudGFyZ2V0c1tpXS51bmNsaXAoKVxuICAgICAgdGhpcy50YXJnZXRzID0gW11cblxuICAgICAgLy8gcmVtb3ZlIGNsaXBQYXRoIGZyb20gcGFyZW50XG4gICAgICB0aGlzLnBhcmVudCgpLnJlbW92ZUVsZW1lbnQodGhpcylcblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuLCBjb25zdHJ1Y3Q6IHtcbiAgICAvLyBDcmVhdGUgY2xpcHBpbmcgZWxlbWVudFxuICAgIGNsaXA6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVmcygpLnB1dChuZXcgU1ZHLkNsaXBQYXRoKVxuICAgIH1cbiAgfVxufSlcblxuLy9cblNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcbiAgLy8gRGlzdHJpYnV0ZSBjbGlwUGF0aCB0byBzdmcgZWxlbWVudFxuICBjbGlwV2l0aDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIC8vIHVzZSBnaXZlbiBjbGlwIG9yIGNyZWF0ZSBhIG5ldyBvbmVcbiAgICB0aGlzLmNsaXBwZXIgPSBlbGVtZW50IGluc3RhbmNlb2YgU1ZHLkNsaXBQYXRoID8gZWxlbWVudCA6IHRoaXMucGFyZW50KCkuY2xpcCgpLmFkZChlbGVtZW50KVxuXG4gICAgLy8gc3RvcmUgcmV2ZXJlbmNlIG9uIHNlbGYgaW4gbWFza1xuICAgIHRoaXMuY2xpcHBlci50YXJnZXRzLnB1c2godGhpcylcblxuICAgIC8vIGFwcGx5IG1hc2tcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdjbGlwLXBhdGgnLCAndXJsKFwiIycgKyB0aGlzLmNsaXBwZXIuYXR0cignaWQnKSArICdcIiknKVxuICB9XG4gIC8vIFVuY2xpcCBlbGVtZW50XG4sIHVuY2xpcDogZnVuY3Rpb24oKSB7XG4gICAgZGVsZXRlIHRoaXMuY2xpcHBlclxuICAgIHJldHVybiB0aGlzLmF0dHIoJ2NsaXAtcGF0aCcsIG51bGwpXG4gIH1cblxufSlcblNWRy5HcmFkaWVudCA9IFNWRy5pbnZlbnQoe1xuICAvLyBJbml0aWFsaXplIG5vZGVcbiAgY3JlYXRlOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIFNWRy5jcmVhdGUodHlwZSArICdHcmFkaWVudCcpKVxuXG4gICAgLy8gc3RvcmUgdHlwZVxuICAgIHRoaXMudHlwZSA9IHR5cGVcbiAgfVxuXG4gIC8vIEluaGVyaXQgZnJvbVxuLCBpbmhlcml0OiBTVkcuQ29udGFpbmVyXG5cbiAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiwgZXh0ZW5kOiB7XG4gICAgLy8gQWRkIGEgY29sb3Igc3RvcFxuICAgIGF0OiBmdW5jdGlvbihvZmZzZXQsIGNvbG9yLCBvcGFjaXR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5TdG9wKS51cGRhdGUob2Zmc2V0LCBjb2xvciwgb3BhY2l0eSlcbiAgICB9XG4gICAgLy8gVXBkYXRlIGdyYWRpZW50XG4gICwgdXBkYXRlOiBmdW5jdGlvbihibG9jaykge1xuICAgICAgLy8gcmVtb3ZlIGFsbCBzdG9wc1xuICAgICAgdGhpcy5jbGVhcigpXG5cbiAgICAgIC8vIGludm9rZSBwYXNzZWQgYmxvY2tcbiAgICAgIGlmICh0eXBlb2YgYmxvY2sgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgYmxvY2suY2FsbCh0aGlzLCB0aGlzKVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICAvLyBSZXR1cm4gdGhlIGZpbGwgaWRcbiAgLCBmaWxsOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAndXJsKCMnICsgdGhpcy5pZCgpICsgJyknXG4gICAgfVxuICAgIC8vIEFsaWFzIHN0cmluZyBjb252ZXJ0aW9uIHRvIGZpbGxcbiAgLCB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWxsKClcbiAgICB9XG4gICAgLy8gY3VzdG9tIGF0dHIgdG8gaGFuZGxlIHRyYW5zZm9ybVxuICAsIGF0dHI6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgIGlmKGEgPT0gJ3RyYW5zZm9ybScpIGEgPSAnZ3JhZGllbnRUcmFuc2Zvcm0nXG4gICAgICByZXR1cm4gU1ZHLkNvbnRhaW5lci5wcm90b3R5cGUuYXR0ci5jYWxsKHRoaXMsIGEsIGIsIGMpXG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiwgY29uc3RydWN0OiB7XG4gICAgLy8gQ3JlYXRlIGdyYWRpZW50IGVsZW1lbnQgaW4gZGVmc1xuICAgIGdyYWRpZW50OiBmdW5jdGlvbih0eXBlLCBibG9jaykge1xuICAgICAgcmV0dXJuIHRoaXMuZGVmcygpLmdyYWRpZW50KHR5cGUsIGJsb2NrKVxuICAgIH1cbiAgfVxufSlcblxuLy8gQWRkIGFuaW1hdGFibGUgbWV0aG9kcyB0byBib3RoIGdyYWRpZW50IGFuZCBmeCBtb2R1bGVcblNWRy5leHRlbmQoU1ZHLkdyYWRpZW50LCBTVkcuRlgsIHtcbiAgLy8gRnJvbSBwb3NpdGlvblxuICBmcm9tOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuICh0aGlzLl90YXJnZXQgfHwgdGhpcykudHlwZSA9PSAncmFkaWFsJyA/XG4gICAgICB0aGlzLmF0dHIoeyBmeDogbmV3IFNWRy5OdW1iZXIoeCksIGZ5OiBuZXcgU1ZHLk51bWJlcih5KSB9KSA6XG4gICAgICB0aGlzLmF0dHIoeyB4MTogbmV3IFNWRy5OdW1iZXIoeCksIHkxOiBuZXcgU1ZHLk51bWJlcih5KSB9KVxuICB9XG4gIC8vIFRvIHBvc2l0aW9uXG4sIHRvOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuICh0aGlzLl90YXJnZXQgfHwgdGhpcykudHlwZSA9PSAncmFkaWFsJyA/XG4gICAgICB0aGlzLmF0dHIoeyBjeDogbmV3IFNWRy5OdW1iZXIoeCksIGN5OiBuZXcgU1ZHLk51bWJlcih5KSB9KSA6XG4gICAgICB0aGlzLmF0dHIoeyB4MjogbmV3IFNWRy5OdW1iZXIoeCksIHkyOiBuZXcgU1ZHLk51bWJlcih5KSB9KVxuICB9XG59KVxuXG4vLyBCYXNlIGdyYWRpZW50IGdlbmVyYXRpb25cblNWRy5leHRlbmQoU1ZHLkRlZnMsIHtcbiAgLy8gZGVmaW5lIGdyYWRpZW50XG4gIGdyYWRpZW50OiBmdW5jdGlvbih0eXBlLCBibG9jaykge1xuICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLkdyYWRpZW50KHR5cGUpKS51cGRhdGUoYmxvY2spXG4gIH1cblxufSlcblxuU1ZHLlN0b3AgPSBTVkcuaW52ZW50KHtcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gIGNyZWF0ZTogJ3N0b3AnXG5cbiAgLy8gSW5oZXJpdCBmcm9tXG4sIGluaGVyaXQ6IFNWRy5FbGVtZW50XG5cbiAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiwgZXh0ZW5kOiB7XG4gICAgLy8gYWRkIGNvbG9yIHN0b3BzXG4gICAgdXBkYXRlOiBmdW5jdGlvbihvKSB7XG4gICAgICBpZiAodHlwZW9mIG8gPT0gJ251bWJlcicgfHwgbyBpbnN0YW5jZW9mIFNWRy5OdW1iZXIpIHtcbiAgICAgICAgbyA9IHtcbiAgICAgICAgICBvZmZzZXQ6ICBhcmd1bWVudHNbMF1cbiAgICAgICAgLCBjb2xvcjogICBhcmd1bWVudHNbMV1cbiAgICAgICAgLCBvcGFjaXR5OiBhcmd1bWVudHNbMl1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBzZXQgYXR0cmlidXRlc1xuICAgICAgaWYgKG8ub3BhY2l0eSAhPSBudWxsKSB0aGlzLmF0dHIoJ3N0b3Atb3BhY2l0eScsIG8ub3BhY2l0eSlcbiAgICAgIGlmIChvLmNvbG9yICAgIT0gbnVsbCkgdGhpcy5hdHRyKCdzdG9wLWNvbG9yJywgby5jb2xvcilcbiAgICAgIGlmIChvLm9mZnNldCAgIT0gbnVsbCkgdGhpcy5hdHRyKCdvZmZzZXQnLCBuZXcgU1ZHLk51bWJlcihvLm9mZnNldCkpXG5cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICB9XG5cbn0pXG5cblNWRy5QYXR0ZXJuID0gU1ZHLmludmVudCh7XG4gIC8vIEluaXRpYWxpemUgbm9kZVxuICBjcmVhdGU6ICdwYXR0ZXJuJ1xuXG4gIC8vIEluaGVyaXQgZnJvbVxuLCBpbmhlcml0OiBTVkcuQ29udGFpbmVyXG5cbiAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiwgZXh0ZW5kOiB7XG4gICAgLy8gUmV0dXJuIHRoZSBmaWxsIGlkXG4gICAgZmlsbDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJ3VybCgjJyArIHRoaXMuaWQoKSArICcpJ1xuICAgIH1cbiAgICAvLyBVcGRhdGUgcGF0dGVybiBieSByZWJ1aWxkaW5nXG4gICwgdXBkYXRlOiBmdW5jdGlvbihibG9jaykge1xuICAgICAgLy8gcmVtb3ZlIGNvbnRlbnRcbiAgICAgIHRoaXMuY2xlYXIoKVxuXG4gICAgICAvLyBpbnZva2UgcGFzc2VkIGJsb2NrXG4gICAgICBpZiAodHlwZW9mIGJsb2NrID09ICdmdW5jdGlvbicpXG4gICAgICAgIGJsb2NrLmNhbGwodGhpcywgdGhpcylcblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgLy8gQWxpYXMgc3RyaW5nIGNvbnZlcnRpb24gdG8gZmlsbFxuICAsIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbGwoKVxuICAgIH1cbiAgICAvLyBjdXN0b20gYXR0ciB0byBoYW5kbGUgdHJhbnNmb3JtXG4gICwgYXR0cjogZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAgaWYoYSA9PSAndHJhbnNmb3JtJykgYSA9ICdwYXR0ZXJuVHJhbnNmb3JtJ1xuICAgICAgcmV0dXJuIFNWRy5Db250YWluZXIucHJvdG90eXBlLmF0dHIuY2FsbCh0aGlzLCBhLCBiLCBjKVxuICAgIH1cblxuICB9XG5cbiAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiwgY29uc3RydWN0OiB7XG4gICAgLy8gQ3JlYXRlIHBhdHRlcm4gZWxlbWVudCBpbiBkZWZzXG4gICAgcGF0dGVybjogZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgYmxvY2spIHtcbiAgICAgIHJldHVybiB0aGlzLmRlZnMoKS5wYXR0ZXJuKHdpZHRoLCBoZWlnaHQsIGJsb2NrKVxuICAgIH1cbiAgfVxufSlcblxuU1ZHLmV4dGVuZChTVkcuRGVmcywge1xuICAvLyBEZWZpbmUgZ3JhZGllbnRcbiAgcGF0dGVybjogZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgYmxvY2spIHtcbiAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5QYXR0ZXJuKS51cGRhdGUoYmxvY2spLmF0dHIoe1xuICAgICAgeDogICAgICAgICAgICAwXG4gICAgLCB5OiAgICAgICAgICAgIDBcbiAgICAsIHdpZHRoOiAgICAgICAgd2lkdGhcbiAgICAsIGhlaWdodDogICAgICAgaGVpZ2h0XG4gICAgLCBwYXR0ZXJuVW5pdHM6ICd1c2VyU3BhY2VPblVzZSdcbiAgICB9KVxuICB9XG5cbn0pXG5TVkcuRG9jID0gU1ZHLmludmVudCh7XG4gIC8vIEluaXRpYWxpemUgbm9kZVxuICBjcmVhdGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgLy8gZW5zdXJlIHRoZSBwcmVzZW5jZSBvZiBhIGRvbSBlbGVtZW50XG4gICAgICBlbGVtZW50ID0gdHlwZW9mIGVsZW1lbnQgPT0gJ3N0cmluZycgP1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50KSA6XG4gICAgICAgIGVsZW1lbnRcblxuICAgICAgLy8gSWYgdGhlIHRhcmdldCBpcyBhbiBzdmcgZWxlbWVudCwgdXNlIHRoYXQgZWxlbWVudCBhcyB0aGUgbWFpbiB3cmFwcGVyLlxuICAgICAgLy8gVGhpcyBhbGxvd3Mgc3ZnLmpzIHRvIHdvcmsgd2l0aCBzdmcgZG9jdW1lbnRzIGFzIHdlbGwuXG4gICAgICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PSAnc3ZnJykge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgZWxlbWVudClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBTVkcuY3JlYXRlKCdzdmcnKSlcbiAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLm5vZGUpXG4gICAgICAgIHRoaXMuc2l6ZSgnMTAwJScsICcxMDAlJylcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IHN2ZyBlbGVtZW50IGF0dHJpYnV0ZXMgYW5kIGVuc3VyZSBkZWZzIG5vZGVcbiAgICAgIHRoaXMubmFtZXNwYWNlKCkuZGVmcygpXG4gICAgfVxuICB9XG5cbiAgLy8gSW5oZXJpdCBmcm9tXG4sIGluaGVyaXQ6IFNWRy5Db250YWluZXJcblxuICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuLCBleHRlbmQ6IHtcbiAgICAvLyBBZGQgbmFtZXNwYWNlc1xuICAgIG5hbWVzcGFjZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgICAgICAuYXR0cih7IHhtbG5zOiBTVkcubnMsIHZlcnNpb246ICcxLjEnIH0pXG4gICAgICAgIC5hdHRyKCd4bWxuczp4bGluaycsIFNWRy54bGluaywgU1ZHLnhtbG5zKVxuICAgICAgICAuYXR0cigneG1sbnM6c3ZnanMnLCBTVkcuc3ZnanMsIFNWRy54bWxucylcbiAgICB9XG4gICAgLy8gQ3JlYXRlcyBhbmQgcmV0dXJucyBkZWZzIGVsZW1lbnRcbiAgLCBkZWZzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5fZGVmcykge1xuICAgICAgICB2YXIgZGVmc1xuXG4gICAgICAgIC8vIEZpbmQgb3IgY3JlYXRlIGEgZGVmcyBlbGVtZW50IGluIHRoaXMgaW5zdGFuY2VcbiAgICAgICAgaWYgKGRlZnMgPSB0aGlzLm5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2RlZnMnKVswXSlcbiAgICAgICAgICB0aGlzLl9kZWZzID0gU1ZHLmFkb3B0KGRlZnMpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aGlzLl9kZWZzID0gbmV3IFNWRy5EZWZzXG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBkZWZzIG5vZGUgaXMgYXQgdGhlIGVuZCBvZiB0aGUgc3RhY2tcbiAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHRoaXMuX2RlZnMubm9kZSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2RlZnNcbiAgICB9XG4gICAgLy8gY3VzdG9tIHBhcmVudCBtZXRob2RcbiAgLCBwYXJlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZS5wYXJlbnROb2RlLm5vZGVOYW1lID09ICcjZG9jdW1lbnQnID8gbnVsbCA6IHRoaXMubm9kZS5wYXJlbnROb2RlXG4gICAgfVxuICAgIC8vIEZpeCBmb3IgcG9zc2libGUgc3ViLXBpeGVsIG9mZnNldC4gU2VlOlxuICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTYwODgxMlxuICAsIHNwb2Y6IGZ1bmN0aW9uKHNwb2YpIHtcbiAgICAgIHZhciBwb3MgPSB0aGlzLm5vZGUuZ2V0U2NyZWVuQ1RNKClcblxuICAgICAgaWYgKHBvcylcbiAgICAgICAgdGhpc1xuICAgICAgICAgIC5zdHlsZSgnbGVmdCcsICgtcG9zLmUgJSAxKSArICdweCcpXG4gICAgICAgICAgLnN0eWxlKCd0b3AnLCAgKC1wb3MuZiAlIDEpICsgJ3B4JylcblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAgIC8vIFJlbW92ZXMgdGhlIGRvYyBmcm9tIHRoZSBET01cbiAgLCByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYodGhpcy5wYXJlbnQoKSkge1xuICAgICAgICB0aGlzLnBhcmVudCgpLnJlbW92ZUNoaWxkKHRoaXMubm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG59KVxuXG5TVkcuU2hhcGUgPSBTVkcuaW52ZW50KHtcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gIGNyZWF0ZTogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBlbGVtZW50KVxuICB9XG5cbiAgLy8gSW5oZXJpdCBmcm9tXG4sIGluaGVyaXQ6IFNWRy5FbGVtZW50XG5cbn0pXG5cblNWRy5CYXJlID0gU1ZHLmludmVudCh7XG4gIC8vIEluaXRpYWxpemVcbiAgY3JlYXRlOiBmdW5jdGlvbihlbGVtZW50LCBpbmhlcml0KSB7XG4gICAgLy8gY29uc3RydWN0IGVsZW1lbnRcbiAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgU1ZHLmNyZWF0ZShlbGVtZW50KSlcblxuICAgIC8vIGluaGVyaXQgY3VzdG9tIG1ldGhvZHNcbiAgICBpZiAoaW5oZXJpdClcbiAgICAgIGZvciAodmFyIG1ldGhvZCBpbiBpbmhlcml0LnByb3RvdHlwZSlcbiAgICAgICAgaWYgKHR5cGVvZiBpbmhlcml0LnByb3RvdHlwZVttZXRob2RdID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIHRoaXNbbWV0aG9kXSA9IGluaGVyaXQucHJvdG90eXBlW21ldGhvZF1cbiAgfVxuXG4gIC8vIEluaGVyaXQgZnJvbVxuLCBpbmhlcml0OiBTVkcuRWxlbWVudFxuXG4gIC8vIEFkZCBtZXRob2RzXG4sIGV4dGVuZDoge1xuICAgIC8vIEluc2VydCBzb21lIHBsYWluIHRleHRcbiAgICB3b3JkczogZnVuY3Rpb24odGV4dCkge1xuICAgICAgLy8gcmVtb3ZlIGNvbnRlbnRzXG4gICAgICB3aGlsZSAodGhpcy5ub2RlLmhhc0NoaWxkTm9kZXMoKSlcbiAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUNoaWxkKHRoaXMubm9kZS5sYXN0Q2hpbGQpXG5cbiAgICAgIC8vIGNyZWF0ZSB0ZXh0IG5vZGVcbiAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSlcblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gIH1cbn0pXG5cblxuU1ZHLmV4dGVuZChTVkcuUGFyZW50LCB7XG4gIC8vIENyZWF0ZSBhbiBlbGVtZW50IHRoYXQgaXMgbm90IGRlc2NyaWJlZCBieSBTVkcuanNcbiAgZWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCwgaW5oZXJpdCkge1xuICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLkJhcmUoZWxlbWVudCwgaW5oZXJpdCkpXG4gIH1cbiAgLy8gQWRkIHN5bWJvbCBlbGVtZW50XG4sIHN5bWJvbDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmcygpLmVsZW1lbnQoJ3N5bWJvbCcsIFNWRy5Db250YWluZXIpXG4gIH1cblxufSlcblNWRy5Vc2UgPSBTVkcuaW52ZW50KHtcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gIGNyZWF0ZTogJ3VzZSdcblxuICAvLyBJbmhlcml0IGZyb21cbiwgaW5oZXJpdDogU1ZHLlNoYXBlXG5cbiAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiwgZXh0ZW5kOiB7XG4gICAgLy8gVXNlIGVsZW1lbnQgYXMgYSByZWZlcmVuY2VcbiAgICBlbGVtZW50OiBmdW5jdGlvbihlbGVtZW50LCBmaWxlKSB7XG4gICAgICAvLyBTZXQgbGluZWQgZWxlbWVudFxuICAgICAgcmV0dXJuIHRoaXMuYXR0cignaHJlZicsIChmaWxlIHx8ICcnKSArICcjJyArIGVsZW1lbnQsIFNWRy54bGluaylcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuLCBjb25zdHJ1Y3Q6IHtcbiAgICAvLyBDcmVhdGUgYSB1c2UgZWxlbWVudFxuICAgIHVzZTogZnVuY3Rpb24oZWxlbWVudCwgZmlsZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuVXNlKS5lbGVtZW50KGVsZW1lbnQsIGZpbGUpXG4gICAgfVxuICB9XG59KVxuU1ZHLlJlY3QgPSBTVkcuaW52ZW50KHtcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gIGNyZWF0ZTogJ3JlY3QnXG5cbiAgLy8gSW5oZXJpdCBmcm9tXG4sIGluaGVyaXQ6IFNWRy5TaGFwZVxuXG4gIC8vIEFkZCBwYXJlbnQgbWV0aG9kXG4sIGNvbnN0cnVjdDoge1xuICAgIC8vIENyZWF0ZSBhIHJlY3QgZWxlbWVudFxuICAgIHJlY3Q6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlJlY3QoKSkuc2l6ZSh3aWR0aCwgaGVpZ2h0KVxuICAgIH1cbiAgfVxufSlcblNWRy5DaXJjbGUgPSBTVkcuaW52ZW50KHtcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gIGNyZWF0ZTogJ2NpcmNsZSdcblxuICAvLyBJbmhlcml0IGZyb21cbiwgaW5oZXJpdDogU1ZHLlNoYXBlXG5cbiAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiwgY29uc3RydWN0OiB7XG4gICAgLy8gQ3JlYXRlIGNpcmNsZSBlbGVtZW50LCBiYXNlZCBvbiBlbGxpcHNlXG4gICAgY2lyY2xlOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5DaXJjbGUpLnJ4KG5ldyBTVkcuTnVtYmVyKHNpemUpLmRpdmlkZSgyKSkubW92ZSgwLCAwKVxuICAgIH1cbiAgfVxufSlcblxuU1ZHLmV4dGVuZChTVkcuQ2lyY2xlLCBTVkcuRlgsIHtcbiAgLy8gUmFkaXVzIHggdmFsdWVcbiAgcng6IGZ1bmN0aW9uKHJ4KSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cigncicsIHJ4KVxuICB9XG4gIC8vIEFsaWFzIHJhZGl1cyB4IHZhbHVlXG4sIHJ5OiBmdW5jdGlvbihyeSkge1xuICAgIHJldHVybiB0aGlzLnJ4KHJ5KVxuICB9XG59KVxuXG5TVkcuRWxsaXBzZSA9IFNWRy5pbnZlbnQoe1xuICAvLyBJbml0aWFsaXplIG5vZGVcbiAgY3JlYXRlOiAnZWxsaXBzZSdcblxuICAvLyBJbmhlcml0IGZyb21cbiwgaW5oZXJpdDogU1ZHLlNoYXBlXG5cbiAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiwgY29uc3RydWN0OiB7XG4gICAgLy8gQ3JlYXRlIGFuIGVsbGlwc2VcbiAgICBlbGxpcHNlOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5FbGxpcHNlKS5zaXplKHdpZHRoLCBoZWlnaHQpLm1vdmUoMCwgMClcbiAgICB9XG4gIH1cbn0pXG5cblNWRy5leHRlbmQoU1ZHLkVsbGlwc2UsIFNWRy5SZWN0LCBTVkcuRlgsIHtcbiAgLy8gUmFkaXVzIHggdmFsdWVcbiAgcng6IGZ1bmN0aW9uKHJ4KSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cigncngnLCByeClcbiAgfVxuICAvLyBSYWRpdXMgeSB2YWx1ZVxuLCByeTogZnVuY3Rpb24ocnkpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdyeScsIHJ5KVxuICB9XG59KVxuXG4vLyBBZGQgY29tbW9uIG1ldGhvZFxuU1ZHLmV4dGVuZChTVkcuQ2lyY2xlLCBTVkcuRWxsaXBzZSwge1xuICAgIC8vIE1vdmUgb3ZlciB4LWF4aXNcbiAgICB4OiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4geCA9PSBudWxsID8gdGhpcy5jeCgpIC0gdGhpcy5yeCgpIDogdGhpcy5jeCh4ICsgdGhpcy5yeCgpKVxuICAgIH1cbiAgICAvLyBNb3ZlIG92ZXIgeS1heGlzXG4gICwgeTogZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIHkgPT0gbnVsbCA/IHRoaXMuY3koKSAtIHRoaXMucnkoKSA6IHRoaXMuY3koeSArIHRoaXMucnkoKSlcbiAgICB9XG4gICAgLy8gTW92ZSBieSBjZW50ZXIgb3ZlciB4LWF4aXNcbiAgLCBjeDogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHggPT0gbnVsbCA/IHRoaXMuYXR0cignY3gnKSA6IHRoaXMuYXR0cignY3gnLCB4KVxuICAgIH1cbiAgICAvLyBNb3ZlIGJ5IGNlbnRlciBvdmVyIHktYXhpc1xuICAsIGN5OiBmdW5jdGlvbih5KSB7XG4gICAgICByZXR1cm4geSA9PSBudWxsID8gdGhpcy5hdHRyKCdjeScpIDogdGhpcy5hdHRyKCdjeScsIHkpXG4gICAgfVxuICAgIC8vIFNldCB3aWR0aCBvZiBlbGVtZW50XG4gICwgd2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICByZXR1cm4gd2lkdGggPT0gbnVsbCA/IHRoaXMucngoKSAqIDIgOiB0aGlzLnJ4KG5ldyBTVkcuTnVtYmVyKHdpZHRoKS5kaXZpZGUoMikpXG4gICAgfVxuICAgIC8vIFNldCBoZWlnaHQgb2YgZWxlbWVudFxuICAsIGhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICByZXR1cm4gaGVpZ2h0ID09IG51bGwgPyB0aGlzLnJ5KCkgKiAyIDogdGhpcy5yeShuZXcgU1ZHLk51bWJlcihoZWlnaHQpLmRpdmlkZSgyKSlcbiAgICB9XG4gICAgLy8gQ3VzdG9tIHNpemUgZnVuY3Rpb25cbiAgLCBzaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodClcblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgLnJ4KG5ldyBTVkcuTnVtYmVyKHAud2lkdGgpLmRpdmlkZSgyKSlcbiAgICAgICAgLnJ5KG5ldyBTVkcuTnVtYmVyKHAuaGVpZ2h0KS5kaXZpZGUoMikpXG4gICAgfVxufSlcblNWRy5MaW5lID0gU1ZHLmludmVudCh7XG4gIC8vIEluaXRpYWxpemUgbm9kZVxuICBjcmVhdGU6ICdsaW5lJ1xuXG4gIC8vIEluaGVyaXQgZnJvbVxuLCBpbmhlcml0OiBTVkcuU2hhcGVcblxuICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuLCBleHRlbmQ6IHtcbiAgICAvLyBHZXQgYXJyYXlcbiAgICBhcnJheTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IFNWRy5Qb2ludEFycmF5KFtcbiAgICAgICAgWyB0aGlzLmF0dHIoJ3gxJyksIHRoaXMuYXR0cigneTEnKSBdXG4gICAgICAsIFsgdGhpcy5hdHRyKCd4MicpLCB0aGlzLmF0dHIoJ3kyJykgXVxuICAgICAgXSlcbiAgICB9XG4gICAgLy8gT3ZlcndyaXRlIG5hdGl2ZSBwbG90KCkgbWV0aG9kXG4gICwgcGxvdDogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgIGlmICh0eXBlb2YgeTEgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICB4MSA9IHsgeDE6IHgxLCB5MTogeTEsIHgyOiB4MiwgeTI6IHkyIH1cbiAgICAgIGVsc2VcbiAgICAgICAgeDEgPSBuZXcgU1ZHLlBvaW50QXJyYXkoeDEpLnRvTGluZSgpXG5cbiAgICAgIHJldHVybiB0aGlzLmF0dHIoeDEpXG4gICAgfVxuICAgIC8vIE1vdmUgYnkgbGVmdCB0b3AgY29ybmVyXG4gICwgbW92ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cih0aGlzLmFycmF5KCkubW92ZSh4LCB5KS50b0xpbmUoKSlcbiAgICB9XG4gICAgLy8gU2V0IGVsZW1lbnQgc2l6ZSB0byBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0XG4gICwgc2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgdmFyIHAgPSBwcm9wb3J0aW9uYWxTaXplKHRoaXMsIHdpZHRoLCBoZWlnaHQpXG5cbiAgICAgIHJldHVybiB0aGlzLmF0dHIodGhpcy5hcnJheSgpLnNpemUocC53aWR0aCwgcC5oZWlnaHQpLnRvTGluZSgpKVxuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBwYXJlbnQgbWV0aG9kXG4sIGNvbnN0cnVjdDoge1xuICAgIC8vIENyZWF0ZSBhIGxpbmUgZWxlbWVudFxuICAgIGxpbmU6IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5MaW5lKS5wbG90KHgxLCB5MSwgeDIsIHkyKVxuICAgIH1cbiAgfVxufSlcblxuU1ZHLlBvbHlsaW5lID0gU1ZHLmludmVudCh7XG4gIC8vIEluaXRpYWxpemUgbm9kZVxuICBjcmVhdGU6ICdwb2x5bGluZSdcblxuICAvLyBJbmhlcml0IGZyb21cbiwgaW5oZXJpdDogU1ZHLlNoYXBlXG5cbiAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiwgY29uc3RydWN0OiB7XG4gICAgLy8gQ3JlYXRlIGEgd3JhcHBlZCBwb2x5bGluZSBlbGVtZW50XG4gICAgcG9seWxpbmU6IGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlBvbHlsaW5lKS5wbG90KHApXG4gICAgfVxuICB9XG59KVxuXG5TVkcuUG9seWdvbiA9IFNWRy5pbnZlbnQoe1xuICAvLyBJbml0aWFsaXplIG5vZGVcbiAgY3JlYXRlOiAncG9seWdvbidcblxuICAvLyBJbmhlcml0IGZyb21cbiwgaW5oZXJpdDogU1ZHLlNoYXBlXG5cbiAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiwgY29uc3RydWN0OiB7XG4gICAgLy8gQ3JlYXRlIGEgd3JhcHBlZCBwb2x5Z29uIGVsZW1lbnRcbiAgICBwb2x5Z29uOiBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5Qb2x5Z29uKS5wbG90KHApXG4gICAgfVxuICB9XG59KVxuXG4vLyBBZGQgcG9seWdvbi1zcGVjaWZpYyBmdW5jdGlvbnNcblNWRy5leHRlbmQoU1ZHLlBvbHlsaW5lLCBTVkcuUG9seWdvbiwge1xuICAvLyBHZXQgYXJyYXlcbiAgYXJyYXk6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJheSB8fCAodGhpcy5fYXJyYXkgPSBuZXcgU1ZHLlBvaW50QXJyYXkodGhpcy5hdHRyKCdwb2ludHMnKSkpXG4gIH1cbiAgLy8gUGxvdCBuZXcgcGF0aFxuLCBwbG90OiBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cigncG9pbnRzJywgKHRoaXMuX2FycmF5ID0gbmV3IFNWRy5Qb2ludEFycmF5KHApKSlcbiAgfVxuICAvLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lclxuLCBtb3ZlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cigncG9pbnRzJywgdGhpcy5hcnJheSgpLm1vdmUoeCwgeSkpXG4gIH1cbiAgLy8gU2V0IGVsZW1lbnQgc2l6ZSB0byBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0XG4sIHNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodClcblxuICAgIHJldHVybiB0aGlzLmF0dHIoJ3BvaW50cycsIHRoaXMuYXJyYXkoKS5zaXplKHAud2lkdGgsIHAuaGVpZ2h0KSlcbiAgfVxuXG59KVxuLy8gdW5pZnkgYWxsIHBvaW50IHRvIHBvaW50IGVsZW1lbnRzXG5TVkcuZXh0ZW5kKFNWRy5MaW5lLCBTVkcuUG9seWxpbmUsIFNWRy5Qb2x5Z29uLCB7XG4gIC8vIERlZmluZSBtb3JwaGFibGUgYXJyYXlcbiAgbW9ycGhBcnJheTogIFNWRy5Qb2ludEFycmF5XG4gIC8vIE1vdmUgYnkgbGVmdCB0b3AgY29ybmVyIG92ZXIgeC1heGlzXG4sIHg6IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geCA9PSBudWxsID8gdGhpcy5iYm94KCkueCA6IHRoaXMubW92ZSh4LCB0aGlzLmJib3goKS55KVxuICB9XG4gIC8vIE1vdmUgYnkgbGVmdCB0b3AgY29ybmVyIG92ZXIgeS1heGlzXG4sIHk6IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4geSA9PSBudWxsID8gdGhpcy5iYm94KCkueSA6IHRoaXMubW92ZSh0aGlzLmJib3goKS54LCB5KVxuICB9XG4gIC8vIFNldCB3aWR0aCBvZiBlbGVtZW50XG4sIHdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xuICAgIHZhciBiID0gdGhpcy5iYm94KClcblxuICAgIHJldHVybiB3aWR0aCA9PSBudWxsID8gYi53aWR0aCA6IHRoaXMuc2l6ZSh3aWR0aCwgYi5oZWlnaHQpXG4gIH1cbiAgLy8gU2V0IGhlaWdodCBvZiBlbGVtZW50XG4sIGhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgdmFyIGIgPSB0aGlzLmJib3goKVxuXG4gICAgcmV0dXJuIGhlaWdodCA9PSBudWxsID8gYi5oZWlnaHQgOiB0aGlzLnNpemUoYi53aWR0aCwgaGVpZ2h0KVxuICB9XG59KVxuU1ZHLlBhdGggPSBTVkcuaW52ZW50KHtcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gIGNyZWF0ZTogJ3BhdGgnXG5cbiAgLy8gSW5oZXJpdCBmcm9tXG4sIGluaGVyaXQ6IFNWRy5TaGFwZVxuXG4gIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4sIGV4dGVuZDoge1xuICAgIC8vIERlZmluZSBtb3JwaGFibGUgYXJyYXlcbiAgICBtb3JwaEFycmF5OiAgU1ZHLlBhdGhBcnJheVxuICAgIC8vIEdldCBhcnJheVxuICAsIGFycmF5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcnJheSB8fCAodGhpcy5fYXJyYXkgPSBuZXcgU1ZHLlBhdGhBcnJheSh0aGlzLmF0dHIoJ2QnKSkpXG4gICAgfVxuICAgIC8vIFBsb3QgbmV3IHBvbHkgcG9pbnRzXG4gICwgcGxvdDogZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cignZCcsICh0aGlzLl9hcnJheSA9IG5ldyBTVkcuUGF0aEFycmF5KHApKSlcbiAgICB9XG4gICAgLy8gTW92ZSBieSBsZWZ0IHRvcCBjb3JuZXJcbiAgLCBtb3ZlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdkJywgdGhpcy5hcnJheSgpLm1vdmUoeCwgeSkpXG4gICAgfVxuICAgIC8vIE1vdmUgYnkgbGVmdCB0b3AgY29ybmVyIG92ZXIgeC1heGlzXG4gICwgeDogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHggPT0gbnVsbCA/IHRoaXMuYmJveCgpLnggOiB0aGlzLm1vdmUoeCwgdGhpcy5iYm94KCkueSlcbiAgICB9XG4gICAgLy8gTW92ZSBieSBsZWZ0IHRvcCBjb3JuZXIgb3ZlciB5LWF4aXNcbiAgLCB5OiBmdW5jdGlvbih5KSB7XG4gICAgICByZXR1cm4geSA9PSBudWxsID8gdGhpcy5iYm94KCkueSA6IHRoaXMubW92ZSh0aGlzLmJib3goKS54LCB5KVxuICAgIH1cbiAgICAvLyBTZXQgZWxlbWVudCBzaXplIHRvIGdpdmVuIHdpZHRoIGFuZCBoZWlnaHRcbiAgLCBzaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodClcblxuICAgICAgcmV0dXJuIHRoaXMuYXR0cignZCcsIHRoaXMuYXJyYXkoKS5zaXplKHAud2lkdGgsIHAuaGVpZ2h0KSlcbiAgICB9XG4gICAgLy8gU2V0IHdpZHRoIG9mIGVsZW1lbnRcbiAgLCB3aWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgIHJldHVybiB3aWR0aCA9PSBudWxsID8gdGhpcy5iYm94KCkud2lkdGggOiB0aGlzLnNpemUod2lkdGgsIHRoaXMuYmJveCgpLmhlaWdodClcbiAgICB9XG4gICAgLy8gU2V0IGhlaWdodCBvZiBlbGVtZW50XG4gICwgaGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcbiAgICAgIHJldHVybiBoZWlnaHQgPT0gbnVsbCA/IHRoaXMuYmJveCgpLmhlaWdodCA6IHRoaXMuc2l6ZSh0aGlzLmJib3goKS53aWR0aCwgaGVpZ2h0KVxuICAgIH1cblxuICB9XG5cbiAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiwgY29uc3RydWN0OiB7XG4gICAgLy8gQ3JlYXRlIGEgd3JhcHBlZCBwYXRoIGVsZW1lbnRcbiAgICBwYXRoOiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5QYXRoKS5wbG90KGQpXG4gICAgfVxuICB9XG59KVxuU1ZHLkltYWdlID0gU1ZHLmludmVudCh7XG4gIC8vIEluaXRpYWxpemUgbm9kZVxuICBjcmVhdGU6ICdpbWFnZSdcblxuICAvLyBJbmhlcml0IGZyb21cbiwgaW5oZXJpdDogU1ZHLlNoYXBlXG5cbiAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiwgZXh0ZW5kOiB7XG4gICAgLy8gKHJlKWxvYWQgaW1hZ2VcbiAgICBsb2FkOiBmdW5jdGlvbih1cmwpIHtcbiAgICAgIGlmICghdXJsKSByZXR1cm4gdGhpc1xuXG4gICAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICAgICAgLCBpbWcgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJylcblxuICAgICAgLy8gcHJlbG9hZCBpbWFnZVxuICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcCA9IHNlbGYucGFyZW50KFNWRy5QYXR0ZXJuKVxuXG4gICAgICAgIGlmKHAgPT09IG51bGwpIHJldHVyblxuXG4gICAgICAgIC8vIGVuc3VyZSBpbWFnZSBzaXplXG4gICAgICAgIGlmIChzZWxmLndpZHRoKCkgPT0gMCAmJiBzZWxmLmhlaWdodCgpID09IDApXG4gICAgICAgICAgc2VsZi5zaXplKGltZy53aWR0aCwgaW1nLmhlaWdodClcblxuICAgICAgICAvLyBlbnN1cmUgcGF0dGVybiBzaXplIGlmIG5vdCBzZXRcbiAgICAgICAgaWYgKHAgJiYgcC53aWR0aCgpID09IDAgJiYgcC5oZWlnaHQoKSA9PSAwKVxuICAgICAgICAgIHAuc2l6ZShzZWxmLndpZHRoKCksIHNlbGYuaGVpZ2h0KCkpXG5cbiAgICAgICAgLy8gY2FsbGJhY2tcbiAgICAgICAgaWYgKHR5cGVvZiBzZWxmLl9sb2FkZWQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgc2VsZi5fbG9hZGVkLmNhbGwoc2VsZiwge1xuICAgICAgICAgICAgd2lkdGg6ICBpbWcud2lkdGhcbiAgICAgICAgICAsIGhlaWdodDogaW1nLmhlaWdodFxuICAgICAgICAgICwgcmF0aW86ICBpbWcud2lkdGggLyBpbWcuaGVpZ2h0XG4gICAgICAgICAgLCB1cmw6ICAgIHVybFxuICAgICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGltZy5vbmVycm9yID0gZnVuY3Rpb24oZSl7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZi5fZXJyb3IgPT09ICdmdW5jdGlvbicpe1xuICAgICAgICAgICAgc2VsZi5fZXJyb3IuY2FsbChzZWxmLCBlKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2hyZWYnLCAoaW1nLnNyYyA9IHRoaXMuc3JjID0gdXJsKSwgU1ZHLnhsaW5rKVxuICAgIH1cbiAgICAvLyBBZGQgbG9hZGVkIGNhbGxiYWNrXG4gICwgbG9hZGVkOiBmdW5jdGlvbihsb2FkZWQpIHtcbiAgICAgIHRoaXMuX2xvYWRlZCA9IGxvYWRlZFxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgLCBlcnJvcjogZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgIHRoaXMuX2Vycm9yID0gZXJyb3JcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiwgY29uc3RydWN0OiB7XG4gICAgLy8gY3JlYXRlIGltYWdlIGVsZW1lbnQsIGxvYWQgaW1hZ2UgYW5kIHNldCBpdHMgc2l6ZVxuICAgIGltYWdlOiBmdW5jdGlvbihzb3VyY2UsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLkltYWdlKS5sb2FkKHNvdXJjZSkuc2l6ZSh3aWR0aCB8fCAwLCBoZWlnaHQgfHwgd2lkdGggfHwgMClcbiAgICB9XG4gIH1cblxufSlcblNWRy5UZXh0ID0gU1ZHLmludmVudCh7XG4gIC8vIEluaXRpYWxpemUgbm9kZVxuICBjcmVhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBTVkcuY3JlYXRlKCd0ZXh0JykpXG5cbiAgICB0aGlzLmRvbS5sZWFkaW5nID0gbmV3IFNWRy5OdW1iZXIoMS4zKSAgICAvLyBzdG9yZSBsZWFkaW5nIHZhbHVlIGZvciByZWJ1aWxkaW5nXG4gICAgdGhpcy5fcmVidWlsZCA9IHRydWUgICAgICAgICAgICAgICAgICAgICAgLy8gZW5hYmxlIGF1dG9tYXRpYyB1cGRhdGluZyBvZiBkeSB2YWx1ZXNcbiAgICB0aGlzLl9idWlsZCAgID0gZmFsc2UgICAgICAgICAgICAgICAgICAgICAvLyBkaXNhYmxlIGJ1aWxkIG1vZGUgZm9yIGFkZGluZyBtdWx0aXBsZSBsaW5lc1xuXG4gICAgLy8gc2V0IGRlZmF1bHQgZm9udFxuICAgIHRoaXMuYXR0cignZm9udC1mYW1pbHknLCBTVkcuZGVmYXVsdHMuYXR0cnNbJ2ZvbnQtZmFtaWx5J10pXG4gIH1cblxuICAvLyBJbmhlcml0IGZyb21cbiwgaW5oZXJpdDogU1ZHLlNoYXBlXG5cbiAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiwgZXh0ZW5kOiB7XG4gICAgLy8gTW92ZSBvdmVyIHgtYXhpc1xuICAgIHg6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIC8vIGFjdCBhcyBnZXR0ZXJcbiAgICAgIGlmICh4ID09IG51bGwpXG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3gnKVxuXG4gICAgICAvLyBtb3ZlIGxpbmVzIGFzIHdlbGwgaWYgbm8gdGV4dFBhdGggaXMgcHJlc2VudFxuICAgICAgaWYgKCF0aGlzLnRleHRQYXRoKVxuICAgICAgICB0aGlzLmxpbmVzKCkuZWFjaChmdW5jdGlvbigpIHsgaWYgKHRoaXMuZG9tLm5ld0xpbmVkKSB0aGlzLngoeCkgfSlcblxuICAgICAgcmV0dXJuIHRoaXMuYXR0cigneCcsIHgpXG4gICAgfVxuICAgIC8vIE1vdmUgb3ZlciB5LWF4aXNcbiAgLCB5OiBmdW5jdGlvbih5KSB7XG4gICAgICB2YXIgb3kgPSB0aGlzLmF0dHIoJ3knKVxuICAgICAgICAsIG8gID0gdHlwZW9mIG95ID09PSAnbnVtYmVyJyA/IG95IC0gdGhpcy5iYm94KCkueSA6IDBcblxuICAgICAgLy8gYWN0IGFzIGdldHRlclxuICAgICAgaWYgKHkgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBveSA9PT0gJ251bWJlcicgPyBveSAtIG8gOiBveVxuXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCd5JywgdHlwZW9mIHkgPT09ICdudW1iZXInID8geSArIG8gOiB5KVxuICAgIH1cbiAgICAvLyBNb3ZlIGNlbnRlciBvdmVyIHgtYXhpc1xuICAsIGN4OiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4geCA9PSBudWxsID8gdGhpcy5iYm94KCkuY3ggOiB0aGlzLngoeCAtIHRoaXMuYmJveCgpLndpZHRoIC8gMilcbiAgICB9XG4gICAgLy8gTW92ZSBjZW50ZXIgb3ZlciB5LWF4aXNcbiAgLCBjeTogZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIHkgPT0gbnVsbCA/IHRoaXMuYmJveCgpLmN5IDogdGhpcy55KHkgLSB0aGlzLmJib3goKS5oZWlnaHQgLyAyKVxuICAgIH1cbiAgICAvLyBTZXQgdGhlIHRleHQgY29udGVudFxuICAsIHRleHQ6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgIC8vIGFjdCBhcyBnZXR0ZXJcbiAgICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ3VuZGVmaW5lZCcpe1xuICAgICAgICB2YXIgdGV4dCA9ICcnXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMubm9kZS5jaGlsZE5vZGVzXG4gICAgICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgKytpKXtcblxuICAgICAgICAgIC8vIGFkZCBuZXdsaW5lIGlmIGl0cyBub3QgdGhlIGZpcnN0IGNoaWxkIGFuZCBuZXdMaW5lZCBpcyBzZXQgdG8gdHJ1ZVxuICAgICAgICAgIGlmKGkgIT0gMCAmJiBjaGlsZHJlbltpXS5ub2RlVHlwZSAhPSAzICYmIFNWRy5hZG9wdChjaGlsZHJlbltpXSkuZG9tLm5ld0xpbmVkID09IHRydWUpe1xuICAgICAgICAgICAgdGV4dCArPSAnXFxuJ1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGFkZCBjb250ZW50IG9mIHRoaXMgbm9kZVxuICAgICAgICAgIHRleHQgKz0gY2hpbGRyZW5baV0udGV4dENvbnRlbnRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXh0XG4gICAgICB9XG5cbiAgICAgIC8vIHJlbW92ZSBleGlzdGluZyBjb250ZW50XG4gICAgICB0aGlzLmNsZWFyKCkuYnVpbGQodHJ1ZSlcblxuICAgICAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIGNhbGwgYmxvY2tcbiAgICAgICAgdGV4dC5jYWxsKHRoaXMsIHRoaXMpXG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHN0b3JlIHRleHQgYW5kIG1ha2Ugc3VyZSB0ZXh0IGlzIG5vdCBibGFua1xuICAgICAgICB0ZXh0ID0gdGV4dC5zcGxpdCgnXFxuJylcblxuICAgICAgICAvLyBidWlsZCBuZXcgbGluZXNcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gdGV4dC5sZW5ndGg7IGkgPCBpbDsgaSsrKVxuICAgICAgICAgIHRoaXMudHNwYW4odGV4dFtpXSkubmV3TGluZSgpXG4gICAgICB9XG5cbiAgICAgIC8vIGRpc2FibGUgYnVpbGQgbW9kZSBhbmQgcmVidWlsZCBsaW5lc1xuICAgICAgcmV0dXJuIHRoaXMuYnVpbGQoZmFsc2UpLnJlYnVpbGQoKVxuICAgIH1cbiAgICAvLyBTZXQgZm9udCBzaXplXG4gICwgc2l6ZTogZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cignZm9udC1zaXplJywgc2l6ZSkucmVidWlsZCgpXG4gICAgfVxuICAgIC8vIFNldCAvIGdldCBsZWFkaW5nXG4gICwgbGVhZGluZzogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIC8vIGFjdCBhcyBnZXR0ZXJcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICByZXR1cm4gdGhpcy5kb20ubGVhZGluZ1xuXG4gICAgICAvLyBhY3QgYXMgc2V0dGVyXG4gICAgICB0aGlzLmRvbS5sZWFkaW5nID0gbmV3IFNWRy5OdW1iZXIodmFsdWUpXG5cbiAgICAgIHJldHVybiB0aGlzLnJlYnVpbGQoKVxuICAgIH1cbiAgICAvLyBHZXQgYWxsIHRoZSBmaXJzdCBsZXZlbCBsaW5lc1xuICAsIGxpbmVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub2RlID0gKHRoaXMudGV4dFBhdGggJiYgdGhpcy50ZXh0UGF0aCgpIHx8IHRoaXMpLm5vZGVcblxuICAgICAgLy8gZmlsdGVyIHRzcGFucyBhbmQgbWFwIHRoZW0gdG8gU1ZHLmpzIGluc3RhbmNlc1xuICAgICAgdmFyIGxpbmVzID0gU1ZHLnV0aWxzLm1hcChTVkcudXRpbHMuZmlsdGVyU1ZHRWxlbWVudHMobm9kZS5jaGlsZE5vZGVzKSwgZnVuY3Rpb24oZWwpe1xuICAgICAgICByZXR1cm4gU1ZHLmFkb3B0KGVsKVxuICAgICAgfSlcblxuICAgICAgLy8gcmV0dXJuIGFuIGluc3RhbmNlIG9mIFNWRy5zZXRcbiAgICAgIHJldHVybiBuZXcgU1ZHLlNldChsaW5lcylcbiAgICB9XG4gICAgLy8gUmVidWlsZCBhcHBlYXJhbmNlIHR5cGVcbiAgLCByZWJ1aWxkOiBmdW5jdGlvbihyZWJ1aWxkKSB7XG4gICAgICAvLyBzdG9yZSBuZXcgcmVidWlsZCBmbGFnIGlmIGdpdmVuXG4gICAgICBpZiAodHlwZW9mIHJlYnVpbGQgPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aGlzLl9yZWJ1aWxkID0gcmVidWlsZFxuXG4gICAgICAvLyBkZWZpbmUgcG9zaXRpb24gb2YgYWxsIGxpbmVzXG4gICAgICBpZiAodGhpcy5fcmVidWlsZCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICAgICAgICAsIGJsYW5rTGluZU9mZnNldCA9IDBcbiAgICAgICAgICAsIGR5ID0gdGhpcy5kb20ubGVhZGluZyAqIG5ldyBTVkcuTnVtYmVyKHRoaXMuYXR0cignZm9udC1zaXplJykpXG5cbiAgICAgICAgdGhpcy5saW5lcygpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZG9tLm5ld0xpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudGV4dFBhdGgpXG4gICAgICAgICAgICAgIHRoaXMuYXR0cigneCcsIHNlbGYuYXR0cigneCcpKVxuXG4gICAgICAgICAgICBpZih0aGlzLnRleHQoKSA9PSAnXFxuJykge1xuICAgICAgICAgICAgICBibGFua0xpbmVPZmZzZXQgKz0gZHlcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICB0aGlzLmF0dHIoJ2R5JywgZHkgKyBibGFua0xpbmVPZmZzZXQpXG4gICAgICAgICAgICAgIGJsYW5rTGluZU9mZnNldCA9IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgdGhpcy5maXJlKCdyZWJ1aWxkJylcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgLy8gRW5hYmxlIC8gZGlzYWJsZSBidWlsZCBtb2RlXG4gICwgYnVpbGQ6IGZ1bmN0aW9uKGJ1aWxkKSB7XG4gICAgICB0aGlzLl9idWlsZCA9ICEhYnVpbGRcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIC8vIG92ZXJ3cml0ZSBtZXRob2QgZnJvbSBwYXJlbnQgdG8gc2V0IGRhdGEgcHJvcGVybHlcbiAgLCBzZXREYXRhOiBmdW5jdGlvbihvKXtcbiAgICAgIHRoaXMuZG9tID0gb1xuICAgICAgdGhpcy5kb20ubGVhZGluZyA9IG5ldyBTVkcuTnVtYmVyKG8ubGVhZGluZyB8fCAxLjMpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBwYXJlbnQgbWV0aG9kXG4sIGNvbnN0cnVjdDoge1xuICAgIC8vIENyZWF0ZSB0ZXh0IGVsZW1lbnRcbiAgICB0ZXh0OiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5UZXh0KS50ZXh0KHRleHQpXG4gICAgfVxuICAgIC8vIENyZWF0ZSBwbGFpbiB0ZXh0IGVsZW1lbnRcbiAgLCBwbGFpbjogZnVuY3Rpb24odGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuVGV4dCkucGxhaW4odGV4dClcbiAgICB9XG4gIH1cblxufSlcblxuU1ZHLlRzcGFuID0gU1ZHLmludmVudCh7XG4gIC8vIEluaXRpYWxpemUgbm9kZVxuICBjcmVhdGU6ICd0c3BhbidcblxuICAvLyBJbmhlcml0IGZyb21cbiwgaW5oZXJpdDogU1ZHLlNoYXBlXG5cbiAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiwgZXh0ZW5kOiB7XG4gICAgLy8gU2V0IHRleHQgY29udGVudFxuICAgIHRleHQ6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgIGlmKHRleHQgPT0gbnVsbCkgcmV0dXJuIHRoaXMubm9kZS50ZXh0Q29udGVudCArICh0aGlzLmRvbS5uZXdMaW5lZCA/ICdcXG4nIDogJycpXG5cbiAgICAgIHR5cGVvZiB0ZXh0ID09PSAnZnVuY3Rpb24nID8gdGV4dC5jYWxsKHRoaXMsIHRoaXMpIDogdGhpcy5wbGFpbih0ZXh0KVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICAvLyBTaG9ydGN1dCBkeFxuICAsIGR4OiBmdW5jdGlvbihkeCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cignZHgnLCBkeClcbiAgICB9XG4gICAgLy8gU2hvcnRjdXQgZHlcbiAgLCBkeTogZnVuY3Rpb24oZHkpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2R5JywgZHkpXG4gICAgfVxuICAgIC8vIENyZWF0ZSBuZXcgbGluZVxuICAsIG5ld0xpbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gZmV0Y2ggdGV4dCBwYXJlbnRcbiAgICAgIHZhciB0ID0gdGhpcy5wYXJlbnQoU1ZHLlRleHQpXG5cbiAgICAgIC8vIG1hcmsgbmV3IGxpbmVcbiAgICAgIHRoaXMuZG9tLm5ld0xpbmVkID0gdHJ1ZVxuXG4gICAgICAvLyBhcHBseSBuZXcgaHnCoW5cbiAgICAgIHJldHVybiB0aGlzLmR5KHQuZG9tLmxlYWRpbmcgKiB0LmF0dHIoJ2ZvbnQtc2l6ZScpKS5hdHRyKCd4JywgdC54KCkpXG4gICAgfVxuICB9XG5cbn0pXG5cblNWRy5leHRlbmQoU1ZHLlRleHQsIFNWRy5Uc3Bhbiwge1xuICAvLyBDcmVhdGUgcGxhaW4gdGV4dCBub2RlXG4gIHBsYWluOiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgLy8gY2xlYXIgaWYgYnVpbGQgbW9kZSBpcyBkaXNhYmxlZFxuICAgIGlmICh0aGlzLl9idWlsZCA9PT0gZmFsc2UpXG4gICAgICB0aGlzLmNsZWFyKClcblxuICAgIC8vIGNyZWF0ZSB0ZXh0IG5vZGVcbiAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCkpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG4gIC8vIENyZWF0ZSBhIHRzcGFuXG4sIHRzcGFuOiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG5vZGUgID0gKHRoaXMudGV4dFBhdGggJiYgdGhpcy50ZXh0UGF0aCgpIHx8IHRoaXMpLm5vZGVcbiAgICAgICwgdHNwYW4gPSBuZXcgU1ZHLlRzcGFuXG5cbiAgICAvLyBjbGVhciBpZiBidWlsZCBtb2RlIGlzIGRpc2FibGVkXG4gICAgaWYgKHRoaXMuX2J1aWxkID09PSBmYWxzZSlcbiAgICAgIHRoaXMuY2xlYXIoKVxuXG4gICAgLy8gYWRkIG5ldyB0c3BhblxuICAgIG5vZGUuYXBwZW5kQ2hpbGQodHNwYW4ubm9kZSlcblxuICAgIHJldHVybiB0c3Bhbi50ZXh0KHRleHQpXG4gIH1cbiAgLy8gQ2xlYXIgYWxsIGxpbmVzXG4sIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbm9kZSA9ICh0aGlzLnRleHRQYXRoICYmIHRoaXMudGV4dFBhdGgoKSB8fCB0aGlzKS5ub2RlXG5cbiAgICAvLyByZW1vdmUgZXhpc3RpbmcgY2hpbGQgbm9kZXNcbiAgICB3aGlsZSAobm9kZS5oYXNDaGlsZE5vZGVzKCkpXG4gICAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUubGFzdENoaWxkKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuICAvLyBHZXQgbGVuZ3RoIG9mIHRleHQgZWxlbWVudFxuLCBsZW5ndGg6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKClcbiAgfVxufSlcblxuU1ZHLlRleHRQYXRoID0gU1ZHLmludmVudCh7XG4gIC8vIEluaXRpYWxpemUgbm9kZVxuICBjcmVhdGU6ICd0ZXh0UGF0aCdcblxuICAvLyBJbmhlcml0IGZyb21cbiwgaW5oZXJpdDogU1ZHLlBhcmVudFxuXG4gIC8vIERlZmluZSBwYXJlbnQgY2xhc3NcbiwgcGFyZW50OiBTVkcuVGV4dFxuXG4gIC8vIEFkZCBwYXJlbnQgbWV0aG9kXG4sIGNvbnN0cnVjdDoge1xuICAgIC8vIENyZWF0ZSBwYXRoIGZvciB0ZXh0IHRvIHJ1biBvblxuICAgIHBhdGg6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIC8vIGNyZWF0ZSB0ZXh0UGF0aCBlbGVtZW50XG4gICAgICB2YXIgcGF0aCAgPSBuZXcgU1ZHLlRleHRQYXRoXG4gICAgICAgICwgdHJhY2sgPSB0aGlzLmRvYygpLmRlZnMoKS5wYXRoKGQpXG5cbiAgICAgIC8vIG1vdmUgbGluZXMgdG8gdGV4dHBhdGhcbiAgICAgIHdoaWxlICh0aGlzLm5vZGUuaGFzQ2hpbGROb2RlcygpKVxuICAgICAgICBwYXRoLm5vZGUuYXBwZW5kQ2hpbGQodGhpcy5ub2RlLmZpcnN0Q2hpbGQpXG5cbiAgICAgIC8vIGFkZCB0ZXh0UGF0aCBlbGVtZW50IGFzIGNoaWxkIG5vZGVcbiAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChwYXRoLm5vZGUpXG5cbiAgICAgIC8vIGxpbmsgdGV4dFBhdGggdG8gcGF0aCBhbmQgYWRkIGNvbnRlbnRcbiAgICAgIHBhdGguYXR0cignaHJlZicsICcjJyArIHRyYWNrLCBTVkcueGxpbmspXG5cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIC8vIFBsb3QgcGF0aCBpZiBhbnlcbiAgLCBwbG90OiBmdW5jdGlvbihkKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0aGlzLnRyYWNrKClcblxuICAgICAgaWYgKHRyYWNrKVxuICAgICAgICB0cmFjay5wbG90KGQpXG5cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIC8vIEdldCB0aGUgcGF0aCB0cmFjayBlbGVtZW50XG4gICwgdHJhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLnRleHRQYXRoKClcblxuICAgICAgaWYgKHBhdGgpXG4gICAgICAgIHJldHVybiBwYXRoLnJlZmVyZW5jZSgnaHJlZicpXG4gICAgfVxuICAgIC8vIEdldCB0aGUgdGV4dFBhdGggY2hpbGRcbiAgLCB0ZXh0UGF0aDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5ub2RlLmZpcnN0Q2hpbGQgJiYgdGhpcy5ub2RlLmZpcnN0Q2hpbGQubm9kZU5hbWUgPT0gJ3RleHRQYXRoJylcbiAgICAgICAgcmV0dXJuIFNWRy5hZG9wdCh0aGlzLm5vZGUuZmlyc3RDaGlsZClcbiAgICB9XG4gIH1cbn0pXG5TVkcuTmVzdGVkID0gU1ZHLmludmVudCh7XG4gIC8vIEluaXRpYWxpemUgbm9kZVxuICBjcmVhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBTVkcuY3JlYXRlKCdzdmcnKSlcblxuICAgIHRoaXMuc3R5bGUoJ292ZXJmbG93JywgJ3Zpc2libGUnKVxuICB9XG5cbiAgLy8gSW5oZXJpdCBmcm9tXG4sIGluaGVyaXQ6IFNWRy5Db250YWluZXJcblxuICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuLCBjb25zdHJ1Y3Q6IHtcbiAgICAvLyBDcmVhdGUgbmVzdGVkIHN2ZyBkb2N1bWVudFxuICAgIG5lc3RlZDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5OZXN0ZWQpXG4gICAgfVxuICB9XG59KVxuU1ZHLkEgPSBTVkcuaW52ZW50KHtcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gIGNyZWF0ZTogJ2EnXG5cbiAgLy8gSW5oZXJpdCBmcm9tXG4sIGluaGVyaXQ6IFNWRy5Db250YWluZXJcblxuICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuLCBleHRlbmQ6IHtcbiAgICAvLyBMaW5rIHVybFxuICAgIHRvOiBmdW5jdGlvbih1cmwpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2hyZWYnLCB1cmwsIFNWRy54bGluaylcbiAgICB9XG4gICAgLy8gTGluayBzaG93IGF0dHJpYnV0ZVxuICAsIHNob3c6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cignc2hvdycsIHRhcmdldCwgU1ZHLnhsaW5rKVxuICAgIH1cbiAgICAvLyBMaW5rIHRhcmdldCBhdHRyaWJ1dGVcbiAgLCB0YXJnZXQ6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cigndGFyZ2V0JywgdGFyZ2V0KVxuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBwYXJlbnQgbWV0aG9kXG4sIGNvbnN0cnVjdDoge1xuICAgIC8vIENyZWF0ZSBhIGh5cGVybGluayBlbGVtZW50XG4gICAgbGluazogZnVuY3Rpb24odXJsKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5BKS50byh1cmwpXG4gICAgfVxuICB9XG59KVxuXG5TVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XG4gIC8vIENyZWF0ZSBhIGh5cGVybGluayBlbGVtZW50XG4gIGxpbmtUbzogZnVuY3Rpb24odXJsKSB7XG4gICAgdmFyIGxpbmsgPSBuZXcgU1ZHLkFcblxuICAgIGlmICh0eXBlb2YgdXJsID09ICdmdW5jdGlvbicpXG4gICAgICB1cmwuY2FsbChsaW5rLCBsaW5rKVxuICAgIGVsc2VcbiAgICAgIGxpbmsudG8odXJsKVxuXG4gICAgcmV0dXJuIHRoaXMucGFyZW50KCkucHV0KGxpbmspLnB1dCh0aGlzKVxuICB9XG5cbn0pXG5TVkcuTWFya2VyID0gU1ZHLmludmVudCh7XG4gIC8vIEluaXRpYWxpemUgbm9kZVxuICBjcmVhdGU6ICdtYXJrZXInXG5cbiAgLy8gSW5oZXJpdCBmcm9tXG4sIGluaGVyaXQ6IFNWRy5Db250YWluZXJcblxuICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuLCBleHRlbmQ6IHtcbiAgICAvLyBTZXQgd2lkdGggb2YgZWxlbWVudFxuICAgIHdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cignbWFya2VyV2lkdGgnLCB3aWR0aClcbiAgICB9XG4gICAgLy8gU2V0IGhlaWdodCBvZiBlbGVtZW50XG4gICwgaGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ21hcmtlckhlaWdodCcsIGhlaWdodClcbiAgICB9XG4gICAgLy8gU2V0IG1hcmtlciByZWZYIGFuZCByZWZZXG4gICwgcmVmOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdyZWZYJywgeCkuYXR0cigncmVmWScsIHkpXG4gICAgfVxuICAgIC8vIFVwZGF0ZSBtYXJrZXJcbiAgLCB1cGRhdGU6IGZ1bmN0aW9uKGJsb2NrKSB7XG4gICAgICAvLyByZW1vdmUgYWxsIGNvbnRlbnRcbiAgICAgIHRoaXMuY2xlYXIoKVxuXG4gICAgICAvLyBpbnZva2UgcGFzc2VkIGJsb2NrXG4gICAgICBpZiAodHlwZW9mIGJsb2NrID09ICdmdW5jdGlvbicpXG4gICAgICAgIGJsb2NrLmNhbGwodGhpcywgdGhpcylcblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgLy8gUmV0dXJuIHRoZSBmaWxsIGlkXG4gICwgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICd1cmwoIycgKyB0aGlzLmlkKCkgKyAnKSdcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuLCBjb25zdHJ1Y3Q6IHtcbiAgICBtYXJrZXI6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIGJsb2NrKSB7XG4gICAgICAvLyBDcmVhdGUgbWFya2VyIGVsZW1lbnQgaW4gZGVmc1xuICAgICAgcmV0dXJuIHRoaXMuZGVmcygpLm1hcmtlcih3aWR0aCwgaGVpZ2h0LCBibG9jaylcbiAgICB9XG4gIH1cblxufSlcblxuU1ZHLmV4dGVuZChTVkcuRGVmcywge1xuICAvLyBDcmVhdGUgbWFya2VyXG4gIG1hcmtlcjogZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgYmxvY2spIHtcbiAgICAvLyBTZXQgZGVmYXVsdCB2aWV3Ym94IHRvIG1hdGNoIHRoZSB3aWR0aCBhbmQgaGVpZ2h0LCBzZXQgcmVmIHRvIGN4IGFuZCBjeSBhbmQgc2V0IG9yaWVudCB0byBhdXRvXG4gICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuTWFya2VyKVxuICAgICAgLnNpemUod2lkdGgsIGhlaWdodClcbiAgICAgIC5yZWYod2lkdGggLyAyLCBoZWlnaHQgLyAyKVxuICAgICAgLnZpZXdib3goMCwgMCwgd2lkdGgsIGhlaWdodClcbiAgICAgIC5hdHRyKCdvcmllbnQnLCAnYXV0bycpXG4gICAgICAudXBkYXRlKGJsb2NrKVxuICB9XG5cbn0pXG5cblNWRy5leHRlbmQoU1ZHLkxpbmUsIFNWRy5Qb2x5bGluZSwgU1ZHLlBvbHlnb24sIFNWRy5QYXRoLCB7XG4gIC8vIENyZWF0ZSBhbmQgYXR0YWNoIG1hcmtlcnNcbiAgbWFya2VyOiBmdW5jdGlvbihtYXJrZXIsIHdpZHRoLCBoZWlnaHQsIGJsb2NrKSB7XG4gICAgdmFyIGF0dHIgPSBbJ21hcmtlciddXG5cbiAgICAvLyBCdWlsZCBhdHRyaWJ1dGUgbmFtZVxuICAgIGlmIChtYXJrZXIgIT0gJ2FsbCcpIGF0dHIucHVzaChtYXJrZXIpXG4gICAgYXR0ciA9IGF0dHIuam9pbignLScpXG5cbiAgICAvLyBTZXQgbWFya2VyIGF0dHJpYnV0ZVxuICAgIG1hcmtlciA9IGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIFNWRy5NYXJrZXIgP1xuICAgICAgYXJndW1lbnRzWzFdIDpcbiAgICAgIHRoaXMuZG9jKCkubWFya2VyKHdpZHRoLCBoZWlnaHQsIGJsb2NrKVxuXG4gICAgcmV0dXJuIHRoaXMuYXR0cihhdHRyLCBtYXJrZXIpXG4gIH1cblxufSlcbi8vIERlZmluZSBsaXN0IG9mIGF2YWlsYWJsZSBhdHRyaWJ1dGVzIGZvciBzdHJva2UgYW5kIGZpbGxcbnZhciBzdWdhciA9IHtcbiAgc3Ryb2tlOiBbJ2NvbG9yJywgJ3dpZHRoJywgJ29wYWNpdHknLCAnbGluZWNhcCcsICdsaW5lam9pbicsICdtaXRlcmxpbWl0JywgJ2Rhc2hhcnJheScsICdkYXNob2Zmc2V0J11cbiwgZmlsbDogICBbJ2NvbG9yJywgJ29wYWNpdHknLCAncnVsZSddXG4sIHByZWZpeDogZnVuY3Rpb24odCwgYSkge1xuICAgIHJldHVybiBhID09ICdjb2xvcicgPyB0IDogdCArICctJyArIGFcbiAgfVxufVxuXG4vLyBBZGQgc3VnYXIgZm9yIGZpbGwgYW5kIHN0cm9rZVxuO1snZmlsbCcsICdzdHJva2UnXS5mb3JFYWNoKGZ1bmN0aW9uKG0pIHtcbiAgdmFyIGksIGV4dGVuc2lvbiA9IHt9XG5cbiAgZXh0ZW5zaW9uW21dID0gZnVuY3Rpb24obykge1xuICAgIGlmICh0eXBlb2YgbyA9PSAndW5kZWZpbmVkJylcbiAgICAgIHJldHVybiB0aGlzXG4gICAgaWYgKHR5cGVvZiBvID09ICdzdHJpbmcnIHx8IFNWRy5Db2xvci5pc1JnYihvKSB8fCAobyAmJiB0eXBlb2Ygby5maWxsID09PSAnZnVuY3Rpb24nKSlcbiAgICAgIHRoaXMuYXR0cihtLCBvKVxuXG4gICAgZWxzZVxuICAgICAgLy8gc2V0IGFsbCBhdHRyaWJ1dGVzIGZyb20gc3VnYXIuZmlsbCBhbmQgc3VnYXIuc3Ryb2tlIGxpc3RcbiAgICAgIGZvciAoaSA9IHN1Z2FyW21dLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAob1tzdWdhclttXVtpXV0gIT0gbnVsbClcbiAgICAgICAgICB0aGlzLmF0dHIoc3VnYXIucHJlZml4KG0sIHN1Z2FyW21dW2ldKSwgb1tzdWdhclttXVtpXV0pXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwgU1ZHLkZYLCBleHRlbnNpb24pXG5cbn0pXG5cblNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIFNWRy5GWCwge1xuICAvLyBNYXAgcm90YXRpb24gdG8gdHJhbnNmb3JtXG4gIHJvdGF0ZTogZnVuY3Rpb24oZCwgY3gsIGN5KSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHsgcm90YXRpb246IGQsIGN4OiBjeCwgY3k6IGN5IH0pXG4gIH1cbiAgLy8gTWFwIHNrZXcgdG8gdHJhbnNmb3JtXG4sIHNrZXc6IGZ1bmN0aW9uKHgsIHksIGN4LCBjeSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09IDEgIHx8IGFyZ3VtZW50cy5sZW5ndGggPT0gMyA/XG4gICAgICB0aGlzLnRyYW5zZm9ybSh7IHNrZXc6IHgsIGN4OiB5LCBjeTogY3ggfSkgOlxuICAgICAgdGhpcy50cmFuc2Zvcm0oeyBza2V3WDogeCwgc2tld1k6IHksIGN4OiBjeCwgY3k6IGN5IH0pXG4gIH1cbiAgLy8gTWFwIHNjYWxlIHRvIHRyYW5zZm9ybVxuLCBzY2FsZTogZnVuY3Rpb24oeCwgeSwgY3gsIGN5KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT0gMSAgfHwgYXJndW1lbnRzLmxlbmd0aCA9PSAzID9cbiAgICAgIHRoaXMudHJhbnNmb3JtKHsgc2NhbGU6IHgsIGN4OiB5LCBjeTogY3ggfSkgOlxuICAgICAgdGhpcy50cmFuc2Zvcm0oeyBzY2FsZVg6IHgsIHNjYWxlWTogeSwgY3g6IGN4LCBjeTogY3kgfSlcbiAgfVxuICAvLyBNYXAgdHJhbnNsYXRlIHRvIHRyYW5zZm9ybVxuLCB0cmFuc2xhdGU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oeyB4OiB4LCB5OiB5IH0pXG4gIH1cbiAgLy8gTWFwIGZsaXAgdG8gdHJhbnNmb3JtXG4sIGZsaXA6IGZ1bmN0aW9uKGEsIG8pIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oeyBmbGlwOiBhLCBvZmZzZXQ6IG8gfSlcbiAgfVxuICAvLyBNYXAgbWF0cml4IHRvIHRyYW5zZm9ybVxuLCBtYXRyaXg6IGZ1bmN0aW9uKG0pIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCd0cmFuc2Zvcm0nLCBuZXcgU1ZHLk1hdHJpeChtKSlcbiAgfVxuICAvLyBPcGFjaXR5XG4sIG9wYWNpdHk6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cignb3BhY2l0eScsIHZhbHVlKVxuICB9XG4gIC8vIFJlbGF0aXZlIG1vdmUgb3ZlciB4IGF4aXNcbiwgZHg6IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gdGhpcy54KCh0aGlzIGluc3RhbmNlb2YgU1ZHLkZYID8gMCA6IHRoaXMueCgpKSArIHgsIHRydWUpXG4gIH1cbiAgLy8gUmVsYXRpdmUgbW92ZSBvdmVyIHkgYXhpc1xuLCBkeTogZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiB0aGlzLnkoKHRoaXMgaW5zdGFuY2VvZiBTVkcuRlggPyAwIDogdGhpcy55KCkpICsgeSwgdHJ1ZSlcbiAgfVxuICAvLyBSZWxhdGl2ZSBtb3ZlIG92ZXIgeCBhbmQgeSBheGVzXG4sIGRtb3ZlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuZHgoeCkuZHkoeSlcbiAgfVxufSlcblxuU1ZHLmV4dGVuZChTVkcuUmVjdCwgU1ZHLkVsbGlwc2UsIFNWRy5DaXJjbGUsIFNWRy5HcmFkaWVudCwgU1ZHLkZYLCB7XG4gIC8vIEFkZCB4IGFuZCB5IHJhZGl1c1xuICByYWRpdXM6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgdHlwZSA9ICh0aGlzLl90YXJnZXQgfHwgdGhpcykudHlwZTtcbiAgICByZXR1cm4gdHlwZSA9PSAncmFkaWFsJyB8fCB0eXBlID09ICdjaXJjbGUnID9cbiAgICAgIHRoaXMuYXR0cigncicsIG5ldyBTVkcuTnVtYmVyKHgpKSA6XG4gICAgICB0aGlzLnJ4KHgpLnJ5KHkgPT0gbnVsbCA/IHggOiB5KVxuICB9XG59KVxuXG5TVkcuZXh0ZW5kKFNWRy5QYXRoLCB7XG4gIC8vIEdldCBwYXRoIGxlbmd0aFxuICBsZW5ndGg6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0VG90YWxMZW5ndGgoKVxuICB9XG4gIC8vIEdldCBwb2ludCBhdCBsZW5ndGhcbiwgcG9pbnRBdDogZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZS5nZXRQb2ludEF0TGVuZ3RoKGxlbmd0aClcbiAgfVxufSlcblxuU1ZHLmV4dGVuZChTVkcuUGFyZW50LCBTVkcuVGV4dCwgU1ZHLkZYLCB7XG4gIC8vIFNldCBmb250XG4gIGZvbnQ6IGZ1bmN0aW9uKG8pIHtcbiAgICBmb3IgKHZhciBrIGluIG8pXG4gICAgICBrID09ICdsZWFkaW5nJyA/XG4gICAgICAgIHRoaXMubGVhZGluZyhvW2tdKSA6XG4gICAgICBrID09ICdhbmNob3InID9cbiAgICAgICAgdGhpcy5hdHRyKCd0ZXh0LWFuY2hvcicsIG9ba10pIDpcbiAgICAgIGsgPT0gJ3NpemUnIHx8IGsgPT0gJ2ZhbWlseScgfHwgayA9PSAnd2VpZ2h0JyB8fCBrID09ICdzdHJldGNoJyB8fCBrID09ICd2YXJpYW50JyB8fCBrID09ICdzdHlsZScgP1xuICAgICAgICB0aGlzLmF0dHIoJ2ZvbnQtJysgaywgb1trXSkgOlxuICAgICAgICB0aGlzLmF0dHIoaywgb1trXSlcblxuICAgIHJldHVybiB0aGlzXG4gIH1cbn0pXG5cblNWRy5TZXQgPSBTVkcuaW52ZW50KHtcbiAgLy8gSW5pdGlhbGl6ZVxuICBjcmVhdGU6IGZ1bmN0aW9uKG1lbWJlcnMpIHtcbiAgICAvLyBTZXQgaW5pdGlhbCBzdGF0ZVxuICAgIEFycmF5LmlzQXJyYXkobWVtYmVycykgPyB0aGlzLm1lbWJlcnMgPSBtZW1iZXJzIDogdGhpcy5jbGVhcigpXG4gIH1cblxuICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuLCBleHRlbmQ6IHtcbiAgICAvLyBBZGQgZWxlbWVudCB0byBzZXRcbiAgICBhZGQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGksIGlsLCBlbGVtZW50cyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuXG4gICAgICBmb3IgKGkgPSAwLCBpbCA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspXG4gICAgICAgIHRoaXMubWVtYmVycy5wdXNoKGVsZW1lbnRzW2ldKVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICAvLyBSZW1vdmUgZWxlbWVudCBmcm9tIHNldFxuICAsIHJlbW92ZTogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgdmFyIGkgPSB0aGlzLmluZGV4KGVsZW1lbnQpXG5cbiAgICAgIC8vIHJlbW92ZSBnaXZlbiBjaGlsZFxuICAgICAgaWYgKGkgPiAtMSlcbiAgICAgICAgdGhpcy5tZW1iZXJzLnNwbGljZShpLCAxKVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICAvLyBJdGVyYXRlIG92ZXIgYWxsIG1lbWJlcnNcbiAgLCBlYWNoOiBmdW5jdGlvbihibG9jaykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gdGhpcy5tZW1iZXJzLmxlbmd0aDsgaSA8IGlsOyBpKyspXG4gICAgICAgIGJsb2NrLmFwcGx5KHRoaXMubWVtYmVyc1tpXSwgW2ksIHRoaXMubWVtYmVyc10pXG5cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIC8vIFJlc3RvcmUgdG8gZGVmYXVsdHNcbiAgLCBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBpbml0aWFsaXplIHN0b3JlXG4gICAgICB0aGlzLm1lbWJlcnMgPSBbXVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIGxlbmd0aCBvZiBhIHNldFxuICAsIGxlbmd0aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZW1iZXJzLmxlbmd0aFxuICAgIH1cbiAgICAvLyBDaGVja3MgaWYgYSBnaXZlbiBlbGVtZW50IGlzIHByZXNlbnQgaW4gc2V0XG4gICwgaGFzOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleChlbGVtZW50KSA+PSAwXG4gICAgfVxuICAgIC8vIHJldHVucyBpbmRleCBvZiBnaXZlbiBlbGVtZW50IGluIHNldFxuICAsIGluZGV4OiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5tZW1iZXJzLmluZGV4T2YoZWxlbWVudClcbiAgICB9XG4gICAgLy8gR2V0IG1lbWJlciBhdCBnaXZlbiBpbmRleFxuICAsIGdldDogZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIHRoaXMubWVtYmVyc1tpXVxuICAgIH1cbiAgICAvLyBHZXQgZmlyc3QgbWVtYmVyXG4gICwgZmlyc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KDApXG4gICAgfVxuICAgIC8vIEdldCBsYXN0IG1lbWJlclxuICAsIGxhc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMubWVtYmVycy5sZW5ndGggLSAxKVxuICAgIH1cbiAgICAvLyBEZWZhdWx0IHZhbHVlXG4gICwgdmFsdWVPZjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZW1iZXJzXG4gICAgfVxuICAgIC8vIEdldCB0aGUgYm91bmRpbmcgYm94IG9mIGFsbCBtZW1iZXJzIGluY2x1ZGVkIG9yIGVtcHR5IGJveCBpZiBzZXQgaGFzIG5vIGl0ZW1zXG4gICwgYmJveDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBib3ggPSBuZXcgU1ZHLkJCb3goKVxuXG4gICAgICAvLyByZXR1cm4gYW4gZW1wdHkgYm94IG9mIHRoZXJlIGFyZSBubyBtZW1iZXJzXG4gICAgICBpZiAodGhpcy5tZW1iZXJzLmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm4gYm94XG5cbiAgICAgIC8vIGdldCB0aGUgZmlyc3QgcmJveCBhbmQgdXBkYXRlIHRoZSB0YXJnZXQgYmJveFxuICAgICAgdmFyIHJib3ggPSB0aGlzLm1lbWJlcnNbMF0ucmJveCgpXG4gICAgICBib3gueCAgICAgID0gcmJveC54XG4gICAgICBib3gueSAgICAgID0gcmJveC55XG4gICAgICBib3gud2lkdGggID0gcmJveC53aWR0aFxuICAgICAgYm94LmhlaWdodCA9IHJib3guaGVpZ2h0XG5cbiAgICAgIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gdXNlciByYm94IGZvciBjb3JyZWN0IHBvc2l0aW9uIGFuZCB2aXN1YWwgcmVwcmVzZW50YXRpb25cbiAgICAgICAgYm94ID0gYm94Lm1lcmdlKHRoaXMucmJveCgpKVxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIGJveFxuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBwYXJlbnQgbWV0aG9kXG4sIGNvbnN0cnVjdDoge1xuICAgIC8vIENyZWF0ZSBhIG5ldyBzZXRcbiAgICBzZXQ6IGZ1bmN0aW9uKG1lbWJlcnMpIHtcbiAgICAgIHJldHVybiBuZXcgU1ZHLlNldChtZW1iZXJzKVxuICAgIH1cbiAgfVxufSlcblxuU1ZHLkZYLlNldCA9IFNWRy5pbnZlbnQoe1xuICAvLyBJbml0aWFsaXplIG5vZGVcbiAgY3JlYXRlOiBmdW5jdGlvbihzZXQpIHtcbiAgICAvLyBzdG9yZSByZWZlcmVuY2UgdG8gc2V0XG4gICAgdGhpcy5zZXQgPSBzZXRcbiAgfVxuXG59KVxuXG4vLyBBbGlhcyBtZXRob2RzXG5TVkcuU2V0LmluaGVyaXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG1cbiAgICAsIG1ldGhvZHMgPSBbXVxuXG4gIC8vIGdhdGhlciBzaGFwZSBtZXRob2RzXG4gIGZvcih2YXIgbSBpbiBTVkcuU2hhcGUucHJvdG90eXBlKVxuICAgIGlmICh0eXBlb2YgU1ZHLlNoYXBlLnByb3RvdHlwZVttXSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTVkcuU2V0LnByb3RvdHlwZVttXSAhPSAnZnVuY3Rpb24nKVxuICAgICAgbWV0aG9kcy5wdXNoKG0pXG5cbiAgLy8gYXBwbHkgc2hhcGUgYWxpYXNzZXNcbiAgbWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIFNWRy5TZXQucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHRoaXMubWVtYmVycy5sZW5ndGg7IGkgPCBpbDsgaSsrKVxuICAgICAgICBpZiAodGhpcy5tZW1iZXJzW2ldICYmIHR5cGVvZiB0aGlzLm1lbWJlcnNbaV1bbWV0aG9kXSA9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIHRoaXMubWVtYmVyc1tpXVttZXRob2RdLmFwcGx5KHRoaXMubWVtYmVyc1tpXSwgYXJndW1lbnRzKVxuXG4gICAgICByZXR1cm4gbWV0aG9kID09ICdhbmltYXRlJyA/ICh0aGlzLmZ4IHx8ICh0aGlzLmZ4ID0gbmV3IFNWRy5GWC5TZXQodGhpcykpKSA6IHRoaXNcbiAgICB9XG4gIH0pXG5cbiAgLy8gY2xlYXIgbWV0aG9kcyBmb3IgdGhlIG5leHQgcm91bmRcbiAgbWV0aG9kcyA9IFtdXG5cbiAgLy8gZ2F0aGVyIGZ4IG1ldGhvZHNcbiAgZm9yKHZhciBtIGluIFNWRy5GWC5wcm90b3R5cGUpXG4gICAgaWYgKHR5cGVvZiBTVkcuRlgucHJvdG90eXBlW21dID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFNWRy5GWC5TZXQucHJvdG90eXBlW21dICE9ICdmdW5jdGlvbicpXG4gICAgICBtZXRob2RzLnB1c2gobSlcblxuICAvLyBhcHBseSBmeCBhbGlhc3Nlc1xuICBtZXRob2RzLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgU1ZHLkZYLlNldC5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gdGhpcy5zZXQubWVtYmVycy5sZW5ndGg7IGkgPCBpbDsgaSsrKVxuICAgICAgICB0aGlzLnNldC5tZW1iZXJzW2ldLmZ4W21ldGhvZF0uYXBwbHkodGhpcy5zZXQubWVtYmVyc1tpXS5meCwgYXJndW1lbnRzKVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgfSlcbn1cblxuXG5cblxuU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwge1xuICAvLyBTdG9yZSBkYXRhIHZhbHVlcyBvbiBzdmcgbm9kZXNcbiAgZGF0YTogZnVuY3Rpb24oYSwgdiwgcikge1xuICAgIGlmICh0eXBlb2YgYSA9PSAnb2JqZWN0Jykge1xuICAgICAgZm9yICh2IGluIGEpXG4gICAgICAgIHRoaXMuZGF0YSh2LCBhW3ZdKVxuXG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGhpcy5hdHRyKCdkYXRhLScgKyBhKSlcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCdkYXRhLScgKyBhKVxuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXR0cihcbiAgICAgICAgJ2RhdGEtJyArIGFcbiAgICAgICwgdiA9PT0gbnVsbCA/XG4gICAgICAgICAgbnVsbCA6XG4gICAgICAgIHIgPT09IHRydWUgfHwgdHlwZW9mIHYgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2ID09PSAnbnVtYmVyJyA/XG4gICAgICAgICAgdiA6XG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkodilcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG59KVxuU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwge1xuICAvLyBSZW1lbWJlciBhcmJpdHJhcnkgZGF0YVxuICByZW1lbWJlcjogZnVuY3Rpb24oaywgdikge1xuICAgIC8vIHJlbWVtYmVyIGV2ZXJ5IGl0ZW0gaW4gYW4gb2JqZWN0IGluZGl2aWR1YWxseVxuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09ICdvYmplY3QnKVxuICAgICAgZm9yICh2YXIgdiBpbiBrKVxuICAgICAgICB0aGlzLnJlbWVtYmVyKHYsIGtbdl0pXG5cbiAgICAvLyByZXRyaWV2ZSBtZW1vcnlcbiAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpXG4gICAgICByZXR1cm4gdGhpcy5tZW1vcnkoKVtrXVxuXG4gICAgLy8gc3RvcmUgbWVtb3J5XG4gICAgZWxzZVxuICAgICAgdGhpcy5tZW1vcnkoKVtrXSA9IHZcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBFcmFzZSBhIGdpdmVuIG1lbW9yeVxuLCBmb3JnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDApXG4gICAgICB0aGlzLl9tZW1vcnkgPSB7fVxuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGRlbGV0ZSB0aGlzLm1lbW9yeSgpW2FyZ3VtZW50c1tpXV1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBJbml0aWFsaXplIG9yIHJldHVybiBsb2NhbCBtZW1vcnkgb2JqZWN0XG4sIG1lbW9yeTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lbW9yeSB8fCAodGhpcy5fbWVtb3J5ID0ge30pXG4gIH1cblxufSlcbi8vIE1ldGhvZCBmb3IgZ2V0dGluZyBhbiBlbGVtZW50IGJ5IGlkXG5TVkcuZ2V0ID0gZnVuY3Rpb24oaWQpIHtcbiAgdmFyIG5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZEZyb21SZWZlcmVuY2UoaWQpIHx8IGlkKVxuICByZXR1cm4gU1ZHLmFkb3B0KG5vZGUpXG59XG5cbi8vIFNlbGVjdCBlbGVtZW50cyBieSBxdWVyeSBzdHJpbmdcblNWRy5zZWxlY3QgPSBmdW5jdGlvbihxdWVyeSwgcGFyZW50KSB7XG4gIHJldHVybiBuZXcgU1ZHLlNldChcbiAgICBTVkcudXRpbHMubWFwKChwYXJlbnQgfHwgZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gU1ZHLmFkb3B0KG5vZGUpXG4gICAgfSlcbiAgKVxufVxuXG5TVkcuZXh0ZW5kKFNWRy5QYXJlbnQsIHtcbiAgLy8gU2NvcGVkIHNlbGVjdCBtZXRob2RcbiAgc2VsZWN0OiBmdW5jdGlvbihxdWVyeSkge1xuICAgIHJldHVybiBTVkcuc2VsZWN0KHF1ZXJ5LCB0aGlzLm5vZGUpXG4gIH1cblxufSlcbmZ1bmN0aW9uIGlzKGVsLCBvYmope1xuICByZXR1cm4gZWwgaW5zdGFuY2VvZiBvYmpcbn1cblxuLy8gdGVzdHMgaWYgYSBnaXZlbiBzZWxlY3RvciBtYXRjaGVzIGFuIGVsZW1lbnRcbmZ1bmN0aW9uIG1hdGNoZXMoZWwsIHNlbGVjdG9yKSB7XG4gIHJldHVybiAoZWwubWF0Y2hlcyB8fCBlbC5tYXRjaGVzU2VsZWN0b3IgfHwgZWwubXNNYXRjaGVzU2VsZWN0b3IgfHwgZWwubW96TWF0Y2hlc1NlbGVjdG9yIHx8IGVsLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBlbC5vTWF0Y2hlc1NlbGVjdG9yKS5jYWxsKGVsLCBzZWxlY3Rvcik7XG59XG5cbi8vIENvbnZlcnQgZGFzaC1zZXBhcmF0ZWQtc3RyaW5nIHRvIGNhbWVsQ2FzZVxuZnVuY3Rpb24gY2FtZWxDYXNlKHMpIHtcbiAgcmV0dXJuIHMudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8tKC4pL2csIGZ1bmN0aW9uKG0sIGcpIHtcbiAgICByZXR1cm4gZy50b1VwcGVyQ2FzZSgpXG4gIH0pXG59XG5cbi8vIENhcGl0YWxpemUgZmlyc3QgbGV0dGVyIG9mIGEgc3RyaW5nXG5mdW5jdGlvbiBjYXBpdGFsaXplKHMpIHtcbiAgcmV0dXJuIHMuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzLnNsaWNlKDEpXG59XG5cbi8vIEVuc3VyZSB0byBzaXgtYmFzZWQgaGV4XG5mdW5jdGlvbiBmdWxsSGV4KGhleCkge1xuICByZXR1cm4gaGV4Lmxlbmd0aCA9PSA0ID9cbiAgICBbICcjJyxcbiAgICAgIGhleC5zdWJzdHJpbmcoMSwgMiksIGhleC5zdWJzdHJpbmcoMSwgMilcbiAgICAsIGhleC5zdWJzdHJpbmcoMiwgMyksIGhleC5zdWJzdHJpbmcoMiwgMylcbiAgICAsIGhleC5zdWJzdHJpbmcoMywgNCksIGhleC5zdWJzdHJpbmcoMywgNClcbiAgICBdLmpvaW4oJycpIDogaGV4XG59XG5cbi8vIENvbXBvbmVudCB0byBoZXggdmFsdWVcbmZ1bmN0aW9uIGNvbXBUb0hleChjb21wKSB7XG4gIHZhciBoZXggPSBjb21wLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gaGV4Lmxlbmd0aCA9PSAxID8gJzAnICsgaGV4IDogaGV4XG59XG5cbi8vIENhbGN1bGF0ZSBwcm9wb3J0aW9uYWwgd2lkdGggYW5kIGhlaWdodCB2YWx1ZXMgd2hlbiBuZWNlc3NhcnlcbmZ1bmN0aW9uIHByb3BvcnRpb25hbFNpemUoZWxlbWVudCwgd2lkdGgsIGhlaWdodCkge1xuICBpZiAod2lkdGggPT0gbnVsbCB8fCBoZWlnaHQgPT0gbnVsbCkge1xuICAgIHZhciBib3ggPSBlbGVtZW50LmJib3goKVxuXG4gICAgaWYgKHdpZHRoID09IG51bGwpXG4gICAgICB3aWR0aCA9IGJveC53aWR0aCAvIGJveC5oZWlnaHQgKiBoZWlnaHRcbiAgICBlbHNlIGlmIChoZWlnaHQgPT0gbnVsbClcbiAgICAgIGhlaWdodCA9IGJveC5oZWlnaHQgLyBib3gud2lkdGggKiB3aWR0aFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogIHdpZHRoXG4gICwgaGVpZ2h0OiBoZWlnaHRcbiAgfVxufVxuXG4vLyBEZWx0YSB0cmFuc2Zvcm0gcG9pbnRcbmZ1bmN0aW9uIGRlbHRhVHJhbnNmb3JtUG9pbnQobWF0cml4LCB4LCB5KSB7XG4gIHJldHVybiB7XG4gICAgeDogeCAqIG1hdHJpeC5hICsgeSAqIG1hdHJpeC5jICsgMFxuICAsIHk6IHggKiBtYXRyaXguYiArIHkgKiBtYXRyaXguZCArIDBcbiAgfVxufVxuXG4vLyBNYXAgbWF0cml4IGFycmF5IHRvIG9iamVjdFxuZnVuY3Rpb24gYXJyYXlUb01hdHJpeChhKSB7XG4gIHJldHVybiB7IGE6IGFbMF0sIGI6IGFbMV0sIGM6IGFbMl0sIGQ6IGFbM10sIGU6IGFbNF0sIGY6IGFbNV0gfVxufVxuXG4vLyBQYXJzZSBtYXRyaXggaWYgcmVxdWlyZWRcbmZ1bmN0aW9uIHBhcnNlTWF0cml4KG1hdHJpeCkge1xuICBpZiAoIShtYXRyaXggaW5zdGFuY2VvZiBTVkcuTWF0cml4KSlcbiAgICBtYXRyaXggPSBuZXcgU1ZHLk1hdHJpeChtYXRyaXgpXG5cbiAgcmV0dXJuIG1hdHJpeFxufVxuXG4vLyBBZGQgY2VudHJlIHBvaW50IHRvIHRyYW5zZm9ybSBvYmplY3RcbmZ1bmN0aW9uIGVuc3VyZUNlbnRyZShvLCB0YXJnZXQpIHtcbiAgby5jeCA9IG8uY3ggPT0gbnVsbCA/IHRhcmdldC5iYm94KCkuY3ggOiBvLmN4XG4gIG8uY3kgPSBvLmN5ID09IG51bGwgPyB0YXJnZXQuYmJveCgpLmN5IDogby5jeVxufVxuXG4vLyBDb252ZXJ0IHN0cmluZyB0byBtYXRyaXhcbmZ1bmN0aW9uIHN0cmluZ1RvTWF0cml4KHNvdXJjZSkge1xuICAvLyByZW1vdmUgbWF0cml4IHdyYXBwZXIgYW5kIHNwbGl0IHRvIGluZGl2aWR1YWwgbnVtYmVyc1xuICBzb3VyY2UgPSBzb3VyY2VcbiAgICAucmVwbGFjZShTVkcucmVnZXgud2hpdGVzcGFjZSwgJycpXG4gICAgLnJlcGxhY2UoU1ZHLnJlZ2V4Lm1hdHJpeCwgJycpXG4gICAgLnNwbGl0KFNWRy5yZWdleC5tYXRyaXhFbGVtZW50cylcblxuICAvLyBjb252ZXJ0IHN0cmluZyB2YWx1ZXMgdG8gZmxvYXRzIGFuZCBjb252ZXJ0IHRvIGEgbWF0cml4LWZvcm1hdHRlZCBvYmplY3RcbiAgcmV0dXJuIGFycmF5VG9NYXRyaXgoXG4gICAgU1ZHLnV0aWxzLm1hcChzb3VyY2UsIGZ1bmN0aW9uKG4pIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KG4pXG4gICAgfSlcbiAgKVxufVxuXG4vLyBDYWxjdWxhdGUgcG9zaXRpb24gYWNjb3JkaW5nIHRvIGZyb20gYW5kIHRvXG5mdW5jdGlvbiBhdChvLCBwb3MpIHtcbiAgLy8gbnVtYmVyIHJlY2FsY3VsYXRpb24gKGRvbid0IGJvdGhlciBjb252ZXJ0aW5nIHRvIFNWRy5OdW1iZXIgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMpXG4gIHJldHVybiB0eXBlb2Ygby5mcm9tID09ICdudW1iZXInID9cbiAgICBvLmZyb20gKyAoby50byAtIG8uZnJvbSkgKiBwb3MgOlxuXG4gIC8vIGluc3RhbmNlIHJlY2FsY3VsYXRpb25cbiAgbyBpbnN0YW5jZW9mIFNWRy5Db2xvciB8fCBvIGluc3RhbmNlb2YgU1ZHLk51bWJlciB8fCBvIGluc3RhbmNlb2YgU1ZHLk1hdHJpeCA/IG8uYXQocG9zKSA6XG5cbiAgLy8gZm9yIGFsbCBvdGhlciB2YWx1ZXMgd2FpdCB1bnRpbCBwb3MgaGFzIHJlYWNoZWQgMSB0byByZXR1cm4gdGhlIGZpbmFsIHZhbHVlXG4gIHBvcyA8IDEgPyBvLmZyb20gOiBvLnRvXG59XG5cbi8vIFBhdGhBcnJheSBIZWxwZXJzXG5mdW5jdGlvbiBhcnJheVRvU3RyaW5nKGEpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGlsID0gYS5sZW5ndGgsIHMgPSAnJzsgaSA8IGlsOyBpKyspIHtcbiAgICBzICs9IGFbaV1bMF1cblxuICAgIGlmIChhW2ldWzFdICE9IG51bGwpIHtcbiAgICAgIHMgKz0gYVtpXVsxXVxuXG4gICAgICBpZiAoYVtpXVsyXSAhPSBudWxsKSB7XG4gICAgICAgIHMgKz0gJyAnXG4gICAgICAgIHMgKz0gYVtpXVsyXVxuXG4gICAgICAgIGlmIChhW2ldWzNdICE9IG51bGwpIHtcbiAgICAgICAgICBzICs9ICcgJ1xuICAgICAgICAgIHMgKz0gYVtpXVszXVxuICAgICAgICAgIHMgKz0gJyAnXG4gICAgICAgICAgcyArPSBhW2ldWzRdXG5cbiAgICAgICAgICBpZiAoYVtpXVs1XSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzICs9ICcgJ1xuICAgICAgICAgICAgcyArPSBhW2ldWzVdXG4gICAgICAgICAgICBzICs9ICcgJ1xuICAgICAgICAgICAgcyArPSBhW2ldWzZdXG5cbiAgICAgICAgICAgIGlmIChhW2ldWzddICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcyArPSAnICdcbiAgICAgICAgICAgICAgcyArPSBhW2ldWzddXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHMgKyAnICdcbn1cblxuLy8gRGVlcCBuZXcgaWQgYXNzaWdubWVudFxuZnVuY3Rpb24gYXNzaWduTmV3SWQobm9kZSkge1xuICAvLyBkbyB0aGUgc2FtZSBmb3IgU1ZHIGNoaWxkIG5vZGVzIGFzIHdlbGxcbiAgZm9yICh2YXIgaSA9IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICBpZiAobm9kZS5jaGlsZE5vZGVzW2ldIGluc3RhbmNlb2YgU1ZHRWxlbWVudClcbiAgICAgIGFzc2lnbk5ld0lkKG5vZGUuY2hpbGROb2Rlc1tpXSlcblxuICByZXR1cm4gU1ZHLmFkb3B0KG5vZGUpLmlkKFNWRy5laWQobm9kZS5ub2RlTmFtZSkpXG59XG5cbi8vIEFkZCBtb3JlIGJvdW5kaW5nIGJveCBwcm9wZXJ0aWVzXG5mdW5jdGlvbiBmdWxsQm94KGIpIHtcbiAgaWYgKGIueCA9PSBudWxsKSB7XG4gICAgYi54ICAgICAgPSAwXG4gICAgYi55ICAgICAgPSAwXG4gICAgYi53aWR0aCAgPSAwXG4gICAgYi5oZWlnaHQgPSAwXG4gIH1cblxuICBiLncgID0gYi53aWR0aFxuICBiLmggID0gYi5oZWlnaHRcbiAgYi54MiA9IGIueCArIGIud2lkdGhcbiAgYi55MiA9IGIueSArIGIuaGVpZ2h0XG4gIGIuY3ggPSBiLnggKyBiLndpZHRoIC8gMlxuICBiLmN5ID0gYi55ICsgYi5oZWlnaHQgLyAyXG5cbiAgcmV0dXJuIGJcbn1cblxuLy8gR2V0IGlkIGZyb20gcmVmZXJlbmNlIHN0cmluZ1xuZnVuY3Rpb24gaWRGcm9tUmVmZXJlbmNlKHVybCkge1xuICB2YXIgbSA9IHVybC50b1N0cmluZygpLm1hdGNoKFNWRy5yZWdleC5yZWZlcmVuY2UpXG5cbiAgaWYgKG0pIHJldHVybiBtWzFdXG59XG5cbi8vIENyZWF0ZSBtYXRyaXggYXJyYXkgZm9yIGxvb3BpbmdcbnZhciBhYmNkZWYgPSAnYWJjZGVmJy5zcGxpdCgnJylcbi8vIEFkZCBDdXN0b21FdmVudCB0byBJRTkgYW5kIElFMTBcbmlmICh0eXBlb2YgQ3VzdG9tRXZlbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgLy8gQ29kZSBmcm9tOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnRcbiAgdmFyIEN1c3RvbUV2ZW50ID0gZnVuY3Rpb24oZXZlbnQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSwgZGV0YWlsOiB1bmRlZmluZWQgfVxuICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50JylcbiAgICBlLmluaXRDdXN0b21FdmVudChldmVudCwgb3B0aW9ucy5idWJibGVzLCBvcHRpb25zLmNhbmNlbGFibGUsIG9wdGlvbnMuZGV0YWlsKVxuICAgIHJldHVybiBlXG4gIH1cblxuICBDdXN0b21FdmVudC5wcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlXG5cbiAgd2luZG93LkN1c3RvbUV2ZW50ID0gQ3VzdG9tRXZlbnRcbn1cblxuLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIC8gY2FuY2VsQW5pbWF0aW9uRnJhbWUgUG9seWZpbGwgd2l0aCBmYWxsYmFjayBiYXNlZCBvbiBQYXVsIElyaXNoXG4oZnVuY3Rpb24odykge1xuICB2YXIgbGFzdFRpbWUgPSAwXG4gIHZhciB2ZW5kb3JzID0gWydtb3onLCAnd2Via2l0J11cblxuICBmb3IodmFyIHggPSAwOyB4IDwgdmVuZG9ycy5sZW5ndGggJiYgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsreCkge1xuICAgIHcucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd1t2ZW5kb3JzW3hdICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddXG4gICAgdy5jYW5jZWxBbmltYXRpb25GcmFtZSAgPSB3W3ZlbmRvcnNbeF0gKyAnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd1t2ZW5kb3JzW3hdICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddXG4gIH1cblxuICB3LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHcucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIHZhciBjdXJyVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgICB2YXIgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKVxuXG4gICAgICB2YXIgaWQgPSB3LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbGxiYWNrKGN1cnJUaW1lICsgdGltZVRvQ2FsbClcbiAgICAgIH0sIHRpbWVUb0NhbGwpXG5cbiAgICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsXG4gICAgICByZXR1cm4gaWRcbiAgICB9XG5cbiAgdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IHcuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgdy5jbGVhclRpbWVvdXQ7XG5cbn0od2luZG93KSlcblxucmV0dXJuIFNWR1xuXG59KSk7IiwiaW1wb3J0IGZpdEN1cnZlIGZyb20gJ2ZpdC1jdXJ2ZSc7XG5pbXBvcnQgTGV2ZWxDdXJ2ZSBmcm9tICcuLi9tb2RlbC9MZXZlbEN1cnZlJztcbmltcG9ydCAqIGFzIFVJIGZyb20gJy4uL21vZGVsL1VJTWFuYWdlbWVudCc7XG5cbmNvbnN0IGVycm9yID0gMTAwO1xuXG5mdW5jdGlvbiBQYWludENvbnRyb2wocGFubmVsKSB7XG5cdGxldCByYXdQb2ludERhdGEgPSBbXTtcblx0bGV0IHBhaW50aW5nUG9seUxpbmUgPSB1bmRlZmluZWQ7XG5cblx0dGhpcy5zdGFydCA9IGZ1bmN0aW9uKCBwb2ludCApIHtcblx0XHRyYXdQb2ludERhdGEucHVzaCggcG9pbnQgKTtcblx0XHRwYWludGluZ1BvbHlMaW5lID0gcGFubmVsLnBvbHlsaW5lKCkuZmlsbCgnbm9uZScpLnN0cm9rZSh7IHdpZHRoOiAxIH0pO1xuXG5cdH07XG5cdHRoaXMudXBkYXRlID0gZnVuY3Rpb24oIHBvaW50ICkge1xuXHRcdHJhd1BvaW50RGF0YS5wdXNoKCBwb2ludCApO1xuXHRcdHVwZGF0ZUxpbmVzKCBwYWludGluZ1BvbHlMaW5lLCByYXdQb2ludERhdGEpO1xuXHR9O1xuXG5cdHRoaXMuZW5kID0gZnVuY3Rpb24oKSB7XG5cdFx0bGV0IHNtb290aEJpemVyID0gZml0Q3VydmUoIHJhd1BvaW50RGF0YSwgZXJyb3IgKTtcblx0XHRpZihzbW9vdGhCaXplci5sZW5ndGggPT0gMCkge1xuXHRcdFx0Y2xlYXJSYXdEYXRhKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGxldCBwYXRoU3RyaW5nID0gZml0dGVkQ3VydmVUb1BhdGhTdHJpbmcoc21vb3RoQml6ZXIpO1xuXG5cdFx0ZHJhd09uUGFubmVsKHBhbm5lbCwgcGF0aFN0cmluZyk7XG5cblx0XHRsZXQgbHZDdXJ2ZSA9IG5ldyBMZXZlbEN1cnZlKCBzbW9vdGhCaXplciwgMSwgVUkuc3RhdGUubGV2ZWxDdXJ2ZSk7XG5cdFx0bHZDdXJ2ZS5kcmF3T24ocGFubmVsKTtcblxuXHRcdGNsZWFyUmF3RGF0YSgpO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIHVwZGF0ZUxpbmVzKHBhaW50aW5nUG9seUxpbmUsIHJhd1BvaW50RGF0YSkge1xuXHRcdHBhaW50aW5nUG9seUxpbmUucGxvdCggcmF3UG9pbnREYXRhICk7XG5cdH1cblx0ZnVuY3Rpb24gZml0dGVkQ3VydmVUb1BhdGhTdHJpbmcoZml0dGVkTGluZURhdGEpIHtcblx0XHR2YXIgc3RyID0gJyc7XG5cdFx0Ly9iZXppZXIgOiBbIFtjMF0sIFtjMV0sIFtjMl0sIFtjM10gXVxuXHRcdGZpdHRlZExpbmVEYXRhLm1hcChmdW5jdGlvbiAoYmV6aWVyLCBpKSB7XG5cdFx0XHRpZiAoaSA9PSAwKSB7XG5cdFx0XHRcdHN0ciArPSAnTSAnICsgYmV6aWVyWzBdWzBdICsgJyAnICsgYmV6aWVyWzBdWzFdO1xuXHRcdFx0fVxuXG5cdFx0XHRzdHIgKz0gJ0MgJyArIGJlemllclsxXVswXSArICcgJyArIGJlemllclsxXVsxXSArICcsICcgK1xuXHRcdFx0YmV6aWVyWzJdWzBdICsgJyAnICsgYmV6aWVyWzJdWzFdICsgJywgJyArXG5cdFx0XHRiZXppZXJbM11bMF0gKyAnICcgKyBiZXppZXJbM11bMV0gKyAnICc7XHRcblx0XHRcdFx0XHRcdFxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHN0cjtcblx0fVxuXHRmdW5jdGlvbiBkcmF3T25QYW5uZWwocGFubmVsLCBwYXRoU3RyaW5nKXtcblx0XHRwYW5uZWwucGF0aCggcGF0aFN0cmluZyApLmZpbGwoJ25vbmUnKS5zdHJva2UoeyB3aWR0aDogMyB9KS5zdHJva2UoJyNmMDYnKTtcblx0fVxuXHRmdW5jdGlvbiBjbGVhclJhd0RhdGEoKXtcblx0XHRyYXdQb2ludERhdGEubGVuZ3RoID0gMDtcblx0XHRwYWludGluZ1BvbHlMaW5lLnJlbW92ZSgpO1xuXHR9XHRcbn1cblxuZXhwb3J0IGRlZmF1bHQgUGFpbnRDb250cm9sO1xuXG4iLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJkYXRcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiZGF0XCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgX2luZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblx0XG5cdHZhciBfaW5kZXgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5kZXgpO1xuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblx0XG5cdG1vZHVsZS5leHBvcnRzID0gX2luZGV4Mi5kZWZhdWx0OyAvKipcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGRhdC1ndWkgSmF2YVNjcmlwdCBDb250cm9sbGVyIExpYnJhcnlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9kYXQtZ3VpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ29weXJpZ2h0IDIwMTEgRGF0YSBBcnRzIFRlYW0sIEdvb2dsZSBDcmVhdGl2ZSBMYWJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuLyoqKi8gfSxcbi8qIDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cdFxuXHR2YXIgX0NvbG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0XG5cdHZhciBfQ29sb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ29sb3IpO1xuXHRcblx0dmFyIF9tYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0XG5cdHZhciBfbWF0aDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXRoKTtcblx0XG5cdHZhciBfaW50ZXJwcmV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0XG5cdHZhciBfaW50ZXJwcmV0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludGVycHJldCk7XG5cdFxuXHR2YXIgX0NvbnRyb2xsZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXHRcblx0dmFyIF9Db250cm9sbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NvbnRyb2xsZXIpO1xuXHRcblx0dmFyIF9Cb29sZWFuQ29udHJvbGxlciA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cdFxuXHR2YXIgX0Jvb2xlYW5Db250cm9sbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jvb2xlYW5Db250cm9sbGVyKTtcblx0XG5cdHZhciBfT3B0aW9uQ29udHJvbGxlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXHRcblx0dmFyIF9PcHRpb25Db250cm9sbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX09wdGlvbkNvbnRyb2xsZXIpO1xuXHRcblx0dmFyIF9TdHJpbmdDb250cm9sbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cdFxuXHR2YXIgX1N0cmluZ0NvbnRyb2xsZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3RyaW5nQ29udHJvbGxlcik7XG5cdFxuXHR2YXIgX051bWJlckNvbnRyb2xsZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblx0XG5cdHZhciBfTnVtYmVyQ29udHJvbGxlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9OdW1iZXJDb250cm9sbGVyKTtcblx0XG5cdHZhciBfTnVtYmVyQ29udHJvbGxlckJveCA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXHRcblx0dmFyIF9OdW1iZXJDb250cm9sbGVyQm94MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX051bWJlckNvbnRyb2xsZXJCb3gpO1xuXHRcblx0dmFyIF9OdW1iZXJDb250cm9sbGVyU2xpZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cdFxuXHR2YXIgX051bWJlckNvbnRyb2xsZXJTbGlkZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTnVtYmVyQ29udHJvbGxlclNsaWRlcik7XG5cdFxuXHR2YXIgX0Z1bmN0aW9uQ29udHJvbGxlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuXHRcblx0dmFyIF9GdW5jdGlvbkNvbnRyb2xsZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRnVuY3Rpb25Db250cm9sbGVyKTtcblx0XG5cdHZhciBfQ29sb3JDb250cm9sbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cdFxuXHR2YXIgX0NvbG9yQ29udHJvbGxlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Db2xvckNvbnRyb2xsZXIpO1xuXHRcblx0dmFyIF9kb20gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXHRcblx0dmFyIF9kb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZG9tKTtcblx0XG5cdHZhciBfR1VJID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5cdFxuXHR2YXIgX0dVSTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9HVUkpO1xuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblx0XG5cdC8qKlxuXHQgKiBkYXQtZ3VpIEphdmFTY3JpcHQgQ29udHJvbGxlciBMaWJyYXJ5XG5cdCAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9kYXQtZ3VpXG5cdCAqXG5cdCAqIENvcHlyaWdodCAyMDExIERhdGEgQXJ0cyBUZWFtLCBHb29nbGUgQ3JlYXRpdmUgTGFiXG5cdCAqXG5cdCAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG5cdCAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cblx0ICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cdCAqXG5cdCAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXHQgKi9cblx0XG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcblx0ICBjb2xvcjoge1xuXHQgICAgQ29sb3I6IF9Db2xvcjIuZGVmYXVsdCxcblx0ICAgIG1hdGg6IF9tYXRoMi5kZWZhdWx0LFxuXHQgICAgaW50ZXJwcmV0OiBfaW50ZXJwcmV0Mi5kZWZhdWx0XG5cdCAgfSxcblx0XG5cdCAgY29udHJvbGxlcnM6IHtcblx0ICAgIENvbnRyb2xsZXI6IF9Db250cm9sbGVyMi5kZWZhdWx0LFxuXHQgICAgQm9vbGVhbkNvbnRyb2xsZXI6IF9Cb29sZWFuQ29udHJvbGxlcjIuZGVmYXVsdCxcblx0ICAgIE9wdGlvbkNvbnRyb2xsZXI6IF9PcHRpb25Db250cm9sbGVyMi5kZWZhdWx0LFxuXHQgICAgU3RyaW5nQ29udHJvbGxlcjogX1N0cmluZ0NvbnRyb2xsZXIyLmRlZmF1bHQsXG5cdCAgICBOdW1iZXJDb250cm9sbGVyOiBfTnVtYmVyQ29udHJvbGxlcjIuZGVmYXVsdCxcblx0ICAgIE51bWJlckNvbnRyb2xsZXJCb3g6IF9OdW1iZXJDb250cm9sbGVyQm94Mi5kZWZhdWx0LFxuXHQgICAgTnVtYmVyQ29udHJvbGxlclNsaWRlcjogX051bWJlckNvbnRyb2xsZXJTbGlkZXIyLmRlZmF1bHQsXG5cdCAgICBGdW5jdGlvbkNvbnRyb2xsZXI6IF9GdW5jdGlvbkNvbnRyb2xsZXIyLmRlZmF1bHQsXG5cdCAgICBDb2xvckNvbnRyb2xsZXI6IF9Db2xvckNvbnRyb2xsZXIyLmRlZmF1bHRcblx0ICB9LFxuXHRcblx0ICBkb206IHtcblx0ICAgIGRvbTogX2RvbTIuZGVmYXVsdFxuXHQgIH0sXG5cdFxuXHQgIGd1aToge1xuXHQgICAgR1VJOiBfR1VJMi5kZWZhdWx0XG5cdCAgfSxcblx0XG5cdCAgR1VJOiBfR1VJMi5kZWZhdWx0XG5cdH07XG5cbi8qKiovIH0sXG4vKiAyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHRcblx0dmFyIF9pbnRlcnByZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHRcblx0dmFyIF9pbnRlcnByZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW50ZXJwcmV0KTtcblx0XG5cdHZhciBfbWF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdFxuXHR2YXIgX21hdGgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0aCk7XG5cdFxuXHR2YXIgX3RvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0XG5cdHZhciBfdG9TdHJpbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9TdHJpbmcpO1xuXHRcblx0dmFyIF9jb21tb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHRcblx0dmFyIF9jb21tb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tbW9uKTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfSAvKipcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGRhdC1ndWkgSmF2YVNjcmlwdCBDb250cm9sbGVyIExpYnJhcnlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9kYXQtZ3VpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ29weXJpZ2h0IDIwMTEgRGF0YSBBcnRzIFRlYW0sIEdvb2dsZSBDcmVhdGl2ZSBMYWJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblx0XG5cdHZhciBDb2xvciA9IGZ1bmN0aW9uICgpIHtcblx0ICBmdW5jdGlvbiBDb2xvcigpIHtcblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb2xvcik7XG5cdFxuXHQgICAgdGhpcy5fX3N0YXRlID0gX2ludGVycHJldDIuZGVmYXVsdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcblx0ICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IGZhbHNlKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGludGVycHJldCBjb2xvciBhcmd1bWVudHMnKTtcblx0ICAgIH1cblx0XG5cdCAgICB0aGlzLl9fc3RhdGUuYSA9IHRoaXMuX19zdGF0ZS5hIHx8IDE7XG5cdCAgfVxuXHRcblx0ICBDb2xvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0ICAgIHJldHVybiAoMCwgX3RvU3RyaW5nMi5kZWZhdWx0KSh0aGlzKTtcblx0ICB9O1xuXHRcblx0ICBDb2xvci5wcm90b3R5cGUudG9IZXhTdHJpbmcgPSBmdW5jdGlvbiB0b0hleFN0cmluZygpIHtcblx0ICAgIHJldHVybiAoMCwgX3RvU3RyaW5nMi5kZWZhdWx0KSh0aGlzLCB0cnVlKTtcblx0ICB9O1xuXHRcblx0ICBDb2xvci5wcm90b3R5cGUudG9PcmlnaW5hbCA9IGZ1bmN0aW9uIHRvT3JpZ2luYWwoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fX3N0YXRlLmNvbnZlcnNpb24ud3JpdGUodGhpcyk7XG5cdCAgfTtcblx0XG5cdCAgcmV0dXJuIENvbG9yO1xuXHR9KCk7XG5cdFxuXHRmdW5jdGlvbiBkZWZpbmVSR0JDb21wb25lbnQodGFyZ2V0LCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KSB7XG5cdCAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29tcG9uZW50LCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSA9PT0gJ1JHQicpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIENvbG9yLnJlY2FsY3VsYXRlUkdCKHRoaXMsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpO1xuXHRcblx0ICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuXHQgICAgfSxcblx0XG5cdCAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2KSB7XG5cdCAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdSR0InKSB7XG5cdCAgICAgICAgQ29sb3IucmVjYWxjdWxhdGVSR0IodGhpcywgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCk7XG5cdCAgICAgICAgdGhpcy5fX3N0YXRlLnNwYWNlID0gJ1JHQic7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdID0gdjtcblx0ICAgIH1cblx0ICB9KTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gZGVmaW5lSFNWQ29tcG9uZW50KHRhcmdldCwgY29tcG9uZW50KSB7XG5cdCAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29tcG9uZW50LCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSA9PT0gJ0hTVicpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIENvbG9yLnJlY2FsY3VsYXRlSFNWKHRoaXMpO1xuXHRcblx0ICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuXHQgICAgfSxcblx0XG5cdCAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2KSB7XG5cdCAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdIU1YnKSB7XG5cdCAgICAgICAgQ29sb3IucmVjYWxjdWxhdGVIU1YodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fX3N0YXRlLnNwYWNlID0gJ0hTVic7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdID0gdjtcblx0ICAgIH1cblx0ICB9KTtcblx0fVxuXHRcblx0Q29sb3IucmVjYWxjdWxhdGVSR0IgPSBmdW5jdGlvbiAoY29sb3IsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpIHtcblx0ICBpZiAoY29sb3IuX19zdGF0ZS5zcGFjZSA9PT0gJ0hFWCcpIHtcblx0ICAgIGNvbG9yLl9fc3RhdGVbY29tcG9uZW50XSA9IF9tYXRoMi5kZWZhdWx0LmNvbXBvbmVudF9mcm9tX2hleChjb2xvci5fX3N0YXRlLmhleCwgY29tcG9uZW50SGV4SW5kZXgpO1xuXHQgIH0gZWxzZSBpZiAoY29sb3IuX19zdGF0ZS5zcGFjZSA9PT0gJ0hTVicpIHtcblx0ICAgIF9jb21tb24yLmRlZmF1bHQuZXh0ZW5kKGNvbG9yLl9fc3RhdGUsIF9tYXRoMi5kZWZhdWx0Lmhzdl90b19yZ2IoY29sb3IuX19zdGF0ZS5oLCBjb2xvci5fX3N0YXRlLnMsIGNvbG9yLl9fc3RhdGUudikpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvcnJ1cHRlZCBjb2xvciBzdGF0ZScpO1xuXHQgIH1cblx0fTtcblx0XG5cdENvbG9yLnJlY2FsY3VsYXRlSFNWID0gZnVuY3Rpb24gKGNvbG9yKSB7XG5cdCAgdmFyIHJlc3VsdCA9IF9tYXRoMi5kZWZhdWx0LnJnYl90b19oc3YoY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG5cdFxuXHQgIF9jb21tb24yLmRlZmF1bHQuZXh0ZW5kKGNvbG9yLl9fc3RhdGUsIHtcblx0ICAgIHM6IHJlc3VsdC5zLFxuXHQgICAgdjogcmVzdWx0LnZcblx0ICB9KTtcblx0XG5cdCAgaWYgKCFfY29tbW9uMi5kZWZhdWx0LmlzTmFOKHJlc3VsdC5oKSkge1xuXHQgICAgY29sb3IuX19zdGF0ZS5oID0gcmVzdWx0Lmg7XG5cdCAgfSBlbHNlIGlmIChfY29tbW9uMi5kZWZhdWx0LmlzVW5kZWZpbmVkKGNvbG9yLl9fc3RhdGUuaCkpIHtcblx0ICAgIGNvbG9yLl9fc3RhdGUuaCA9IDA7XG5cdCAgfVxuXHR9O1xuXHRcblx0Q29sb3IuQ09NUE9ORU5UUyA9IFsncicsICdnJywgJ2InLCAnaCcsICdzJywgJ3YnLCAnaGV4JywgJ2EnXTtcblx0XG5cdGRlZmluZVJHQkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdyJywgMik7XG5cdGRlZmluZVJHQkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdnJywgMSk7XG5cdGRlZmluZVJHQkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdiJywgMCk7XG5cdFxuXHRkZWZpbmVIU1ZDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnaCcpO1xuXHRkZWZpbmVIU1ZDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAncycpO1xuXHRkZWZpbmVIU1ZDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAndicpO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yLnByb3RvdHlwZSwgJ2EnLCB7XG5cdCAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fX3N0YXRlLmE7XG5cdCAgfSxcblx0XG5cdCAgc2V0OiBmdW5jdGlvbiBzZXQodikge1xuXHQgICAgdGhpcy5fX3N0YXRlLmEgPSB2O1xuXHQgIH1cblx0fSk7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3IucHJvdG90eXBlLCAnaGV4Jywge1xuXHQgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgaWYgKCF0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdIRVgnKSB7XG5cdCAgICAgIHRoaXMuX19zdGF0ZS5oZXggPSBfbWF0aDIuZGVmYXVsdC5yZ2JfdG9faGV4KHRoaXMuciwgdGhpcy5nLCB0aGlzLmIpO1xuXHQgICAgfVxuXHRcblx0ICAgIHJldHVybiB0aGlzLl9fc3RhdGUuaGV4O1xuXHQgIH0sXG5cdFxuXHQgIHNldDogZnVuY3Rpb24gc2V0KHYpIHtcblx0ICAgIHRoaXMuX19zdGF0ZS5zcGFjZSA9ICdIRVgnO1xuXHQgICAgdGhpcy5fX3N0YXRlLmhleCA9IHY7XG5cdCAgfVxuXHR9KTtcblx0XG5cdGV4cG9ydHMuZGVmYXVsdCA9IENvbG9yO1xuXG4vKioqLyB9LFxuLyogMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblx0XG5cdHZhciBfdG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHRcblx0dmFyIF90b1N0cmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90b1N0cmluZyk7XG5cdFxuXHR2YXIgX2NvbW1vbiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdFxuXHR2YXIgX2NvbW1vbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21tb24pO1xuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblx0XG5cdC8qKlxuXHQgKiBkYXQtZ3VpIEphdmFTY3JpcHQgQ29udHJvbGxlciBMaWJyYXJ5XG5cdCAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9kYXQtZ3VpXG5cdCAqXG5cdCAqIENvcHlyaWdodCAyMDExIERhdGEgQXJ0cyBUZWFtLCBHb29nbGUgQ3JlYXRpdmUgTGFiXG5cdCAqXG5cdCAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG5cdCAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cblx0ICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cdCAqXG5cdCAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXHQgKi9cblx0XG5cdHZhciBJTlRFUlBSRVRBVElPTlMgPSBbXG5cdC8vIFN0cmluZ3Ncblx0e1xuXHQgIGxpdG11czogX2NvbW1vbjIuZGVmYXVsdC5pc1N0cmluZyxcblx0ICBjb252ZXJzaW9uczoge1xuXHQgICAgVEhSRUVfQ0hBUl9IRVg6IHtcblx0ICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuXHQgICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL14jKFtBLUYwLTldKShbQS1GMC05XSkoW0EtRjAtOV0pJC9pKTtcblx0ICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgIHNwYWNlOiAnSEVYJyxcblx0ICAgICAgICAgIGhleDogcGFyc2VJbnQoJzB4JyArIHRlc3RbMV0udG9TdHJpbmcoKSArIHRlc3RbMV0udG9TdHJpbmcoKSArIHRlc3RbMl0udG9TdHJpbmcoKSArIHRlc3RbMl0udG9TdHJpbmcoKSArIHRlc3RbM10udG9TdHJpbmcoKSArIHRlc3RbM10udG9TdHJpbmcoKSwgMClcblx0ICAgICAgICB9O1xuXHQgICAgICB9LFxuXHRcblx0ICAgICAgd3JpdGU6IF90b1N0cmluZzIuZGVmYXVsdFxuXHQgICAgfSxcblx0XG5cdCAgICBTSVhfQ0hBUl9IRVg6IHtcblx0ICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuXHQgICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL14jKFtBLUYwLTldezZ9KSQvaSk7XG5cdCAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHtcblx0ICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICBzcGFjZTogJ0hFWCcsXG5cdCAgICAgICAgICBoZXg6IHBhcnNlSW50KCcweCcgKyB0ZXN0WzFdLnRvU3RyaW5nKCksIDApXG5cdCAgICAgICAgfTtcblx0ICAgICAgfSxcblx0XG5cdCAgICAgIHdyaXRlOiBfdG9TdHJpbmcyLmRlZmF1bHRcblx0ICAgIH0sXG5cdFxuXHQgICAgQ1NTX1JHQjoge1xuXHQgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG5cdCAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXnJnYlxcKFxccyooLispXFxzKixcXHMqKC4rKVxccyosXFxzKiguKylcXHMqXFwpLyk7XG5cdCAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHtcblx0ICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICBzcGFjZTogJ1JHQicsXG5cdCAgICAgICAgICByOiBwYXJzZUZsb2F0KHRlc3RbMV0pLFxuXHQgICAgICAgICAgZzogcGFyc2VGbG9hdCh0ZXN0WzJdKSxcblx0ICAgICAgICAgIGI6IHBhcnNlRmxvYXQodGVzdFszXSlcblx0ICAgICAgICB9O1xuXHQgICAgICB9LFxuXHRcblx0ICAgICAgd3JpdGU6IF90b1N0cmluZzIuZGVmYXVsdFxuXHQgICAgfSxcblx0XG5cdCAgICBDU1NfUkdCQToge1xuXHQgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG5cdCAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXnJnYmFcXChcXHMqKC4rKVxccyosXFxzKiguKylcXHMqLFxccyooLispXFxzKixcXHMqKC4rKVxccypcXCkvKTtcblx0ICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgIHNwYWNlOiAnUkdCJyxcblx0ICAgICAgICAgIHI6IHBhcnNlRmxvYXQodGVzdFsxXSksXG5cdCAgICAgICAgICBnOiBwYXJzZUZsb2F0KHRlc3RbMl0pLFxuXHQgICAgICAgICAgYjogcGFyc2VGbG9hdCh0ZXN0WzNdKSxcblx0ICAgICAgICAgIGE6IHBhcnNlRmxvYXQodGVzdFs0XSlcblx0ICAgICAgICB9O1xuXHQgICAgICB9LFxuXHRcblx0ICAgICAgd3JpdGU6IF90b1N0cmluZzIuZGVmYXVsdFxuXHQgICAgfVxuXHQgIH1cblx0fSxcblx0XG5cdC8vIE51bWJlcnNcblx0e1xuXHQgIGxpdG11czogX2NvbW1vbjIuZGVmYXVsdC5pc051bWJlcixcblx0XG5cdCAgY29udmVyc2lvbnM6IHtcblx0XG5cdCAgICBIRVg6IHtcblx0ICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICBzcGFjZTogJ0hFWCcsXG5cdCAgICAgICAgICBoZXg6IG9yaWdpbmFsLFxuXHQgICAgICAgICAgY29udmVyc2lvbk5hbWU6ICdIRVgnXG5cdCAgICAgICAgfTtcblx0ICAgICAgfSxcblx0XG5cdCAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShjb2xvcikge1xuXHQgICAgICAgIHJldHVybiBjb2xvci5oZXg7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgfVxuXHRcblx0fSxcblx0XG5cdC8vIEFycmF5c1xuXHR7XG5cdCAgbGl0bXVzOiBfY29tbW9uMi5kZWZhdWx0LmlzQXJyYXksXG5cdCAgY29udmVyc2lvbnM6IHtcblx0ICAgIFJHQl9BUlJBWToge1xuXHQgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG5cdCAgICAgICAgaWYgKG9yaWdpbmFsLmxlbmd0aCAhPT0gMykge1xuXHQgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgIHNwYWNlOiAnUkdCJyxcblx0ICAgICAgICAgIHI6IG9yaWdpbmFsWzBdLFxuXHQgICAgICAgICAgZzogb3JpZ2luYWxbMV0sXG5cdCAgICAgICAgICBiOiBvcmlnaW5hbFsyXVxuXHQgICAgICAgIH07XG5cdCAgICAgIH0sXG5cdFxuXHQgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY29sb3IpIHtcblx0ICAgICAgICByZXR1cm4gW2NvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmJdO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHRcblx0ICAgIFJHQkFfQVJSQVk6IHtcblx0ICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuXHQgICAgICAgIGlmIChvcmlnaW5hbC5sZW5ndGggIT09IDQpIHJldHVybiBmYWxzZTtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgc3BhY2U6ICdSR0InLFxuXHQgICAgICAgICAgcjogb3JpZ2luYWxbMF0sXG5cdCAgICAgICAgICBnOiBvcmlnaW5hbFsxXSxcblx0ICAgICAgICAgIGI6IG9yaWdpbmFsWzJdLFxuXHQgICAgICAgICAgYTogb3JpZ2luYWxbM11cblx0ICAgICAgICB9O1xuXHQgICAgICB9LFxuXHRcblx0ICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKGNvbG9yKSB7XG5cdCAgICAgICAgcmV0dXJuIFtjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iLCBjb2xvci5hXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fSxcblx0XG5cdC8vIE9iamVjdHNcblx0e1xuXHQgIGxpdG11czogX2NvbW1vbjIuZGVmYXVsdC5pc09iamVjdCxcblx0ICBjb252ZXJzaW9uczoge1xuXHRcblx0ICAgIFJHQkFfT0JKOiB7XG5cdCAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcblx0ICAgICAgICBpZiAoX2NvbW1vbjIuZGVmYXVsdC5pc051bWJlcihvcmlnaW5hbC5yKSAmJiBfY29tbW9uMi5kZWZhdWx0LmlzTnVtYmVyKG9yaWdpbmFsLmcpICYmIF9jb21tb24yLmRlZmF1bHQuaXNOdW1iZXIob3JpZ2luYWwuYikgJiYgX2NvbW1vbjIuZGVmYXVsdC5pc051bWJlcihvcmlnaW5hbC5hKSkge1xuXHQgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuXHQgICAgICAgICAgICByOiBvcmlnaW5hbC5yLFxuXHQgICAgICAgICAgICBnOiBvcmlnaW5hbC5nLFxuXHQgICAgICAgICAgICBiOiBvcmlnaW5hbC5iLFxuXHQgICAgICAgICAgICBhOiBvcmlnaW5hbC5hXG5cdCAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgIH0sXG5cdFxuXHQgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY29sb3IpIHtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgcjogY29sb3Iucixcblx0ICAgICAgICAgIGc6IGNvbG9yLmcsXG5cdCAgICAgICAgICBiOiBjb2xvci5iLFxuXHQgICAgICAgICAgYTogY29sb3IuYVxuXHQgICAgICAgIH07XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdFxuXHQgICAgUkdCX09CSjoge1xuXHQgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG5cdCAgICAgICAgaWYgKF9jb21tb24yLmRlZmF1bHQuaXNOdW1iZXIob3JpZ2luYWwucikgJiYgX2NvbW1vbjIuZGVmYXVsdC5pc051bWJlcihvcmlnaW5hbC5nKSAmJiBfY29tbW9uMi5kZWZhdWx0LmlzTnVtYmVyKG9yaWdpbmFsLmIpKSB7XG5cdCAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG5cdCAgICAgICAgICAgIHI6IG9yaWdpbmFsLnIsXG5cdCAgICAgICAgICAgIGc6IG9yaWdpbmFsLmcsXG5cdCAgICAgICAgICAgIGI6IG9yaWdpbmFsLmJcblx0ICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgfSxcblx0XG5cdCAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShjb2xvcikge1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICByOiBjb2xvci5yLFxuXHQgICAgICAgICAgZzogY29sb3IuZyxcblx0ICAgICAgICAgIGI6IGNvbG9yLmJcblx0ICAgICAgICB9O1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHRcblx0ICAgIEhTVkFfT0JKOiB7XG5cdCAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcblx0ICAgICAgICBpZiAoX2NvbW1vbjIuZGVmYXVsdC5pc051bWJlcihvcmlnaW5hbC5oKSAmJiBfY29tbW9uMi5kZWZhdWx0LmlzTnVtYmVyKG9yaWdpbmFsLnMpICYmIF9jb21tb24yLmRlZmF1bHQuaXNOdW1iZXIob3JpZ2luYWwudikgJiYgX2NvbW1vbjIuZGVmYXVsdC5pc051bWJlcihvcmlnaW5hbC5hKSkge1xuXHQgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgc3BhY2U6ICdIU1YnLFxuXHQgICAgICAgICAgICBoOiBvcmlnaW5hbC5oLFxuXHQgICAgICAgICAgICBzOiBvcmlnaW5hbC5zLFxuXHQgICAgICAgICAgICB2OiBvcmlnaW5hbC52LFxuXHQgICAgICAgICAgICBhOiBvcmlnaW5hbC5hXG5cdCAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgIH0sXG5cdFxuXHQgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY29sb3IpIHtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgaDogY29sb3IuaCxcblx0ICAgICAgICAgIHM6IGNvbG9yLnMsXG5cdCAgICAgICAgICB2OiBjb2xvci52LFxuXHQgICAgICAgICAgYTogY29sb3IuYVxuXHQgICAgICAgIH07XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdFxuXHQgICAgSFNWX09CSjoge1xuXHQgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG5cdCAgICAgICAgaWYgKF9jb21tb24yLmRlZmF1bHQuaXNOdW1iZXIob3JpZ2luYWwuaCkgJiYgX2NvbW1vbjIuZGVmYXVsdC5pc051bWJlcihvcmlnaW5hbC5zKSAmJiBfY29tbW9uMi5kZWZhdWx0LmlzTnVtYmVyKG9yaWdpbmFsLnYpKSB7XG5cdCAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBzcGFjZTogJ0hTVicsXG5cdCAgICAgICAgICAgIGg6IG9yaWdpbmFsLmgsXG5cdCAgICAgICAgICAgIHM6IG9yaWdpbmFsLnMsXG5cdCAgICAgICAgICAgIHY6IG9yaWdpbmFsLnZcblx0ICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgfSxcblx0XG5cdCAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShjb2xvcikge1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICBoOiBjb2xvci5oLFxuXHQgICAgICAgICAgczogY29sb3Iucyxcblx0ICAgICAgICAgIHY6IGNvbG9yLnZcblx0ICAgICAgICB9O1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHR9XTtcblx0XG5cdHZhciByZXN1bHQgPSB2b2lkIDA7XG5cdHZhciB0b1JldHVybiA9IHZvaWQgMDtcblx0XG5cdHZhciBpbnRlcnByZXQgPSBmdW5jdGlvbiBpbnRlcnByZXQoKSB7XG5cdCAgdG9SZXR1cm4gPSBmYWxzZTtcblx0XG5cdCAgdmFyIG9yaWdpbmFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBfY29tbW9uMi5kZWZhdWx0LnRvQXJyYXkoYXJndW1lbnRzKSA6IGFyZ3VtZW50c1swXTtcblx0ICBfY29tbW9uMi5kZWZhdWx0LmVhY2goSU5URVJQUkVUQVRJT05TLCBmdW5jdGlvbiAoZmFtaWx5KSB7XG5cdCAgICBpZiAoZmFtaWx5LmxpdG11cyhvcmlnaW5hbCkpIHtcblx0ICAgICAgX2NvbW1vbjIuZGVmYXVsdC5lYWNoKGZhbWlseS5jb252ZXJzaW9ucywgZnVuY3Rpb24gKGNvbnZlcnNpb24sIGNvbnZlcnNpb25OYW1lKSB7XG5cdCAgICAgICAgcmVzdWx0ID0gY29udmVyc2lvbi5yZWFkKG9yaWdpbmFsKTtcblx0XG5cdCAgICAgICAgaWYgKHRvUmV0dXJuID09PSBmYWxzZSAmJiByZXN1bHQgIT09IGZhbHNlKSB7XG5cdCAgICAgICAgICB0b1JldHVybiA9IHJlc3VsdDtcblx0ICAgICAgICAgIHJlc3VsdC5jb252ZXJzaW9uTmFtZSA9IGNvbnZlcnNpb25OYW1lO1xuXHQgICAgICAgICAgcmVzdWx0LmNvbnZlcnNpb24gPSBjb252ZXJzaW9uO1xuXHQgICAgICAgICAgcmV0dXJuIF9jb21tb24yLmRlZmF1bHQuQlJFQUs7XG5cdCAgICAgICAgfVxuXHQgICAgICB9KTtcblx0XG5cdCAgICAgIHJldHVybiBfY29tbW9uMi5kZWZhdWx0LkJSRUFLO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICByZXR1cm4gdG9SZXR1cm47XG5cdH07XG5cdFxuXHRleHBvcnRzLmRlZmF1bHQgPSBpbnRlcnByZXQ7XG5cbi8qKiovIH0sXG4vKiA0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGNvbG9yLCBmb3JjZUNTU0hleCkge1xuXHQgIHZhciBjb2xvckZvcm1hdCA9IGNvbG9yLl9fc3RhdGUuY29udmVyc2lvbk5hbWUudG9TdHJpbmcoKTtcblx0XG5cdCAgdmFyIHIgPSBNYXRoLnJvdW5kKGNvbG9yLnIpO1xuXHQgIHZhciBnID0gTWF0aC5yb3VuZChjb2xvci5nKTtcblx0ICB2YXIgYiA9IE1hdGgucm91bmQoY29sb3IuYik7XG5cdCAgdmFyIGEgPSBjb2xvci5hO1xuXHQgIHZhciBoID0gTWF0aC5yb3VuZChjb2xvci5oKTtcblx0ICB2YXIgcyA9IGNvbG9yLnMudG9GaXhlZCgxKTtcblx0ICB2YXIgdiA9IGNvbG9yLnYudG9GaXhlZCgxKTtcblx0XG5cdCAgaWYgKGZvcmNlQ1NTSGV4IHx8IGNvbG9yRm9ybWF0ID09PSAnVEhSRUVfQ0hBUl9IRVgnIHx8IGNvbG9yRm9ybWF0ID09PSAnU0lYX0NIQVJfSEVYJykge1xuXHQgICAgdmFyIHN0ciA9IGNvbG9yLmhleC50b1N0cmluZygxNik7XG5cdCAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IDYpIHtcblx0ICAgICAgc3RyID0gJzAnICsgc3RyO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuICcjJyArIHN0cjtcblx0ICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnQ1NTX1JHQicpIHtcblx0ICAgIHJldHVybiAncmdiKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnKSc7XG5cdCAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ0NTU19SR0JBJykge1xuXHQgICAgcmV0dXJuICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xuXHQgIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdIRVgnKSB7XG5cdCAgICByZXR1cm4gJzB4JyArIGNvbG9yLmhleC50b1N0cmluZygxNik7XG5cdCAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ1JHQl9BUlJBWScpIHtcblx0ICAgIHJldHVybiAnWycgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnXSc7XG5cdCAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ1JHQkFfQVJSQVknKSB7XG5cdCAgICByZXR1cm4gJ1snICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICddJztcblx0ICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnUkdCX09CSicpIHtcblx0ICAgIHJldHVybiAne3I6JyArIHIgKyAnLGc6JyArIGcgKyAnLGI6JyArIGIgKyAnfSc7XG5cdCAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ1JHQkFfT0JKJykge1xuXHQgICAgcmV0dXJuICd7cjonICsgciArICcsZzonICsgZyArICcsYjonICsgYiArICcsYTonICsgYSArICd9Jztcblx0ICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnSFNWX09CSicpIHtcblx0ICAgIHJldHVybiAne2g6JyArIGggKyAnLHM6JyArIHMgKyAnLHY6JyArIHYgKyAnfSc7XG5cdCAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ0hTVkFfT0JKJykge1xuXHQgICAgcmV0dXJuICd7aDonICsgaCArICcsczonICsgcyArICcsdjonICsgdiArICcsYTonICsgYSArICd9Jztcblx0ICB9XG5cdFxuXHQgIHJldHVybiAndW5rbm93biBmb3JtYXQnO1xuXHR9O1xuXG4vKioqLyB9LFxuLyogNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblx0LyoqXG5cdCAqIGRhdC1ndWkgSmF2YVNjcmlwdCBDb250cm9sbGVyIExpYnJhcnlcblx0ICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2RhdC1ndWlcblx0ICpcblx0ICogQ29weXJpZ2h0IDIwMTEgRGF0YSBBcnRzIFRlYW0sIEdvb2dsZSBDcmVhdGl2ZSBMYWJcblx0ICpcblx0ICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcblx0ICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuXHQgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblx0ICpcblx0ICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cdCAqL1xuXHRcblx0dmFyIEFSUl9FQUNIID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2g7XG5cdHZhciBBUlJfU0xJQ0UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cdFxuXHQvKipcblx0ICogQmFuZC1haWQgbWV0aG9kcyBmb3IgdGhpbmdzIHRoYXQgc2hvdWxkIGJlIGEgbG90IGVhc2llciBpbiBKYXZhU2NyaXB0LlxuXHQgKiBJbXBsZW1lbnRhdGlvbiBhbmQgc3RydWN0dXJlIGluc3BpcmVkIGJ5IHVuZGVyc2NvcmUuanNcblx0ICogaHR0cDovL2RvY3VtZW50Y2xvdWQuZ2l0aHViLmNvbS91bmRlcnNjb3JlL1xuXHQgKi9cblx0XG5cdHZhciBDb21tb24gPSB7XG5cdCAgQlJFQUs6IHt9LFxuXHRcblx0ICBleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQpIHtcblx0ICAgIHRoaXMuZWFjaChBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgIHZhciBrZXlzID0gdGhpcy5pc09iamVjdChvYmopID8gT2JqZWN0LmtleXMob2JqKSA6IFtdO1xuXHQgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgIGlmICghdGhpcy5pc1VuZGVmaW5lZChvYmpba2V5XSkpIHtcblx0ICAgICAgICAgIHRhcmdldFtrZXldID0gb2JqW2tleV07XG5cdCAgICAgICAgfVxuXHQgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgfSwgdGhpcyk7XG5cdFxuXHQgICAgcmV0dXJuIHRhcmdldDtcblx0ICB9LFxuXHRcblx0ICBkZWZhdWx0czogZnVuY3Rpb24gZGVmYXVsdHModGFyZ2V0KSB7XG5cdCAgICB0aGlzLmVhY2goQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICB2YXIga2V5cyA9IHRoaXMuaXNPYmplY3Qob2JqKSA/IE9iamVjdC5rZXlzKG9iaikgOiBbXTtcblx0ICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICBpZiAodGhpcy5pc1VuZGVmaW5lZCh0YXJnZXRba2V5XSkpIHtcblx0ICAgICAgICAgIHRhcmdldFtrZXldID0gb2JqW2tleV07XG5cdCAgICAgICAgfVxuXHQgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgfSwgdGhpcyk7XG5cdFxuXHQgICAgcmV0dXJuIHRhcmdldDtcblx0ICB9LFxuXHRcblx0ICBjb21wb3NlOiBmdW5jdGlvbiBjb21wb3NlKCkge1xuXHQgICAgdmFyIHRvQ2FsbCA9IEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cyk7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgICB2YXIgYXJncyA9IEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cyk7XG5cdCAgICAgIGZvciAodmFyIGkgPSB0b0NhbGwubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgICBhcmdzID0gW3RvQ2FsbFtpXS5hcHBseSh0aGlzLCBhcmdzKV07XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGFyZ3NbMF07XG5cdCAgICB9O1xuXHQgIH0sXG5cdFxuXHQgIGVhY2g6IGZ1bmN0aW9uIGVhY2gob2JqLCBpdHIsIHNjb3BlKSB7XG5cdCAgICBpZiAoIW9iaikge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdFxuXHQgICAgaWYgKEFSUl9FQUNIICYmIG9iai5mb3JFYWNoICYmIG9iai5mb3JFYWNoID09PSBBUlJfRUFDSCkge1xuXHQgICAgICBvYmouZm9yRWFjaChpdHIsIHNjb3BlKTtcblx0ICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gb2JqLmxlbmd0aCArIDApIHtcblx0ICAgICAgLy8gSXMgbnVtYmVyIGJ1dCBub3QgTmFOXG5cdCAgICAgIHZhciBrZXkgPSB2b2lkIDA7XG5cdCAgICAgIHZhciBsID0gdm9pZCAwO1xuXHQgICAgICBmb3IgKGtleSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBrZXkgPCBsOyBrZXkrKykge1xuXHQgICAgICAgIGlmIChrZXkgaW4gb2JqICYmIGl0ci5jYWxsKHNjb3BlLCBvYmpba2V5XSwga2V5KSA9PT0gdGhpcy5CUkVBSykge1xuXHQgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZm9yICh2YXIgX2tleSBpbiBvYmopIHtcblx0ICAgICAgICBpZiAoaXRyLmNhbGwoc2NvcGUsIG9ialtfa2V5XSwgX2tleSkgPT09IHRoaXMuQlJFQUspIHtcblx0ICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHRcblx0ICBkZWZlcjogZnVuY3Rpb24gZGVmZXIoZm5jKSB7XG5cdCAgICBzZXRUaW1lb3V0KGZuYywgMCk7XG5cdCAgfSxcblx0XG5cdCAgLy8gY2FsbCB0aGUgZnVuY3Rpb24gaW1tZWRpYXRlbHksIGJ1dCB3YWl0IHVudGlsIHRocmVzaG9sZCBwYXNzZXMgdG8gYWxsb3cgaXQgdG8gYmUgY2FsbGVkIGFnYWluXG5cdCAgZGVib3VuY2U6IGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHRocmVzaG9sZCkge1xuXHQgICAgdmFyIHRpbWVvdXQgPSB2b2lkIDA7XG5cdFxuXHQgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIG9iaiA9IHRoaXM7XG5cdCAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuXHQgICAgICBmdW5jdGlvbiBkZWxheWVkKCkge1xuXHQgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICB2YXIgYWxsb3dDYWxsID0gIXRpbWVvdXQ7XG5cdFxuXHQgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdCAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIHRocmVzaG9sZCk7XG5cdFxuXHQgICAgICBpZiAoYWxsb3dDYWxsKSB7XG5cdCAgICAgICAgZnVuYy5hcHBseShvYmosIGFyZ3MpO1xuXHQgICAgICB9XG5cdCAgICB9O1xuXHQgIH0sXG5cdFxuXHQgIHRvQXJyYXk6IGZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG5cdCAgICBpZiAob2JqLnRvQXJyYXkpIHJldHVybiBvYmoudG9BcnJheSgpO1xuXHQgICAgcmV0dXJuIEFSUl9TTElDRS5jYWxsKG9iaik7XG5cdCAgfSxcblx0XG5cdCAgaXNVbmRlZmluZWQ6IGZ1bmN0aW9uIGlzVW5kZWZpbmVkKG9iaikge1xuXHQgICAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkO1xuXHQgIH0sXG5cdFxuXHQgIGlzTnVsbDogZnVuY3Rpb24gaXNOdWxsKG9iaikge1xuXHQgICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcblx0ICB9LFxuXHRcblx0ICBpc05hTjogZnVuY3Rpb24gKF9pc05hTikge1xuXHQgICAgZnVuY3Rpb24gaXNOYU4oX3gpIHtcblx0ICAgICAgcmV0dXJuIF9pc05hTi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgfVxuXHRcblx0ICAgIGlzTmFOLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gX2lzTmFOLnRvU3RyaW5nKCk7XG5cdCAgICB9O1xuXHRcblx0ICAgIHJldHVybiBpc05hTjtcblx0ICB9KGZ1bmN0aW9uIChvYmopIHtcblx0ICAgIHJldHVybiBpc05hTihvYmopO1xuXHQgIH0pLFxuXHRcblx0ICBpc0FycmF5OiBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChvYmopIHtcblx0ICAgIHJldHVybiBvYmouY29uc3RydWN0b3IgPT09IEFycmF5O1xuXHQgIH0sXG5cdFxuXHQgIGlzT2JqZWN0OiBmdW5jdGlvbiBpc09iamVjdChvYmopIHtcblx0ICAgIHJldHVybiBvYmogPT09IE9iamVjdChvYmopO1xuXHQgIH0sXG5cdFxuXHQgIGlzTnVtYmVyOiBmdW5jdGlvbiBpc051bWJlcihvYmopIHtcblx0ICAgIHJldHVybiBvYmogPT09IG9iaiArIDA7XG5cdCAgfSxcblx0XG5cdCAgaXNTdHJpbmc6IGZ1bmN0aW9uIGlzU3RyaW5nKG9iaikge1xuXHQgICAgcmV0dXJuIG9iaiA9PT0gb2JqICsgJyc7XG5cdCAgfSxcblx0XG5cdCAgaXNCb29sZWFuOiBmdW5jdGlvbiBpc0Jvb2xlYW4ob2JqKSB7XG5cdCAgICByZXR1cm4gb2JqID09PSBmYWxzZSB8fCBvYmogPT09IHRydWU7XG5cdCAgfSxcblx0XG5cdCAgaXNGdW5jdGlvbjogZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcblx0ICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblx0ICB9XG5cdFxuXHR9O1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gQ29tbW9uO1xuXG4vKioqLyB9LFxuLyogNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHQvKipcblx0ICogZGF0LWd1aSBKYXZhU2NyaXB0IENvbnRyb2xsZXIgTGlicmFyeVxuXHQgKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZGF0LWd1aVxuXHQgKlxuXHQgKiBDb3B5cmlnaHQgMjAxMSBEYXRhIEFydHMgVGVhbSwgR29vZ2xlIENyZWF0aXZlIExhYlxuXHQgKlxuXHQgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuXHQgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5cdCAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXHQgKlxuXHQgKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblx0ICovXG5cdFxuXHR2YXIgdG1wQ29tcG9uZW50ID0gdm9pZCAwO1xuXHRcblx0dmFyIENvbG9yTWF0aCA9IHtcblx0ICBoc3ZfdG9fcmdiOiBmdW5jdGlvbiBoc3ZfdG9fcmdiKGgsIHMsIHYpIHtcblx0ICAgIHZhciBoaSA9IE1hdGguZmxvb3IoaCAvIDYwKSAlIDY7XG5cdFxuXHQgICAgdmFyIGYgPSBoIC8gNjAgLSBNYXRoLmZsb29yKGggLyA2MCk7XG5cdCAgICB2YXIgcCA9IHYgKiAoMS4wIC0gcyk7XG5cdCAgICB2YXIgcSA9IHYgKiAoMS4wIC0gZiAqIHMpO1xuXHQgICAgdmFyIHQgPSB2ICogKDEuMCAtICgxLjAgLSBmKSAqIHMpO1xuXHRcblx0ICAgIHZhciBjID0gW1t2LCB0LCBwXSwgW3EsIHYsIHBdLCBbcCwgdiwgdF0sIFtwLCBxLCB2XSwgW3QsIHAsIHZdLCBbdiwgcCwgcV1dW2hpXTtcblx0XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICByOiBjWzBdICogMjU1LFxuXHQgICAgICBnOiBjWzFdICogMjU1LFxuXHQgICAgICBiOiBjWzJdICogMjU1XG5cdCAgICB9O1xuXHQgIH0sXG5cdFxuXHQgIHJnYl90b19oc3Y6IGZ1bmN0aW9uIHJnYl90b19oc3YociwgZywgYikge1xuXHQgICAgdmFyIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuXHQgICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuXHQgICAgdmFyIGRlbHRhID0gbWF4IC0gbWluO1xuXHQgICAgdmFyIGggPSB2b2lkIDA7XG5cdCAgICB2YXIgcyA9IHZvaWQgMDtcblx0XG5cdCAgICBpZiAobWF4ICE9PSAwKSB7XG5cdCAgICAgIHMgPSBkZWx0YSAvIG1heDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiB7XG5cdCAgICAgICAgaDogTmFOLFxuXHQgICAgICAgIHM6IDAsXG5cdCAgICAgICAgdjogMFxuXHQgICAgICB9O1xuXHQgICAgfVxuXHRcblx0ICAgIGlmIChyID09PSBtYXgpIHtcblx0ICAgICAgaCA9IChnIC0gYikgLyBkZWx0YTtcblx0ICAgIH0gZWxzZSBpZiAoZyA9PT0gbWF4KSB7XG5cdCAgICAgIGggPSAyICsgKGIgLSByKSAvIGRlbHRhO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaCA9IDQgKyAociAtIGcpIC8gZGVsdGE7XG5cdCAgICB9XG5cdCAgICBoIC89IDY7XG5cdCAgICBpZiAoaCA8IDApIHtcblx0ICAgICAgaCArPSAxO1xuXHQgICAgfVxuXHRcblx0ICAgIHJldHVybiB7XG5cdCAgICAgIGg6IGggKiAzNjAsXG5cdCAgICAgIHM6IHMsXG5cdCAgICAgIHY6IG1heCAvIDI1NVxuXHQgICAgfTtcblx0ICB9LFxuXHRcblx0ICByZ2JfdG9faGV4OiBmdW5jdGlvbiByZ2JfdG9faGV4KHIsIGcsIGIpIHtcblx0ICAgIHZhciBoZXggPSB0aGlzLmhleF93aXRoX2NvbXBvbmVudCgwLCAyLCByKTtcblx0ICAgIGhleCA9IHRoaXMuaGV4X3dpdGhfY29tcG9uZW50KGhleCwgMSwgZyk7XG5cdCAgICBoZXggPSB0aGlzLmhleF93aXRoX2NvbXBvbmVudChoZXgsIDAsIGIpO1xuXHQgICAgcmV0dXJuIGhleDtcblx0ICB9LFxuXHRcblx0ICBjb21wb25lbnRfZnJvbV9oZXg6IGZ1bmN0aW9uIGNvbXBvbmVudF9mcm9tX2hleChoZXgsIGNvbXBvbmVudEluZGV4KSB7XG5cdCAgICByZXR1cm4gaGV4ID4+IGNvbXBvbmVudEluZGV4ICogOCAmIDB4RkY7XG5cdCAgfSxcblx0XG5cdCAgaGV4X3dpdGhfY29tcG9uZW50OiBmdW5jdGlvbiBoZXhfd2l0aF9jb21wb25lbnQoaGV4LCBjb21wb25lbnRJbmRleCwgdmFsdWUpIHtcblx0ICAgIHJldHVybiB2YWx1ZSA8PCAodG1wQ29tcG9uZW50ID0gY29tcG9uZW50SW5kZXggKiA4KSB8IGhleCAmIH4oMHhGRiA8PCB0bXBDb21wb25lbnQpO1xuXHQgIH1cblx0fTtcblx0XG5cdGV4cG9ydHMuZGVmYXVsdCA9IENvbG9yTWF0aDtcblxuLyoqKi8gfSxcbi8qIDcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXHRcblx0LyoqXG5cdCAqIGRhdC1ndWkgSmF2YVNjcmlwdCBDb250cm9sbGVyIExpYnJhcnlcblx0ICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2RhdC1ndWlcblx0ICpcblx0ICogQ29weXJpZ2h0IDIwMTEgRGF0YSBBcnRzIFRlYW0sIEdvb2dsZSBDcmVhdGl2ZSBMYWJcblx0ICpcblx0ICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcblx0ICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuXHQgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblx0ICpcblx0ICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cdCAqL1xuXHRcblx0LyoqXG5cdCAqIEBjbGFzcyBBbiBcImFic3RyYWN0XCIgY2xhc3MgdGhhdCByZXByZXNlbnRzIGEgZ2l2ZW4gcHJvcGVydHkgb2YgYW4gb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmUgbWFuaXB1bGF0ZWRcblx0ICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBtYW5pcHVsYXRlZFxuXHQgKlxuXHQgKiBAbWVtYmVyIGRhdC5jb250cm9sbGVyc1xuXHQgKi9cblx0dmFyIENvbnRyb2xsZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgZnVuY3Rpb24gQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KSB7XG5cdCAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29udHJvbGxlcik7XG5cdFxuXHQgICAgdGhpcy5pbml0aWFsVmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVGhvc2Ugd2hvIGV4dGVuZCB0aGlzIGNsYXNzIHdpbGwgcHV0IHRoZWlyIERPTSBlbGVtZW50cyBpbiBoZXJlLlxuXHQgICAgICogQHR5cGUge0RPTUVsZW1lbnR9XG5cdCAgICAgKi9cblx0ICAgIHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVGhlIG9iamVjdCB0byBtYW5pcHVsYXRlXG5cdCAgICAgKiBAdHlwZSB7T2JqZWN0fVxuXHQgICAgICovXG5cdCAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcblx0XG5cdCAgICAvKipcblx0ICAgICAqIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBtYW5pcHVsYXRlXG5cdCAgICAgKiBAdHlwZSB7U3RyaW5nfVxuXHQgICAgICovXG5cdCAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGNoYW5nZS5cblx0ICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cblx0ICAgICAqIEBpZ25vcmVcblx0ICAgICAqL1xuXHQgICAgdGhpcy5fX29uQ2hhbmdlID0gdW5kZWZpbmVkO1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBmaW5pc2hpbmcgY2hhbmdlLlxuXHQgICAgICogQHR5cGUge0Z1bmN0aW9ufVxuXHQgICAgICogQGlnbm9yZVxuXHQgICAgICovXG5cdCAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UgPSB1bmRlZmluZWQ7XG5cdCAgfVxuXHRcblx0ICAvKipcblx0ICAgKiBTcGVjaWZ5IHRoYXQgYSBmdW5jdGlvbiBmaXJlIGV2ZXJ5IHRpbWUgc29tZW9uZSBjaGFuZ2VzIHRoZSB2YWx1ZSB3aXRoXG5cdCAgICogdGhpcyBDb250cm9sbGVyLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5jIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIHZhbHVlXG5cdCAgICogaXMgbW9kaWZpZWQgdmlhIHRoaXMgQ29udHJvbGxlci5cblx0ICAgKiBAcmV0dXJucyB7Q29udHJvbGxlcn0gdGhpc1xuXHQgICAqL1xuXHRcblx0XG5cdCAgQ29udHJvbGxlci5wcm90b3R5cGUub25DaGFuZ2UgPSBmdW5jdGlvbiBvbkNoYW5nZShmbmMpIHtcblx0ICAgIHRoaXMuX19vbkNoYW5nZSA9IGZuYztcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdFxuXHQgIC8qKlxuXHQgICAqIFNwZWNpZnkgdGhhdCBhIGZ1bmN0aW9uIGZpcmUgZXZlcnkgdGltZSBzb21lb25lIFwiZmluaXNoZXNcIiBjaGFuZ2luZ1xuXHQgICAqIHRoZSB2YWx1ZSB3aWggdGhpcyBDb250cm9sbGVyLiBVc2VmdWwgZm9yIHZhbHVlcyB0aGF0IGNoYW5nZVxuXHQgICAqIGluY3JlbWVudGFsbHkgbGlrZSBudW1iZXJzIG9yIHN0cmluZ3MuXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbmMgVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlclxuXHQgICAqIHNvbWVvbmUgXCJmaW5pc2hlc1wiIGNoYW5naW5nIHRoZSB2YWx1ZSB2aWEgdGhpcyBDb250cm9sbGVyLlxuXHQgICAqIEByZXR1cm5zIHtDb250cm9sbGVyfSB0aGlzXG5cdCAgICovXG5cdFxuXHRcblx0ICBDb250cm9sbGVyLnByb3RvdHlwZS5vbkZpbmlzaENoYW5nZSA9IGZ1bmN0aW9uIG9uRmluaXNoQ2hhbmdlKGZuYykge1xuXHQgICAgdGhpcy5fX29uRmluaXNoQ2hhbmdlID0gZm5jO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0XG5cdCAgLyoqXG5cdCAgICogQ2hhbmdlIHRoZSB2YWx1ZSBvZiA8Y29kZT5vYmplY3RbcHJvcGVydHldPC9jb2RlPlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtPYmplY3R9IG5ld1ZhbHVlIFRoZSBuZXcgdmFsdWUgb2YgPGNvZGU+b2JqZWN0W3Byb3BlcnR5XTwvY29kZT5cblx0ICAgKi9cblx0XG5cdFxuXHQgIENvbnRyb2xsZXIucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gc2V0VmFsdWUobmV3VmFsdWUpIHtcblx0ICAgIHRoaXMub2JqZWN0W3RoaXMucHJvcGVydHldID0gbmV3VmFsdWU7XG5cdCAgICBpZiAodGhpcy5fX29uQ2hhbmdlKSB7XG5cdCAgICAgIHRoaXMuX19vbkNoYW5nZS5jYWxsKHRoaXMsIG5ld1ZhbHVlKTtcblx0ICAgIH1cblx0XG5cdCAgICB0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdFxuXHQgIC8qKlxuXHQgICAqIEdldHMgdGhlIHZhbHVlIG9mIDxjb2RlPm9iamVjdFtwcm9wZXJ0eV08L2NvZGU+XG5cdCAgICpcblx0ICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgY3VycmVudCB2YWx1ZSBvZiA8Y29kZT5vYmplY3RbcHJvcGVydHldPC9jb2RlPlxuXHQgICAqL1xuXHRcblx0XG5cdCAgQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcblx0ICAgIHJldHVybiB0aGlzLm9iamVjdFt0aGlzLnByb3BlcnR5XTtcblx0ICB9O1xuXHRcblx0ICAvKipcblx0ICAgKiBSZWZyZXNoZXMgdGhlIHZpc3VhbCBkaXNwbGF5IG9mIGEgQ29udHJvbGxlciBpbiBvcmRlciB0byBrZWVwIHN5bmNcblx0ICAgKiB3aXRoIHRoZSBvYmplY3QncyBjdXJyZW50IHZhbHVlLlxuXHQgICAqIEByZXR1cm5zIHtDb250cm9sbGVyfSB0aGlzXG5cdCAgICovXG5cdFxuXHRcblx0ICBDb250cm9sbGVyLnByb3RvdHlwZS51cGRhdGVEaXNwbGF5ID0gZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdFxuXHQgIC8qKlxuXHQgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSB2YWx1ZSBoYXMgZGV2aWF0ZWQgZnJvbSBpbml0aWFsVmFsdWVcblx0ICAgKi9cblx0XG5cdFxuXHQgIENvbnRyb2xsZXIucHJvdG90eXBlLmlzTW9kaWZpZWQgPSBmdW5jdGlvbiBpc01vZGlmaWVkKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuaW5pdGlhbFZhbHVlICE9PSB0aGlzLmdldFZhbHVlKCk7XG5cdCAgfTtcblx0XG5cdCAgcmV0dXJuIENvbnRyb2xsZXI7XG5cdH0oKTtcblx0XG5cdGV4cG9ydHMuZGVmYXVsdCA9IENvbnRyb2xsZXI7XG5cbi8qKiovIH0sXG4vKiA4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHRcblx0dmFyIF9Db250cm9sbGVyMiA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cdFxuXHR2YXIgX0NvbnRyb2xsZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ29udHJvbGxlcjIpO1xuXHRcblx0dmFyIF9kb20gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXHRcblx0dmFyIF9kb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZG9tKTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXHRcblx0ZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cdFxuXHRmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLyoqXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGRhdC1ndWkgSmF2YVNjcmlwdCBDb250cm9sbGVyIExpYnJhcnlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2RhdC1ndWlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ29weXJpZ2h0IDIwMTEgRGF0YSBBcnRzIFRlYW0sIEdvb2dsZSBDcmVhdGl2ZSBMYWJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXHRcblx0LyoqXG5cdCAqIEBjbGFzcyBQcm92aWRlcyBhIGNoZWNrYm94IGlucHV0IHRvIGFsdGVyIHRoZSBib29sZWFuIHByb3BlcnR5IG9mIGFuIG9iamVjdC5cblx0ICogQGV4dGVuZHMgZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJlIG1hbmlwdWxhdGVkXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgbWFuaXB1bGF0ZWRcblx0ICpcblx0ICogQG1lbWJlciBkYXQuY29udHJvbGxlcnNcblx0ICovXG5cdHZhciBCb29sZWFuQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfQ29udHJvbGxlcikge1xuXHQgIF9pbmhlcml0cyhCb29sZWFuQ29udHJvbGxlciwgX0NvbnRyb2xsZXIpO1xuXHRcblx0ICBmdW5jdGlvbiBCb29sZWFuQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KSB7XG5cdCAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQm9vbGVhbkNvbnRyb2xsZXIpO1xuXHRcblx0ICAgIHZhciBfdGhpczIgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29udHJvbGxlci5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpKTtcblx0XG5cdCAgICB2YXIgX3RoaXMgPSBfdGhpczI7XG5cdCAgICBfdGhpczIuX19wcmV2ID0gX3RoaXMyLmdldFZhbHVlKCk7XG5cdFxuXHQgICAgX3RoaXMyLl9fY2hlY2tib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuXHQgICAgX3RoaXMyLl9fY2hlY2tib3guc2V0QXR0cmlidXRlKCd0eXBlJywgJ2NoZWNrYm94Jyk7XG5cdFxuXHQgICAgZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG5cdCAgICAgIF90aGlzLnNldFZhbHVlKCFfdGhpcy5fX3ByZXYpO1xuXHQgICAgfVxuXHRcblx0ICAgIF9kb20yLmRlZmF1bHQuYmluZChfdGhpczIuX19jaGVja2JveCwgJ2NoYW5nZScsIG9uQ2hhbmdlLCBmYWxzZSk7XG5cdFxuXHQgICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9fY2hlY2tib3gpO1xuXHRcblx0ICAgIC8vIE1hdGNoIG9yaWdpbmFsIHZhbHVlXG5cdCAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xuXHQgICAgcmV0dXJuIF90aGlzMjtcblx0ICB9XG5cdFxuXHQgIEJvb2xlYW5Db250cm9sbGVyLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uIHNldFZhbHVlKHYpIHtcblx0ICAgIHZhciB0b1JldHVybiA9IF9Db250cm9sbGVyLnByb3RvdHlwZS5zZXRWYWx1ZS5jYWxsKHRoaXMsIHYpO1xuXHQgICAgaWYgKHRoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuXHQgICAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbCh0aGlzLCB0aGlzLmdldFZhbHVlKCkpO1xuXHQgICAgfVxuXHQgICAgdGhpcy5fX3ByZXYgPSB0aGlzLmdldFZhbHVlKCk7XG5cdCAgICByZXR1cm4gdG9SZXR1cm47XG5cdCAgfTtcblx0XG5cdCAgQm9vbGVhbkNvbnRyb2xsZXIucHJvdG90eXBlLnVwZGF0ZURpc3BsYXkgPSBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuXHQgICAgaWYgKHRoaXMuZ2V0VmFsdWUoKSA9PT0gdHJ1ZSkge1xuXHQgICAgICB0aGlzLl9fY2hlY2tib3guc2V0QXR0cmlidXRlKCdjaGVja2VkJywgJ2NoZWNrZWQnKTtcblx0ICAgICAgdGhpcy5fX2NoZWNrYm94LmNoZWNrZWQgPSB0cnVlO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhpcy5fX2NoZWNrYm94LmNoZWNrZWQgPSBmYWxzZTtcblx0ICAgIH1cblx0XG5cdCAgICByZXR1cm4gX0NvbnRyb2xsZXIucHJvdG90eXBlLnVwZGF0ZURpc3BsYXkuY2FsbCh0aGlzKTtcblx0ICB9O1xuXHRcblx0ICByZXR1cm4gQm9vbGVhbkNvbnRyb2xsZXI7XG5cdH0oX0NvbnRyb2xsZXIzLmRlZmF1bHQpO1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gQm9vbGVhbkNvbnRyb2xsZXI7XG5cbi8qKiovIH0sXG4vKiA5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHRcblx0dmFyIF9jb21tb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHRcblx0dmFyIF9jb21tb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tbW9uKTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cdFxuXHR2YXIgRVZFTlRfTUFQID0ge1xuXHQgIEhUTUxFdmVudHM6IFsnY2hhbmdlJ10sXG5cdCAgTW91c2VFdmVudHM6IFsnY2xpY2snLCAnbW91c2Vtb3ZlJywgJ21vdXNlZG93bicsICdtb3VzZXVwJywgJ21vdXNlb3ZlciddLFxuXHQgIEtleWJvYXJkRXZlbnRzOiBbJ2tleWRvd24nXVxuXHR9OyAvKipcblx0ICAgICogZGF0LWd1aSBKYXZhU2NyaXB0IENvbnRyb2xsZXIgTGlicmFyeVxuXHQgICAgKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZGF0LWd1aVxuXHQgICAgKlxuXHQgICAgKiBDb3B5cmlnaHQgMjAxMSBEYXRhIEFydHMgVGVhbSwgR29vZ2xlIENyZWF0aXZlIExhYlxuXHQgICAgKlxuXHQgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuXHQgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5cdCAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXHQgICAgKlxuXHQgICAgKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblx0ICAgICovXG5cdFxuXHR2YXIgRVZFTlRfTUFQX0lOViA9IHt9O1xuXHRfY29tbW9uMi5kZWZhdWx0LmVhY2goRVZFTlRfTUFQLCBmdW5jdGlvbiAodiwgaykge1xuXHQgIF9jb21tb24yLmRlZmF1bHQuZWFjaCh2LCBmdW5jdGlvbiAoZSkge1xuXHQgICAgRVZFTlRfTUFQX0lOVltlXSA9IGs7XG5cdCAgfSk7XG5cdH0pO1xuXHRcblx0dmFyIENTU19WQUxVRV9QSVhFTFMgPSAvKFxcZCsoXFwuXFxkKyk/KXB4Lztcblx0XG5cdGZ1bmN0aW9uIGNzc1ZhbHVlVG9QaXhlbHModmFsKSB7XG5cdCAgaWYgKHZhbCA9PT0gJzAnIHx8IF9jb21tb24yLmRlZmF1bHQuaXNVbmRlZmluZWQodmFsKSkge1xuXHQgICAgcmV0dXJuIDA7XG5cdCAgfVxuXHRcblx0ICB2YXIgbWF0Y2ggPSB2YWwubWF0Y2goQ1NTX1ZBTFVFX1BJWEVMUyk7XG5cdFxuXHQgIGlmICghX2NvbW1vbjIuZGVmYXVsdC5pc051bGwobWF0Y2gpKSB7XG5cdCAgICByZXR1cm4gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG5cdCAgfVxuXHRcblx0ICAvLyBUT0RPIC4uLmVtcz8gJT9cblx0XG5cdCAgcmV0dXJuIDA7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBAbmFtZXNwYWNlXG5cdCAqIEBtZW1iZXIgZGF0LmRvbVxuXHQgKi9cblx0dmFyIGRvbSA9IHtcblx0XG5cdCAgLyoqXG5cdCAgICpcblx0ICAgKiBAcGFyYW0gZWxlbVxuXHQgICAqIEBwYXJhbSBzZWxlY3RhYmxlXG5cdCAgICovXG5cdCAgbWFrZVNlbGVjdGFibGU6IGZ1bmN0aW9uIG1ha2VTZWxlY3RhYmxlKGVsZW0sIHNlbGVjdGFibGUpIHtcblx0ICAgIGlmIChlbGVtID09PSB1bmRlZmluZWQgfHwgZWxlbS5zdHlsZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cdFxuXHQgICAgZWxlbS5vbnNlbGVjdHN0YXJ0ID0gc2VsZWN0YWJsZSA/IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfSA6IGZ1bmN0aW9uICgpIHt9O1xuXHRcblx0ICAgIGVsZW0uc3R5bGUuTW96VXNlclNlbGVjdCA9IHNlbGVjdGFibGUgPyAnYXV0bycgOiAnbm9uZSc7XG5cdCAgICBlbGVtLnN0eWxlLktodG1sVXNlclNlbGVjdCA9IHNlbGVjdGFibGUgPyAnYXV0bycgOiAnbm9uZSc7XG5cdCAgICBlbGVtLnVuc2VsZWN0YWJsZSA9IHNlbGVjdGFibGUgPyAnb24nIDogJ29mZic7XG5cdCAgfSxcblx0XG5cdCAgLyoqXG5cdCAgICpcblx0ICAgKiBAcGFyYW0gZWxlbVxuXHQgICAqIEBwYXJhbSBob3Jpem9udGFsXG5cdCAgICogQHBhcmFtIHZlcnRcblx0ICAgKi9cblx0ICBtYWtlRnVsbHNjcmVlbjogZnVuY3Rpb24gbWFrZUZ1bGxzY3JlZW4oZWxlbSwgaG9yLCB2ZXJ0KSB7XG5cdCAgICB2YXIgdmVydGljYWwgPSB2ZXJ0O1xuXHQgICAgdmFyIGhvcml6b250YWwgPSBob3I7XG5cdFxuXHQgICAgaWYgKF9jb21tb24yLmRlZmF1bHQuaXNVbmRlZmluZWQoaG9yaXpvbnRhbCkpIHtcblx0ICAgICAgaG9yaXpvbnRhbCA9IHRydWU7XG5cdCAgICB9XG5cdFxuXHQgICAgaWYgKF9jb21tb24yLmRlZmF1bHQuaXNVbmRlZmluZWQodmVydGljYWwpKSB7XG5cdCAgICAgIHZlcnRpY2FsID0gdHJ1ZTtcblx0ICAgIH1cblx0XG5cdCAgICBlbGVtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblx0XG5cdCAgICBpZiAoaG9yaXpvbnRhbCkge1xuXHQgICAgICBlbGVtLnN0eWxlLmxlZnQgPSAwO1xuXHQgICAgICBlbGVtLnN0eWxlLnJpZ2h0ID0gMDtcblx0ICAgIH1cblx0ICAgIGlmICh2ZXJ0aWNhbCkge1xuXHQgICAgICBlbGVtLnN0eWxlLnRvcCA9IDA7XG5cdCAgICAgIGVsZW0uc3R5bGUuYm90dG9tID0gMDtcblx0ICAgIH1cblx0ICB9LFxuXHRcblx0ICAvKipcblx0ICAgKlxuXHQgICAqIEBwYXJhbSBlbGVtXG5cdCAgICogQHBhcmFtIGV2ZW50VHlwZVxuXHQgICAqIEBwYXJhbSBwYXJhbXNcblx0ICAgKi9cblx0ICBmYWtlRXZlbnQ6IGZ1bmN0aW9uIGZha2VFdmVudChlbGVtLCBldmVudFR5cGUsIHBhcnMsIGF1eCkge1xuXHQgICAgdmFyIHBhcmFtcyA9IHBhcnMgfHwge307XG5cdCAgICB2YXIgY2xhc3NOYW1lID0gRVZFTlRfTUFQX0lOVltldmVudFR5cGVdO1xuXHQgICAgaWYgKCFjbGFzc05hbWUpIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudCB0eXBlICcgKyBldmVudFR5cGUgKyAnIG5vdCBzdXBwb3J0ZWQuJyk7XG5cdCAgICB9XG5cdCAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoY2xhc3NOYW1lKTtcblx0ICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG5cdCAgICAgIGNhc2UgJ01vdXNlRXZlbnRzJzpcblx0ICAgICAgICB7XG5cdCAgICAgICAgICB2YXIgY2xpZW50WCA9IHBhcmFtcy54IHx8IHBhcmFtcy5jbGllbnRYIHx8IDA7XG5cdCAgICAgICAgICB2YXIgY2xpZW50WSA9IHBhcmFtcy55IHx8IHBhcmFtcy5jbGllbnRZIHx8IDA7XG5cdCAgICAgICAgICBldnQuaW5pdE1vdXNlRXZlbnQoZXZlbnRUeXBlLCBwYXJhbXMuYnViYmxlcyB8fCBmYWxzZSwgcGFyYW1zLmNhbmNlbGFibGUgfHwgdHJ1ZSwgd2luZG93LCBwYXJhbXMuY2xpY2tDb3VudCB8fCAxLCAwLCAvLyBzY3JlZW4gWFxuXHQgICAgICAgICAgMCwgLy8gc2NyZWVuIFlcblx0ICAgICAgICAgIGNsaWVudFgsIC8vIGNsaWVudCBYXG5cdCAgICAgICAgICBjbGllbnRZLCAvLyBjbGllbnQgWVxuXHQgICAgICAgICAgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICBjYXNlICdLZXlib2FyZEV2ZW50cyc6XG5cdCAgICAgICAge1xuXHQgICAgICAgICAgdmFyIGluaXQgPSBldnQuaW5pdEtleWJvYXJkRXZlbnQgfHwgZXZ0LmluaXRLZXlFdmVudDsgLy8gd2Via2l0IHx8IG1velxuXHQgICAgICAgICAgX2NvbW1vbjIuZGVmYXVsdC5kZWZhdWx0cyhwYXJhbXMsIHtcblx0ICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcblx0ICAgICAgICAgICAgY3RybEtleTogZmFsc2UsXG5cdCAgICAgICAgICAgIGFsdEtleTogZmFsc2UsXG5cdCAgICAgICAgICAgIHNoaWZ0S2V5OiBmYWxzZSxcblx0ICAgICAgICAgICAgbWV0YUtleTogZmFsc2UsXG5cdCAgICAgICAgICAgIGtleUNvZGU6IHVuZGVmaW5lZCxcblx0ICAgICAgICAgICAgY2hhckNvZGU6IHVuZGVmaW5lZFxuXHQgICAgICAgICAgfSk7XG5cdCAgICAgICAgICBpbml0KGV2ZW50VHlwZSwgcGFyYW1zLmJ1YmJsZXMgfHwgZmFsc2UsIHBhcmFtcy5jYW5jZWxhYmxlLCB3aW5kb3csIHBhcmFtcy5jdHJsS2V5LCBwYXJhbXMuYWx0S2V5LCBwYXJhbXMuc2hpZnRLZXksIHBhcmFtcy5tZXRhS2V5LCBwYXJhbXMua2V5Q29kZSwgcGFyYW1zLmNoYXJDb2RlKTtcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgICAgZGVmYXVsdDpcblx0ICAgICAgICB7XG5cdCAgICAgICAgICBldnQuaW5pdEV2ZW50KGV2ZW50VHlwZSwgcGFyYW1zLmJ1YmJsZXMgfHwgZmFsc2UsIHBhcmFtcy5jYW5jZWxhYmxlIHx8IHRydWUpO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgX2NvbW1vbjIuZGVmYXVsdC5kZWZhdWx0cyhldnQsIGF1eCk7XG5cdCAgICBlbGVtLmRpc3BhdGNoRXZlbnQoZXZ0KTtcblx0ICB9LFxuXHRcblx0ICAvKipcblx0ICAgKlxuXHQgICAqIEBwYXJhbSBlbGVtXG5cdCAgICogQHBhcmFtIGV2ZW50XG5cdCAgICogQHBhcmFtIGZ1bmNcblx0ICAgKiBAcGFyYW0gYm9vbFxuXHQgICAqL1xuXHQgIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoZWxlbSwgZXZlbnQsIGZ1bmMsIG5ld0Jvb2wpIHtcblx0ICAgIHZhciBib29sID0gbmV3Qm9vbCB8fCBmYWxzZTtcblx0ICAgIGlmIChlbGVtLmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0ICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmdW5jLCBib29sKTtcblx0ICAgIH0gZWxzZSBpZiAoZWxlbS5hdHRhY2hFdmVudCkge1xuXHQgICAgICBlbGVtLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgZnVuYyk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZG9tO1xuXHQgIH0sXG5cdFxuXHQgIC8qKlxuXHQgICAqXG5cdCAgICogQHBhcmFtIGVsZW1cblx0ICAgKiBAcGFyYW0gZXZlbnRcblx0ICAgKiBAcGFyYW0gZnVuY1xuXHQgICAqIEBwYXJhbSBib29sXG5cdCAgICovXG5cdCAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoZWxlbSwgZXZlbnQsIGZ1bmMsIG5ld0Jvb2wpIHtcblx0ICAgIHZhciBib29sID0gbmV3Qm9vbCB8fCBmYWxzZTtcblx0ICAgIGlmIChlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcblx0ICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBmdW5jLCBib29sKTtcblx0ICAgIH0gZWxzZSBpZiAoZWxlbS5kZXRhY2hFdmVudCkge1xuXHQgICAgICBlbGVtLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgZnVuYyk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZG9tO1xuXHQgIH0sXG5cdFxuXHQgIC8qKlxuXHQgICAqXG5cdCAgICogQHBhcmFtIGVsZW1cblx0ICAgKiBAcGFyYW0gY2xhc3NOYW1lXG5cdCAgICovXG5cdCAgYWRkQ2xhc3M6IGZ1bmN0aW9uIGFkZENsYXNzKGVsZW0sIGNsYXNzTmFtZSkge1xuXHQgICAgaWYgKGVsZW0uY2xhc3NOYW1lID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG5cdCAgICB9IGVsc2UgaWYgKGVsZW0uY2xhc3NOYW1lICE9PSBjbGFzc05hbWUpIHtcblx0ICAgICAgdmFyIGNsYXNzZXMgPSBlbGVtLmNsYXNzTmFtZS5zcGxpdCgvICsvKTtcblx0ICAgICAgaWYgKGNsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpID09PSAtMSkge1xuXHQgICAgICAgIGNsYXNzZXMucHVzaChjbGFzc05hbWUpO1xuXHQgICAgICAgIGVsZW0uY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJykucmVwbGFjZSgvXlxccysvLCAnJykucmVwbGFjZSgvXFxzKyQvLCAnJyk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBkb207XG5cdCAgfSxcblx0XG5cdCAgLyoqXG5cdCAgICpcblx0ICAgKiBAcGFyYW0gZWxlbVxuXHQgICAqIEBwYXJhbSBjbGFzc05hbWVcblx0ICAgKi9cblx0ICByZW1vdmVDbGFzczogZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbSwgY2xhc3NOYW1lKSB7XG5cdCAgICBpZiAoY2xhc3NOYW1lKSB7XG5cdCAgICAgIGlmIChlbGVtLmNsYXNzTmFtZSA9PT0gY2xhc3NOYW1lKSB7XG5cdCAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdmFyIGNsYXNzZXMgPSBlbGVtLmNsYXNzTmFtZS5zcGxpdCgvICsvKTtcblx0ICAgICAgICB2YXIgaW5kZXggPSBjbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKTtcblx0ICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG5cdCAgICAgICAgICBjbGFzc2VzLnNwbGljZShpbmRleCwgMSk7XG5cdCAgICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbignICcpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZWxlbS5jbGFzc05hbWUgPSB1bmRlZmluZWQ7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZG9tO1xuXHQgIH0sXG5cdFxuXHQgIGhhc0NsYXNzOiBmdW5jdGlvbiBoYXNDbGFzcyhlbGVtLCBjbGFzc05hbWUpIHtcblx0ICAgIHJldHVybiBuZXcgUmVnRXhwKCcoPzpefFxcXFxzKyknICsgY2xhc3NOYW1lICsgJyg/OlxcXFxzK3wkKScpLnRlc3QoZWxlbS5jbGFzc05hbWUpIHx8IGZhbHNlO1xuXHQgIH0sXG5cdFxuXHQgIC8qKlxuXHQgICAqXG5cdCAgICogQHBhcmFtIGVsZW1cblx0ICAgKi9cblx0ICBnZXRXaWR0aDogZnVuY3Rpb24gZ2V0V2lkdGgoZWxlbSkge1xuXHQgICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKTtcblx0XG5cdCAgICByZXR1cm4gY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnYm9yZGVyLWxlZnQtd2lkdGgnXSkgKyBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydib3JkZXItcmlnaHQtd2lkdGgnXSkgKyBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydwYWRkaW5nLWxlZnQnXSkgKyBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydwYWRkaW5nLXJpZ2h0J10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZS53aWR0aCk7XG5cdCAgfSxcblx0XG5cdCAgLyoqXG5cdCAgICpcblx0ICAgKiBAcGFyYW0gZWxlbVxuXHQgICAqL1xuXHQgIGdldEhlaWdodDogZnVuY3Rpb24gZ2V0SGVpZ2h0KGVsZW0pIHtcblx0ICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbSk7XG5cdFxuXHQgICAgcmV0dXJuIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2JvcmRlci10b3Atd2lkdGgnXSkgKyBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydib3JkZXItYm90dG9tLXdpZHRoJ10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsncGFkZGluZy10b3AnXSkgKyBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydwYWRkaW5nLWJvdHRvbSddKSArIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGUuaGVpZ2h0KTtcblx0ICB9LFxuXHRcblx0ICAvKipcblx0ICAgKlxuXHQgICAqIEBwYXJhbSBlbFxuXHQgICAqL1xuXHQgIGdldE9mZnNldDogZnVuY3Rpb24gZ2V0T2Zmc2V0KGVsKSB7XG5cdCAgICB2YXIgZWxlbSA9IGVsO1xuXHQgICAgdmFyIG9mZnNldCA9IHsgbGVmdDogMCwgdG9wOiAwIH07XG5cdCAgICBpZiAoZWxlbS5vZmZzZXRQYXJlbnQpIHtcblx0ICAgICAgZG8ge1xuXHQgICAgICAgIG9mZnNldC5sZWZ0ICs9IGVsZW0ub2Zmc2V0TGVmdDtcblx0ICAgICAgICBvZmZzZXQudG9wICs9IGVsZW0ub2Zmc2V0VG9wO1xuXHQgICAgICAgIGVsZW0gPSBlbGVtLm9mZnNldFBhcmVudDtcblx0ICAgICAgfSB3aGlsZSAoZWxlbSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gb2Zmc2V0O1xuXHQgIH0sXG5cdFxuXHQgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9wb3N0cy8yNjg0NTYxL3JldmlzaW9uc1xuXHQgIC8qKlxuXHQgICAqXG5cdCAgICogQHBhcmFtIGVsZW1cblx0ICAgKi9cblx0ICBpc0FjdGl2ZTogZnVuY3Rpb24gaXNBY3RpdmUoZWxlbSkge1xuXHQgICAgcmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYpO1xuXHQgIH1cblx0XG5cdH07XG5cdFxuXHRleHBvcnRzLmRlZmF1bHQgPSBkb207XG5cbi8qKiovIH0sXG4vKiAxMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblx0XG5cdHZhciBfQ29udHJvbGxlcjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXHRcblx0dmFyIF9Db250cm9sbGVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NvbnRyb2xsZXIyKTtcblx0XG5cdHZhciBfZG9tID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblx0XG5cdHZhciBfZG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RvbSk7XG5cdFxuXHR2YXIgX2NvbW1vbiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdFxuXHR2YXIgX2NvbW1vbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21tb24pO1xuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblx0XG5cdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cdFxuXHRmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblx0XG5cdGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfSAvKipcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogZGF0LWd1aSBKYXZhU2NyaXB0IENvbnRyb2xsZXIgTGlicmFyeVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZGF0LWd1aVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBDb3B5cmlnaHQgMjAxMSBEYXRhIEFydHMgVGVhbSwgR29vZ2xlIENyZWF0aXZlIExhYlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cdFxuXHQvKipcblx0ICogQGNsYXNzIFByb3ZpZGVzIGEgc2VsZWN0IGlucHV0IHRvIGFsdGVyIHRoZSBwcm9wZXJ0eSBvZiBhbiBvYmplY3QsIHVzaW5nIGFcblx0ICogbGlzdCBvZiBhY2NlcHRlZCB2YWx1ZXMuXG5cdCAqXG5cdCAqIEBleHRlbmRzIGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiZSBtYW5pcHVsYXRlZFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIG1hbmlwdWxhdGVkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ1tdfSBvcHRpb25zIEEgbWFwIG9mIGxhYmVscyB0byBhY2NlcHRhYmxlIHZhbHVlcywgb3Jcblx0ICogYSBsaXN0IG9mIGFjY2VwdGFibGUgc3RyaW5nIHZhbHVlcy5cblx0ICpcblx0ICogQG1lbWJlciBkYXQuY29udHJvbGxlcnNcblx0ICovXG5cdHZhciBPcHRpb25Db250cm9sbGVyID0gZnVuY3Rpb24gKF9Db250cm9sbGVyKSB7XG5cdCAgX2luaGVyaXRzKE9wdGlvbkNvbnRyb2xsZXIsIF9Db250cm9sbGVyKTtcblx0XG5cdCAgZnVuY3Rpb24gT3B0aW9uQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5LCBvcHRzKSB7XG5cdCAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT3B0aW9uQ29udHJvbGxlcik7XG5cdFxuXHQgICAgdmFyIF90aGlzMiA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db250cm9sbGVyLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSkpO1xuXHRcblx0ICAgIHZhciBvcHRpb25zID0gb3B0cztcblx0XG5cdCAgICB2YXIgX3RoaXMgPSBfdGhpczI7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGUgZHJvcCBkb3duIG1lbnVcblx0ICAgICAqIEBpZ25vcmVcblx0ICAgICAqL1xuXHQgICAgX3RoaXMyLl9fc2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XG5cdFxuXHQgICAgaWYgKF9jb21tb24yLmRlZmF1bHQuaXNBcnJheShvcHRpb25zKSkge1xuXHQgICAgICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBtYXAgPSB7fTtcblx0ICAgICAgICBfY29tbW9uMi5kZWZhdWx0LmVhY2gob3B0aW9ucywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0ICAgICAgICAgIG1hcFtlbGVtZW50XSA9IGVsZW1lbnQ7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgb3B0aW9ucyA9IG1hcDtcblx0ICAgICAgfSkoKTtcblx0ICAgIH1cblx0XG5cdCAgICBfY29tbW9uMi5kZWZhdWx0LmVhY2gob3B0aW9ucywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcblx0ICAgICAgdmFyIG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuXHQgICAgICBvcHQuaW5uZXJIVE1MID0ga2V5O1xuXHQgICAgICBvcHQuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHZhbHVlKTtcblx0ICAgICAgX3RoaXMuX19zZWxlY3QuYXBwZW5kQ2hpbGQob3B0KTtcblx0ICAgIH0pO1xuXHRcblx0ICAgIC8vIEFja25vd2xlZGdlIG9yaWdpbmFsIHZhbHVlXG5cdCAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xuXHRcblx0ICAgIF9kb20yLmRlZmF1bHQuYmluZChfdGhpczIuX19zZWxlY3QsICdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciBkZXNpcmVkVmFsdWUgPSB0aGlzLm9wdGlvbnNbdGhpcy5zZWxlY3RlZEluZGV4XS52YWx1ZTtcblx0ICAgICAgX3RoaXMuc2V0VmFsdWUoZGVzaXJlZFZhbHVlKTtcblx0ICAgIH0pO1xuXHRcblx0ICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX3NlbGVjdCk7XG5cdCAgICByZXR1cm4gX3RoaXMyO1xuXHQgIH1cblx0XG5cdCAgT3B0aW9uQ29udHJvbGxlci5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiBzZXRWYWx1ZSh2KSB7XG5cdCAgICB2YXIgdG9SZXR1cm4gPSBfQ29udHJvbGxlci5wcm90b3R5cGUuc2V0VmFsdWUuY2FsbCh0aGlzLCB2KTtcblx0XG5cdCAgICBpZiAodGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG5cdCAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKHRoaXMsIHRoaXMuZ2V0VmFsdWUoKSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdG9SZXR1cm47XG5cdCAgfTtcblx0XG5cdCAgT3B0aW9uQ29udHJvbGxlci5wcm90b3R5cGUudXBkYXRlRGlzcGxheSA9IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG5cdCAgICBpZiAoX2RvbTIuZGVmYXVsdC5pc0FjdGl2ZSh0aGlzLl9fc2VsZWN0KSkgcmV0dXJuIHRoaXM7IC8vIHByZXZlbnQgbnVtYmVyIGZyb20gdXBkYXRpbmcgaWYgdXNlciBpcyB0cnlpbmcgdG8gbWFudWFsbHkgdXBkYXRlXG5cdCAgICB0aGlzLl9fc2VsZWN0LnZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuXHQgICAgcmV0dXJuIF9Db250cm9sbGVyLnByb3RvdHlwZS51cGRhdGVEaXNwbGF5LmNhbGwodGhpcyk7XG5cdCAgfTtcblx0XG5cdCAgcmV0dXJuIE9wdGlvbkNvbnRyb2xsZXI7XG5cdH0oX0NvbnRyb2xsZXIzLmRlZmF1bHQpO1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gT3B0aW9uQ29udHJvbGxlcjtcblxuLyoqKi8gfSxcbi8qIDExICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHRcblx0dmFyIF9Db250cm9sbGVyMiA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cdFxuXHR2YXIgX0NvbnRyb2xsZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ29udHJvbGxlcjIpO1xuXHRcblx0dmFyIF9kb20gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXHRcblx0dmFyIF9kb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZG9tKTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXHRcblx0ZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cdFxuXHRmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLyoqXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGRhdC1ndWkgSmF2YVNjcmlwdCBDb250cm9sbGVyIExpYnJhcnlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2RhdC1ndWlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ29weXJpZ2h0IDIwMTEgRGF0YSBBcnRzIFRlYW0sIEdvb2dsZSBDcmVhdGl2ZSBMYWJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXHRcblx0LyoqXG5cdCAqIEBjbGFzcyBQcm92aWRlcyBhIHRleHQgaW5wdXQgdG8gYWx0ZXIgdGhlIHN0cmluZyBwcm9wZXJ0eSBvZiBhbiBvYmplY3QuXG5cdCAqXG5cdCAqIEBleHRlbmRzIGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiZSBtYW5pcHVsYXRlZFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIG1hbmlwdWxhdGVkXG5cdCAqXG5cdCAqIEBtZW1iZXIgZGF0LmNvbnRyb2xsZXJzXG5cdCAqL1xuXHR2YXIgU3RyaW5nQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfQ29udHJvbGxlcikge1xuXHQgIF9pbmhlcml0cyhTdHJpbmdDb250cm9sbGVyLCBfQ29udHJvbGxlcik7XG5cdFxuXHQgIGZ1bmN0aW9uIFN0cmluZ0NvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSkge1xuXHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0cmluZ0NvbnRyb2xsZXIpO1xuXHRcblx0ICAgIHZhciBfdGhpczIgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29udHJvbGxlci5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpKTtcblx0XG5cdCAgICB2YXIgX3RoaXMgPSBfdGhpczI7XG5cdFxuXHQgICAgZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG5cdCAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLl9faW5wdXQudmFsdWUpO1xuXHQgICAgfVxuXHRcblx0ICAgIGZ1bmN0aW9uIG9uQmx1cigpIHtcblx0ICAgICAgaWYgKF90aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcblx0ICAgICAgICBfdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwoX3RoaXMsIF90aGlzLmdldFZhbHVlKCkpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdFxuXHQgICAgX3RoaXMyLl9faW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuXHQgICAgX3RoaXMyLl9faW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQnKTtcblx0XG5cdCAgICBfZG9tMi5kZWZhdWx0LmJpbmQoX3RoaXMyLl9faW5wdXQsICdrZXl1cCcsIG9uQ2hhbmdlKTtcblx0ICAgIF9kb20yLmRlZmF1bHQuYmluZChfdGhpczIuX19pbnB1dCwgJ2NoYW5nZScsIG9uQ2hhbmdlKTtcblx0ICAgIF9kb20yLmRlZmF1bHQuYmluZChfdGhpczIuX19pbnB1dCwgJ2JsdXInLCBvbkJsdXIpO1xuXHQgICAgX2RvbTIuZGVmYXVsdC5iaW5kKF90aGlzMi5fX2lucHV0LCAna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XG5cdCAgICAgICAgdGhpcy5ibHVyKCk7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHRcblx0ICAgIF90aGlzMi51cGRhdGVEaXNwbGF5KCk7XG5cdFxuXHQgICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9faW5wdXQpO1xuXHQgICAgcmV0dXJuIF90aGlzMjtcblx0ICB9XG5cdFxuXHQgIFN0cmluZ0NvbnRyb2xsZXIucHJvdG90eXBlLnVwZGF0ZURpc3BsYXkgPSBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuXHQgICAgLy8gU3RvcHMgdGhlIGNhcmV0IGZyb20gbW92aW5nIG9uIGFjY291bnQgb2Y6XG5cdCAgICAvLyBrZXl1cCAtPiBzZXRWYWx1ZSAtPiB1cGRhdGVEaXNwbGF5XG5cdCAgICBpZiAoIV9kb20yLmRlZmF1bHQuaXNBY3RpdmUodGhpcy5fX2lucHV0KSkge1xuXHQgICAgICB0aGlzLl9faW5wdXQudmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gX0NvbnRyb2xsZXIucHJvdG90eXBlLnVwZGF0ZURpc3BsYXkuY2FsbCh0aGlzKTtcblx0ICB9O1xuXHRcblx0ICByZXR1cm4gU3RyaW5nQ29udHJvbGxlcjtcblx0fShfQ29udHJvbGxlcjMuZGVmYXVsdCk7XG5cdFxuXHRleHBvcnRzLmRlZmF1bHQgPSBTdHJpbmdDb250cm9sbGVyO1xuXG4vKioqLyB9LFxuLyogMTIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cdFxuXHR2YXIgX0NvbnRyb2xsZXIyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblx0XG5cdHZhciBfQ29udHJvbGxlcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Db250cm9sbGVyMik7XG5cdFxuXHR2YXIgX2NvbW1vbiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdFxuXHR2YXIgX2NvbW1vbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21tb24pO1xuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblx0XG5cdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cdFxuXHRmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblx0XG5cdGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfSAvKipcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogZGF0LWd1aSBKYXZhU2NyaXB0IENvbnRyb2xsZXIgTGlicmFyeVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZGF0LWd1aVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBDb3B5cmlnaHQgMjAxMSBEYXRhIEFydHMgVGVhbSwgR29vZ2xlIENyZWF0aXZlIExhYlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cdFxuXHRmdW5jdGlvbiBudW1EZWNpbWFscyh4KSB7XG5cdCAgdmFyIF94ID0geC50b1N0cmluZygpO1xuXHQgIGlmIChfeC5pbmRleE9mKCcuJykgPiAtMSkge1xuXHQgICAgcmV0dXJuIF94Lmxlbmd0aCAtIF94LmluZGV4T2YoJy4nKSAtIDE7XG5cdCAgfVxuXHRcblx0ICByZXR1cm4gMDtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEBjbGFzcyBSZXByZXNlbnRzIGEgZ2l2ZW4gcHJvcGVydHkgb2YgYW4gb2JqZWN0IHRoYXQgaXMgYSBudW1iZXIuXG5cdCAqXG5cdCAqIEBleHRlbmRzIGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiZSBtYW5pcHVsYXRlZFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIG1hbmlwdWxhdGVkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSBPcHRpb25hbCBwYXJhbWV0ZXJzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1zLm1pbl0gTWluaW11bSBhbGxvd2VkIHZhbHVlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1zLm1heF0gTWF4aW11bSBhbGxvd2VkIHZhbHVlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1zLnN0ZXBdIEluY3JlbWVudCBieSB3aGljaCB0byBjaGFuZ2UgdmFsdWVcblx0ICpcblx0ICogQG1lbWJlciBkYXQuY29udHJvbGxlcnNcblx0ICovXG5cdFxuXHR2YXIgTnVtYmVyQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfQ29udHJvbGxlcikge1xuXHQgIF9pbmhlcml0cyhOdW1iZXJDb250cm9sbGVyLCBfQ29udHJvbGxlcik7XG5cdFxuXHQgIGZ1bmN0aW9uIE51bWJlckNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSwgcGFyYW1zKSB7XG5cdCAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTnVtYmVyQ29udHJvbGxlcik7XG5cdFxuXHQgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbnRyb2xsZXIuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KSk7XG5cdFxuXHQgICAgdmFyIF9wYXJhbXMgPSBwYXJhbXMgfHwge307XG5cdFxuXHQgICAgX3RoaXMuX19taW4gPSBfcGFyYW1zLm1pbjtcblx0ICAgIF90aGlzLl9fbWF4ID0gX3BhcmFtcy5tYXg7XG5cdCAgICBfdGhpcy5fX3N0ZXAgPSBfcGFyYW1zLnN0ZXA7XG5cdFxuXHQgICAgaWYgKF9jb21tb24yLmRlZmF1bHQuaXNVbmRlZmluZWQoX3RoaXMuX19zdGVwKSkge1xuXHQgICAgICBpZiAoX3RoaXMuaW5pdGlhbFZhbHVlID09PSAwKSB7XG5cdCAgICAgICAgX3RoaXMuX19pbXBsaWVkU3RlcCA9IDE7IC8vIFdoYXQgYXJlIHdlLCBwc3ljaGljcz9cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAvLyBIZXkgRG91ZywgY2hlY2sgdGhpcyBvdXQuXG5cdCAgICAgICAgX3RoaXMuX19pbXBsaWVkU3RlcCA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKE1hdGgubG9nKE1hdGguYWJzKF90aGlzLmluaXRpYWxWYWx1ZSkpIC8gTWF0aC5MTjEwKSkgLyAxMDtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgX3RoaXMuX19pbXBsaWVkU3RlcCA9IF90aGlzLl9fc3RlcDtcblx0ICAgIH1cblx0XG5cdCAgICBfdGhpcy5fX3ByZWNpc2lvbiA9IG51bURlY2ltYWxzKF90aGlzLl9faW1wbGllZFN0ZXApO1xuXHQgICAgcmV0dXJuIF90aGlzO1xuXHQgIH1cblx0XG5cdCAgTnVtYmVyQ29udHJvbGxlci5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiBzZXRWYWx1ZSh2KSB7XG5cdCAgICB2YXIgX3YgPSB2O1xuXHRcblx0ICAgIGlmICh0aGlzLl9fbWluICE9PSB1bmRlZmluZWQgJiYgX3YgPCB0aGlzLl9fbWluKSB7XG5cdCAgICAgIF92ID0gdGhpcy5fX21pbjtcblx0ICAgIH0gZWxzZSBpZiAodGhpcy5fX21heCAhPT0gdW5kZWZpbmVkICYmIF92ID4gdGhpcy5fX21heCkge1xuXHQgICAgICBfdiA9IHRoaXMuX19tYXg7XG5cdCAgICB9XG5cdFxuXHQgICAgaWYgKHRoaXMuX19zdGVwICE9PSB1bmRlZmluZWQgJiYgX3YgJSB0aGlzLl9fc3RlcCAhPT0gMCkge1xuXHQgICAgICBfdiA9IE1hdGgucm91bmQoX3YgLyB0aGlzLl9fc3RlcCkgKiB0aGlzLl9fc3RlcDtcblx0ICAgIH1cblx0XG5cdCAgICByZXR1cm4gX0NvbnRyb2xsZXIucHJvdG90eXBlLnNldFZhbHVlLmNhbGwodGhpcywgX3YpO1xuXHQgIH07XG5cdFxuXHQgIC8qKlxuXHQgICAqIFNwZWNpZnkgYSBtaW5pbXVtIHZhbHVlIGZvciA8Y29kZT5vYmplY3RbcHJvcGVydHldPC9jb2RlPi5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7TnVtYmVyfSBtaW5WYWx1ZSBUaGUgbWluaW11bSB2YWx1ZSBmb3Jcblx0ICAgKiA8Y29kZT5vYmplY3RbcHJvcGVydHldPC9jb2RlPlxuXHQgICAqIEByZXR1cm5zIHtkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlcn0gdGhpc1xuXHQgICAqL1xuXHRcblx0XG5cdCAgTnVtYmVyQ29udHJvbGxlci5wcm90b3R5cGUubWluID0gZnVuY3Rpb24gbWluKHYpIHtcblx0ICAgIHRoaXMuX19taW4gPSB2O1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0XG5cdCAgLyoqXG5cdCAgICogU3BlY2lmeSBhIG1heGltdW0gdmFsdWUgZm9yIDxjb2RlPm9iamVjdFtwcm9wZXJ0eV08L2NvZGU+LlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtOdW1iZXJ9IG1heFZhbHVlIFRoZSBtYXhpbXVtIHZhbHVlIGZvclxuXHQgICAqIDxjb2RlPm9iamVjdFtwcm9wZXJ0eV08L2NvZGU+XG5cdCAgICogQHJldHVybnMge2RhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyfSB0aGlzXG5cdCAgICovXG5cdFxuXHRcblx0ICBOdW1iZXJDb250cm9sbGVyLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiBtYXgodikge1xuXHQgICAgdGhpcy5fX21heCA9IHY7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHRcblx0ICAvKipcblx0ICAgKiBTcGVjaWZ5IGEgc3RlcCB2YWx1ZSB0aGF0IGRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyXG5cdCAgICogaW5jcmVtZW50cyBieS5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwVmFsdWUgVGhlIHN0ZXAgdmFsdWUgZm9yXG5cdCAgICogZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJcblx0ICAgKiBAZGVmYXVsdCBpZiBtaW5pbXVtIGFuZCBtYXhpbXVtIHNwZWNpZmllZCBpbmNyZW1lbnQgaXMgMSUgb2YgdGhlXG5cdCAgICogZGlmZmVyZW5jZSBvdGhlcndpc2Ugc3RlcFZhbHVlIGlzIDFcblx0ICAgKiBAcmV0dXJucyB7ZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJ9IHRoaXNcblx0ICAgKi9cblx0XG5cdFxuXHQgIE51bWJlckNvbnRyb2xsZXIucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbiBzdGVwKHYpIHtcblx0ICAgIHRoaXMuX19zdGVwID0gdjtcblx0ICAgIHRoaXMuX19pbXBsaWVkU3RlcCA9IHY7XG5cdCAgICB0aGlzLl9fcHJlY2lzaW9uID0gbnVtRGVjaW1hbHModik7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHRcblx0ICByZXR1cm4gTnVtYmVyQ29udHJvbGxlcjtcblx0fShfQ29udHJvbGxlcjMuZGVmYXVsdCk7XG5cdFxuXHRleHBvcnRzLmRlZmF1bHQgPSBOdW1iZXJDb250cm9sbGVyO1xuXG4vKioqLyB9LFxuLyogMTMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cdFxuXHR2YXIgX051bWJlckNvbnRyb2xsZXIyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cdFxuXHR2YXIgX051bWJlckNvbnRyb2xsZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTnVtYmVyQ29udHJvbGxlcjIpO1xuXHRcblx0dmFyIF9kb20gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXHRcblx0dmFyIF9kb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZG9tKTtcblx0XG5cdHZhciBfY29tbW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0XG5cdHZhciBfY29tbW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbW1vbik7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXHRcblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblx0XG5cdGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXHRcblx0ZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9IC8qKlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBkYXQtZ3VpIEphdmFTY3JpcHQgQ29udHJvbGxlciBMaWJyYXJ5XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9kYXQtZ3VpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIENvcHlyaWdodCAyMDExIERhdGEgQXJ0cyBUZWFtLCBHb29nbGUgQ3JlYXRpdmUgTGFiXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblx0XG5cdGZ1bmN0aW9uIHJvdW5kVG9EZWNpbWFsKHZhbHVlLCBkZWNpbWFscykge1xuXHQgIHZhciB0ZW5UbyA9IE1hdGgucG93KDEwLCBkZWNpbWFscyk7XG5cdCAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiB0ZW5UbykgLyB0ZW5Ubztcblx0fVxuXHRcblx0LyoqXG5cdCAqIEBjbGFzcyBSZXByZXNlbnRzIGEgZ2l2ZW4gcHJvcGVydHkgb2YgYW4gb2JqZWN0IHRoYXQgaXMgYSBudW1iZXIgYW5kXG5cdCAqIHByb3ZpZGVzIGFuIGlucHV0IGVsZW1lbnQgd2l0aCB3aGljaCB0byBtYW5pcHVsYXRlIGl0LlxuXHQgKlxuXHQgKiBAZXh0ZW5kcyBkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlclxuXHQgKiBAZXh0ZW5kcyBkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlclxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmUgbWFuaXB1bGF0ZWRcblx0ICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBtYW5pcHVsYXRlZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gT3B0aW9uYWwgcGFyYW1ldGVyc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5taW5dIE1pbmltdW0gYWxsb3dlZCB2YWx1ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5tYXhdIE1heGltdW0gYWxsb3dlZCB2YWx1ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5zdGVwXSBJbmNyZW1lbnQgYnkgd2hpY2ggdG8gY2hhbmdlIHZhbHVlXG5cdCAqXG5cdCAqIEBtZW1iZXIgZGF0LmNvbnRyb2xsZXJzXG5cdCAqL1xuXHRcblx0dmFyIE51bWJlckNvbnRyb2xsZXJCb3ggPSBmdW5jdGlvbiAoX051bWJlckNvbnRyb2xsZXIpIHtcblx0ICBfaW5oZXJpdHMoTnVtYmVyQ29udHJvbGxlckJveCwgX051bWJlckNvbnRyb2xsZXIpO1xuXHRcblx0ICBmdW5jdGlvbiBOdW1iZXJDb250cm9sbGVyQm94KG9iamVjdCwgcHJvcGVydHksIHBhcmFtcykge1xuXHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE51bWJlckNvbnRyb2xsZXJCb3gpO1xuXHRcblx0ICAgIHZhciBfdGhpczIgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfTnVtYmVyQ29udHJvbGxlci5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHksIHBhcmFtcykpO1xuXHRcblx0ICAgIF90aGlzMi5fX3RydW5jYXRpb25TdXNwZW5kZWQgPSBmYWxzZTtcblx0XG5cdCAgICB2YXIgX3RoaXMgPSBfdGhpczI7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiB7TnVtYmVyfSBQcmV2aW91cyBtb3VzZSB5IHBvc2l0aW9uXG5cdCAgICAgKiBAaWdub3JlXG5cdCAgICAgKi9cblx0ICAgIHZhciBwcmV2WSA9IHZvaWQgMDtcblx0XG5cdCAgICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcblx0ICAgICAgdmFyIGF0dGVtcHRlZCA9IHBhcnNlRmxvYXQoX3RoaXMuX19pbnB1dC52YWx1ZSk7XG5cdCAgICAgIGlmICghX2NvbW1vbjIuZGVmYXVsdC5pc05hTihhdHRlbXB0ZWQpKSB7XG5cdCAgICAgICAgX3RoaXMuc2V0VmFsdWUoYXR0ZW1wdGVkKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIGZ1bmN0aW9uIG9uRmluaXNoKCkge1xuXHQgICAgICBpZiAoX3RoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuXHQgICAgICAgIF90aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChfdGhpcywgX3RoaXMuZ2V0VmFsdWUoKSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICBmdW5jdGlvbiBvbkJsdXIoKSB7XG5cdCAgICAgIG9uRmluaXNoKCk7XG5cdCAgICB9XG5cdFxuXHQgICAgZnVuY3Rpb24gb25Nb3VzZURyYWcoZSkge1xuXHQgICAgICB2YXIgZGlmZiA9IHByZXZZIC0gZS5jbGllbnRZO1xuXHQgICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5nZXRWYWx1ZSgpICsgZGlmZiAqIF90aGlzLl9faW1wbGllZFN0ZXApO1xuXHRcblx0ICAgICAgcHJldlkgPSBlLmNsaWVudFk7XG5cdCAgICB9XG5cdFxuXHQgICAgZnVuY3Rpb24gb25Nb3VzZVVwKCkge1xuXHQgICAgICBfZG9tMi5kZWZhdWx0LnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBvbk1vdXNlRHJhZyk7XG5cdCAgICAgIF9kb20yLmRlZmF1bHQudW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuXHQgICAgICBvbkZpbmlzaCgpO1xuXHQgICAgfVxuXHRcblx0ICAgIGZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcblx0ICAgICAgX2RvbTIuZGVmYXVsdC5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIG9uTW91c2VEcmFnKTtcblx0ICAgICAgX2RvbTIuZGVmYXVsdC5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuXHQgICAgICBwcmV2WSA9IGUuY2xpZW50WTtcblx0ICAgIH1cblx0XG5cdCAgICBfdGhpczIuX19pbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG5cdCAgICBfdGhpczIuX19pbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpO1xuXHRcblx0ICAgIC8vIE1ha2VzIGl0IHNvIG1hbnVhbGx5IHNwZWNpZmllZCB2YWx1ZXMgYXJlIG5vdCB0cnVuY2F0ZWQuXG5cdFxuXHQgICAgX2RvbTIuZGVmYXVsdC5iaW5kKF90aGlzMi5fX2lucHV0LCAnY2hhbmdlJywgb25DaGFuZ2UpO1xuXHQgICAgX2RvbTIuZGVmYXVsdC5iaW5kKF90aGlzMi5fX2lucHV0LCAnYmx1cicsIG9uQmx1cik7XG5cdCAgICBfZG9tMi5kZWZhdWx0LmJpbmQoX3RoaXMyLl9faW5wdXQsICdtb3VzZWRvd24nLCBvbk1vdXNlRG93bik7XG5cdCAgICBfZG9tMi5kZWZhdWx0LmJpbmQoX3RoaXMyLl9faW5wdXQsICdrZXlkb3duJywgZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgLy8gV2hlbiBwcmVzc2luZyBlbnRlciwgeW91IGNhbiBiZSBhcyBwcmVjaXNlIGFzIHlvdSB3YW50LlxuXHQgICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykge1xuXHQgICAgICAgIF90aGlzLl9fdHJ1bmNhdGlvblN1c3BlbmRlZCA9IHRydWU7XG5cdCAgICAgICAgdGhpcy5ibHVyKCk7XG5cdCAgICAgICAgX3RoaXMuX190cnVuY2F0aW9uU3VzcGVuZGVkID0gZmFsc2U7XG5cdCAgICAgICAgb25GaW5pc2goKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdFxuXHQgICAgX3RoaXMyLnVwZGF0ZURpc3BsYXkoKTtcblx0XG5cdCAgICBfdGhpczIuZG9tRWxlbWVudC5hcHBlbmRDaGlsZChfdGhpczIuX19pbnB1dCk7XG5cdCAgICByZXR1cm4gX3RoaXMyO1xuXHQgIH1cblx0XG5cdCAgTnVtYmVyQ29udHJvbGxlckJveC5wcm90b3R5cGUudXBkYXRlRGlzcGxheSA9IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG5cdCAgICB0aGlzLl9faW5wdXQudmFsdWUgPSB0aGlzLl9fdHJ1bmNhdGlvblN1c3BlbmRlZCA/IHRoaXMuZ2V0VmFsdWUoKSA6IHJvdW5kVG9EZWNpbWFsKHRoaXMuZ2V0VmFsdWUoKSwgdGhpcy5fX3ByZWNpc2lvbik7XG5cdCAgICByZXR1cm4gX051bWJlckNvbnRyb2xsZXIucHJvdG90eXBlLnVwZGF0ZURpc3BsYXkuY2FsbCh0aGlzKTtcblx0ICB9O1xuXHRcblx0ICByZXR1cm4gTnVtYmVyQ29udHJvbGxlckJveDtcblx0fShfTnVtYmVyQ29udHJvbGxlcjMuZGVmYXVsdCk7XG5cdFxuXHRleHBvcnRzLmRlZmF1bHQgPSBOdW1iZXJDb250cm9sbGVyQm94O1xuXG4vKioqLyB9LFxuLyogMTQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cdFxuXHR2YXIgX051bWJlckNvbnRyb2xsZXIyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cdFxuXHR2YXIgX051bWJlckNvbnRyb2xsZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTnVtYmVyQ29udHJvbGxlcjIpO1xuXHRcblx0dmFyIF9kb20gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXHRcblx0dmFyIF9kb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZG9tKTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXHRcblx0ZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cdFxuXHRmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLyoqXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGRhdC1ndWkgSmF2YVNjcmlwdCBDb250cm9sbGVyIExpYnJhcnlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2RhdC1ndWlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ29weXJpZ2h0IDIwMTEgRGF0YSBBcnRzIFRlYW0sIEdvb2dsZSBDcmVhdGl2ZSBMYWJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXHRcblx0ZnVuY3Rpb24gbWFwKHYsIGkxLCBpMiwgbzEsIG8yKSB7XG5cdCAgcmV0dXJuIG8xICsgKG8yIC0gbzEpICogKCh2IC0gaTEpIC8gKGkyIC0gaTEpKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEBjbGFzcyBSZXByZXNlbnRzIGEgZ2l2ZW4gcHJvcGVydHkgb2YgYW4gb2JqZWN0IHRoYXQgaXMgYSBudW1iZXIsIGNvbnRhaW5zXG5cdCAqIGEgbWluaW11bSBhbmQgbWF4aW11bSwgYW5kIHByb3ZpZGVzIGEgc2xpZGVyIGVsZW1lbnQgd2l0aCB3aGljaCB0b1xuXHQgKiBtYW5pcHVsYXRlIGl0LiBJdCBzaG91bGQgYmUgbm90ZWQgdGhhdCB0aGUgc2xpZGVyIGVsZW1lbnQgaXMgbWFkZSB1cCBvZlxuXHQgKiA8Y29kZT4mbHQ7ZGl2Jmd0OzwvY29kZT4gdGFncywgPHN0cm9uZz5ub3Q8L3N0cm9uZz4gdGhlIGh0bWw1XG5cdCAqIDxjb2RlPiZsdDtzbGlkZXImZ3Q7PC9jb2RlPiBlbGVtZW50LlxuXHQgKlxuXHQgKiBAZXh0ZW5kcyBkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlclxuXHQgKiBAZXh0ZW5kcyBkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlclxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmUgbWFuaXB1bGF0ZWRcblx0ICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBtYW5pcHVsYXRlZFxuXHQgKiBAcGFyYW0ge051bWJlcn0gbWluVmFsdWUgTWluaW11bSBhbGxvd2VkIHZhbHVlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBtYXhWYWx1ZSBNYXhpbXVtIGFsbG93ZWQgdmFsdWVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0ZXBWYWx1ZSBJbmNyZW1lbnQgYnkgd2hpY2ggdG8gY2hhbmdlIHZhbHVlXG5cdCAqXG5cdCAqIEBtZW1iZXIgZGF0LmNvbnRyb2xsZXJzXG5cdCAqL1xuXHRcblx0dmFyIE51bWJlckNvbnRyb2xsZXJTbGlkZXIgPSBmdW5jdGlvbiAoX051bWJlckNvbnRyb2xsZXIpIHtcblx0ICBfaW5oZXJpdHMoTnVtYmVyQ29udHJvbGxlclNsaWRlciwgX051bWJlckNvbnRyb2xsZXIpO1xuXHRcblx0ICBmdW5jdGlvbiBOdW1iZXJDb250cm9sbGVyU2xpZGVyKG9iamVjdCwgcHJvcGVydHksIG1pbiwgbWF4LCBzdGVwKSB7XG5cdCAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTnVtYmVyQ29udHJvbGxlclNsaWRlcik7XG5cdFxuXHQgICAgdmFyIF90aGlzMiA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9OdW1iZXJDb250cm9sbGVyLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSwgeyBtaW46IG1pbiwgbWF4OiBtYXgsIHN0ZXA6IHN0ZXAgfSkpO1xuXHRcblx0ICAgIHZhciBfdGhpcyA9IF90aGlzMjtcblx0XG5cdCAgICBfdGhpczIuX19iYWNrZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdCAgICBfdGhpczIuX19mb3JlZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFxuXHQgICAgX2RvbTIuZGVmYXVsdC5iaW5kKF90aGlzMi5fX2JhY2tncm91bmQsICdtb3VzZWRvd24nLCBvbk1vdXNlRG93bik7XG5cdFxuXHQgICAgX2RvbTIuZGVmYXVsdC5hZGRDbGFzcyhfdGhpczIuX19iYWNrZ3JvdW5kLCAnc2xpZGVyJyk7XG5cdCAgICBfZG9tMi5kZWZhdWx0LmFkZENsYXNzKF90aGlzMi5fX2ZvcmVncm91bmQsICdzbGlkZXItZmcnKTtcblx0XG5cdCAgICBmdW5jdGlvbiBvbk1vdXNlRG93bihlKSB7XG5cdCAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuXHRcblx0ICAgICAgX2RvbTIuZGVmYXVsdC5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIG9uTW91c2VEcmFnKTtcblx0ICAgICAgX2RvbTIuZGVmYXVsdC5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuXHRcblx0ICAgICAgb25Nb3VzZURyYWcoZSk7XG5cdCAgICB9XG5cdFxuXHQgICAgZnVuY3Rpb24gb25Nb3VzZURyYWcoZSkge1xuXHQgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cdFxuXHQgICAgICB2YXIgYmdSZWN0ID0gX3RoaXMuX19iYWNrZ3JvdW5kLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcblx0ICAgICAgX3RoaXMuc2V0VmFsdWUobWFwKGUuY2xpZW50WCwgYmdSZWN0LmxlZnQsIGJnUmVjdC5yaWdodCwgX3RoaXMuX19taW4sIF90aGlzLl9fbWF4KSk7XG5cdFxuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdFxuXHQgICAgZnVuY3Rpb24gb25Nb3VzZVVwKCkge1xuXHQgICAgICBfZG9tMi5kZWZhdWx0LnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBvbk1vdXNlRHJhZyk7XG5cdCAgICAgIF9kb20yLmRlZmF1bHQudW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuXHQgICAgICBpZiAoX3RoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuXHQgICAgICAgIF90aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChfdGhpcywgX3RoaXMuZ2V0VmFsdWUoKSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xuXHRcblx0ICAgIF90aGlzMi5fX2JhY2tncm91bmQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9fZm9yZWdyb3VuZCk7XG5cdCAgICBfdGhpczIuZG9tRWxlbWVudC5hcHBlbmRDaGlsZChfdGhpczIuX19iYWNrZ3JvdW5kKTtcblx0ICAgIHJldHVybiBfdGhpczI7XG5cdCAgfVxuXHRcblx0ICBOdW1iZXJDb250cm9sbGVyU2xpZGVyLnByb3RvdHlwZS51cGRhdGVEaXNwbGF5ID0gZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcblx0ICAgIHZhciBwY3QgPSAodGhpcy5nZXRWYWx1ZSgpIC0gdGhpcy5fX21pbikgLyAodGhpcy5fX21heCAtIHRoaXMuX19taW4pO1xuXHQgICAgdGhpcy5fX2ZvcmVncm91bmQuc3R5bGUud2lkdGggPSBwY3QgKiAxMDAgKyAnJSc7XG5cdCAgICByZXR1cm4gX051bWJlckNvbnRyb2xsZXIucHJvdG90eXBlLnVwZGF0ZURpc3BsYXkuY2FsbCh0aGlzKTtcblx0ICB9O1xuXHRcblx0ICByZXR1cm4gTnVtYmVyQ29udHJvbGxlclNsaWRlcjtcblx0fShfTnVtYmVyQ29udHJvbGxlcjMuZGVmYXVsdCk7XG5cdFxuXHRleHBvcnRzLmRlZmF1bHQgPSBOdW1iZXJDb250cm9sbGVyU2xpZGVyO1xuXG4vKioqLyB9LFxuLyogMTUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cdFxuXHR2YXIgX0NvbnRyb2xsZXIyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblx0XG5cdHZhciBfQ29udHJvbGxlcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Db250cm9sbGVyMik7XG5cdFxuXHR2YXIgX2RvbSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cdFxuXHR2YXIgX2RvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kb20pO1xuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblx0XG5cdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cdFxuXHRmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblx0XG5cdGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfSAvKipcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogZGF0LWd1aSBKYXZhU2NyaXB0IENvbnRyb2xsZXIgTGlicmFyeVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZGF0LWd1aVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBDb3B5cmlnaHQgMjAxMSBEYXRhIEFydHMgVGVhbSwgR29vZ2xlIENyZWF0aXZlIExhYlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cdFxuXHQvKipcblx0ICogQGNsYXNzIFByb3ZpZGVzIGEgR1VJIGludGVyZmFjZSB0byBmaXJlIGEgc3BlY2lmaWVkIG1ldGhvZCwgYSBwcm9wZXJ0eSBvZiBhbiBvYmplY3QuXG5cdCAqXG5cdCAqIEBleHRlbmRzIGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiZSBtYW5pcHVsYXRlZFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIG1hbmlwdWxhdGVkXG5cdCAqXG5cdCAqIEBtZW1iZXIgZGF0LmNvbnRyb2xsZXJzXG5cdCAqL1xuXHR2YXIgRnVuY3Rpb25Db250cm9sbGVyID0gZnVuY3Rpb24gKF9Db250cm9sbGVyKSB7XG5cdCAgX2luaGVyaXRzKEZ1bmN0aW9uQ29udHJvbGxlciwgX0NvbnRyb2xsZXIpO1xuXHRcblx0ICBmdW5jdGlvbiBGdW5jdGlvbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSwgdGV4dCkge1xuXHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZ1bmN0aW9uQ29udHJvbGxlcik7XG5cdFxuXHQgICAgdmFyIF90aGlzMiA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db250cm9sbGVyLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSkpO1xuXHRcblx0ICAgIHZhciBfdGhpcyA9IF90aGlzMjtcblx0XG5cdCAgICBfdGhpczIuX19idXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0ICAgIF90aGlzMi5fX2J1dHRvbi5pbm5lckhUTUwgPSB0ZXh0ID09PSB1bmRlZmluZWQgPyAnRmlyZScgOiB0ZXh0O1xuXHRcblx0ICAgIF9kb20yLmRlZmF1bHQuYmluZChfdGhpczIuX19idXR0b24sICdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblx0ICAgICAgX3RoaXMuZmlyZSgpO1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9KTtcblx0XG5cdCAgICBfZG9tMi5kZWZhdWx0LmFkZENsYXNzKF90aGlzMi5fX2J1dHRvbiwgJ2J1dHRvbicpO1xuXHRcblx0ICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX2J1dHRvbik7XG5cdCAgICByZXR1cm4gX3RoaXMyO1xuXHQgIH1cblx0XG5cdCAgRnVuY3Rpb25Db250cm9sbGVyLnByb3RvdHlwZS5maXJlID0gZnVuY3Rpb24gZmlyZSgpIHtcblx0ICAgIGlmICh0aGlzLl9fb25DaGFuZ2UpIHtcblx0ICAgICAgdGhpcy5fX29uQ2hhbmdlLmNhbGwodGhpcyk7XG5cdCAgICB9XG5cdCAgICB0aGlzLmdldFZhbHVlKCkuY2FsbCh0aGlzLm9iamVjdCk7XG5cdCAgICBpZiAodGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG5cdCAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKHRoaXMsIHRoaXMuZ2V0VmFsdWUoKSk7XG5cdCAgICB9XG5cdCAgfTtcblx0XG5cdCAgcmV0dXJuIEZ1bmN0aW9uQ29udHJvbGxlcjtcblx0fShfQ29udHJvbGxlcjMuZGVmYXVsdCk7XG5cdFxuXHRleHBvcnRzLmRlZmF1bHQgPSBGdW5jdGlvbkNvbnRyb2xsZXI7XG5cbi8qKiovIH0sXG4vKiAxNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblx0XG5cdHZhciBfQ29udHJvbGxlcjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXHRcblx0dmFyIF9Db250cm9sbGVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NvbnRyb2xsZXIyKTtcblx0XG5cdHZhciBfZG9tID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblx0XG5cdHZhciBfZG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RvbSk7XG5cdFxuXHR2YXIgX0NvbG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0XG5cdHZhciBfQ29sb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ29sb3IpO1xuXHRcblx0dmFyIF9pbnRlcnByZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHRcblx0dmFyIF9pbnRlcnByZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW50ZXJwcmV0KTtcblx0XG5cdHZhciBfY29tbW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0XG5cdHZhciBfY29tbW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbW1vbik7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXHRcblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblx0XG5cdGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXHRcblx0ZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9IC8qKlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBkYXQtZ3VpIEphdmFTY3JpcHQgQ29udHJvbGxlciBMaWJyYXJ5XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9kYXQtZ3VpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIENvcHlyaWdodCAyMDExIERhdGEgQXJ0cyBUZWFtLCBHb29nbGUgQ3JlYXRpdmUgTGFiXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblx0XG5cdHZhciBDb2xvckNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX0NvbnRyb2xsZXIpIHtcblx0ICBfaW5oZXJpdHMoQ29sb3JDb250cm9sbGVyLCBfQ29udHJvbGxlcik7XG5cdFxuXHQgIGZ1bmN0aW9uIENvbG9yQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KSB7XG5cdCAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29sb3JDb250cm9sbGVyKTtcblx0XG5cdCAgICB2YXIgX3RoaXMyID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbnRyb2xsZXIuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KSk7XG5cdFxuXHQgICAgX3RoaXMyLl9fY29sb3IgPSBuZXcgX0NvbG9yMi5kZWZhdWx0KF90aGlzMi5nZXRWYWx1ZSgpKTtcblx0ICAgIF90aGlzMi5fX3RlbXAgPSBuZXcgX0NvbG9yMi5kZWZhdWx0KDApO1xuXHRcblx0ICAgIHZhciBfdGhpcyA9IF90aGlzMjtcblx0XG5cdCAgICBfdGhpczIuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcblx0ICAgIF9kb20yLmRlZmF1bHQubWFrZVNlbGVjdGFibGUoX3RoaXMyLmRvbUVsZW1lbnQsIGZhbHNlKTtcblx0XG5cdCAgICBfdGhpczIuX19zZWxlY3RvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHQgICAgX3RoaXMyLl9fc2VsZWN0b3IuY2xhc3NOYW1lID0gJ3NlbGVjdG9yJztcblx0XG5cdCAgICBfdGhpczIuX19zYXR1cmF0aW9uX2ZpZWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdCAgICBfdGhpczIuX19zYXR1cmF0aW9uX2ZpZWxkLmNsYXNzTmFtZSA9ICdzYXR1cmF0aW9uLWZpZWxkJztcblx0XG5cdCAgICBfdGhpczIuX19maWVsZF9rbm9iID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdCAgICBfdGhpczIuX19maWVsZF9rbm9iLmNsYXNzTmFtZSA9ICdmaWVsZC1rbm9iJztcblx0ICAgIF90aGlzMi5fX2ZpZWxkX2tub2JfYm9yZGVyID0gJzJweCBzb2xpZCAnO1xuXHRcblx0ICAgIF90aGlzMi5fX2h1ZV9rbm9iID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdCAgICBfdGhpczIuX19odWVfa25vYi5jbGFzc05hbWUgPSAnaHVlLWtub2InO1xuXHRcblx0ICAgIF90aGlzMi5fX2h1ZV9maWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHQgICAgX3RoaXMyLl9faHVlX2ZpZWxkLmNsYXNzTmFtZSA9ICdodWUtZmllbGQnO1xuXHRcblx0ICAgIF90aGlzMi5fX2lucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcblx0ICAgIF90aGlzMi5fX2lucHV0LnR5cGUgPSAndGV4dCc7XG5cdCAgICBfdGhpczIuX19pbnB1dF90ZXh0U2hhZG93ID0gJzAgMXB4IDFweCAnO1xuXHRcblx0ICAgIF9kb20yLmRlZmF1bHQuYmluZChfdGhpczIuX19pbnB1dCwgJ2tleWRvd24nLCBmdW5jdGlvbiAoZSkge1xuXHQgICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykge1xuXHQgICAgICAgIC8vIG9uIGVudGVyXG5cdCAgICAgICAgb25CbHVyLmNhbGwodGhpcyk7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHRcblx0ICAgIF9kb20yLmRlZmF1bHQuYmluZChfdGhpczIuX19pbnB1dCwgJ2JsdXInLCBvbkJsdXIpO1xuXHRcblx0ICAgIF9kb20yLmRlZmF1bHQuYmluZChfdGhpczIuX19zZWxlY3RvciwgJ21vdXNlZG93bicsIGZ1bmN0aW9uICgpIC8qIGUgKi97XG5cdCAgICAgIF9kb20yLmRlZmF1bHQuYWRkQ2xhc3ModGhpcywgJ2RyYWcnKS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBmdW5jdGlvbiAoKSAvKiBlICove1xuXHQgICAgICAgIF9kb20yLmRlZmF1bHQucmVtb3ZlQ2xhc3MoX3RoaXMuX19zZWxlY3RvciwgJ2RyYWcnKTtcblx0ICAgICAgfSk7XG5cdCAgICB9KTtcblx0XG5cdCAgICB2YXIgdmFsdWVGaWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcblx0ICAgIF9jb21tb24yLmRlZmF1bHQuZXh0ZW5kKF90aGlzMi5fX3NlbGVjdG9yLnN0eWxlLCB7XG5cdCAgICAgIHdpZHRoOiAnMTIycHgnLFxuXHQgICAgICBoZWlnaHQ6ICcxMDJweCcsXG5cdCAgICAgIHBhZGRpbmc6ICczcHgnLFxuXHQgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMjIyJyxcblx0ICAgICAgYm94U2hhZG93OiAnMHB4IDFweCAzcHggcmdiYSgwLDAsMCwwLjMpJ1xuXHQgICAgfSk7XG5cdFxuXHQgICAgX2NvbW1vbjIuZGVmYXVsdC5leHRlbmQoX3RoaXMyLl9fZmllbGRfa25vYi5zdHlsZSwge1xuXHQgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcblx0ICAgICAgd2lkdGg6ICcxMnB4Jyxcblx0ICAgICAgaGVpZ2h0OiAnMTJweCcsXG5cdCAgICAgIGJvcmRlcjogX3RoaXMyLl9fZmllbGRfa25vYl9ib3JkZXIgKyAoX3RoaXMyLl9fY29sb3IudiA8IDAuNSA/ICcjZmZmJyA6ICcjMDAwJyksXG5cdCAgICAgIGJveFNoYWRvdzogJzBweCAxcHggM3B4IHJnYmEoMCwwLDAsMC41KScsXG5cdCAgICAgIGJvcmRlclJhZGl1czogJzEycHgnLFxuXHQgICAgICB6SW5kZXg6IDFcblx0ICAgIH0pO1xuXHRcblx0ICAgIF9jb21tb24yLmRlZmF1bHQuZXh0ZW5kKF90aGlzMi5fX2h1ZV9rbm9iLnN0eWxlLCB7XG5cdCAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHQgICAgICB3aWR0aDogJzE1cHgnLFxuXHQgICAgICBoZWlnaHQ6ICcycHgnLFxuXHQgICAgICBib3JkZXJSaWdodDogJzRweCBzb2xpZCAjZmZmJyxcblx0ICAgICAgekluZGV4OiAxXG5cdCAgICB9KTtcblx0XG5cdCAgICBfY29tbW9uMi5kZWZhdWx0LmV4dGVuZChfdGhpczIuX19zYXR1cmF0aW9uX2ZpZWxkLnN0eWxlLCB7XG5cdCAgICAgIHdpZHRoOiAnMTAwcHgnLFxuXHQgICAgICBoZWlnaHQ6ICcxMDBweCcsXG5cdCAgICAgIGJvcmRlcjogJzFweCBzb2xpZCAjNTU1Jyxcblx0ICAgICAgbWFyZ2luUmlnaHQ6ICczcHgnLFxuXHQgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcblx0ICAgICAgY3Vyc29yOiAncG9pbnRlcidcblx0ICAgIH0pO1xuXHRcblx0ICAgIF9jb21tb24yLmRlZmF1bHQuZXh0ZW5kKHZhbHVlRmllbGQuc3R5bGUsIHtcblx0ICAgICAgd2lkdGg6ICcxMDAlJyxcblx0ICAgICAgaGVpZ2h0OiAnMTAwJScsXG5cdCAgICAgIGJhY2tncm91bmQ6ICdub25lJ1xuXHQgICAgfSk7XG5cdFxuXHQgICAgbGluZWFyR3JhZGllbnQodmFsdWVGaWVsZCwgJ3RvcCcsICdyZ2JhKDAsMCwwLDApJywgJyMwMDAnKTtcblx0XG5cdCAgICBfY29tbW9uMi5kZWZhdWx0LmV4dGVuZChfdGhpczIuX19odWVfZmllbGQuc3R5bGUsIHtcblx0ICAgICAgd2lkdGg6ICcxNXB4Jyxcblx0ICAgICAgaGVpZ2h0OiAnMTAwcHgnLFxuXHQgICAgICBib3JkZXI6ICcxcHggc29saWQgIzU1NScsXG5cdCAgICAgIGN1cnNvcjogJ25zLXJlc2l6ZScsXG5cdCAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHQgICAgICB0b3A6ICczcHgnLFxuXHQgICAgICByaWdodDogJzNweCdcblx0ICAgIH0pO1xuXHRcblx0ICAgIGh1ZUdyYWRpZW50KF90aGlzMi5fX2h1ZV9maWVsZCk7XG5cdFxuXHQgICAgX2NvbW1vbjIuZGVmYXVsdC5leHRlbmQoX3RoaXMyLl9faW5wdXQuc3R5bGUsIHtcblx0ICAgICAgb3V0bGluZTogJ25vbmUnLFxuXHQgICAgICAvLyAgICAgIHdpZHRoOiAnMTIwcHgnLFxuXHQgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuXHQgICAgICAvLyAgICAgIHBhZGRpbmc6ICc0cHgnLFxuXHQgICAgICAvLyAgICAgIG1hcmdpbkJvdHRvbTogJzZweCcsXG5cdCAgICAgIGNvbG9yOiAnI2ZmZicsXG5cdCAgICAgIGJvcmRlcjogMCxcblx0ICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxuXHQgICAgICB0ZXh0U2hhZG93OiBfdGhpczIuX19pbnB1dF90ZXh0U2hhZG93ICsgJ3JnYmEoMCwwLDAsMC43KSdcblx0ICAgIH0pO1xuXHRcblx0ICAgIF9kb20yLmRlZmF1bHQuYmluZChfdGhpczIuX19zYXR1cmF0aW9uX2ZpZWxkLCAnbW91c2Vkb3duJywgZmllbGREb3duKTtcblx0ICAgIF9kb20yLmRlZmF1bHQuYmluZChfdGhpczIuX19maWVsZF9rbm9iLCAnbW91c2Vkb3duJywgZmllbGREb3duKTtcblx0XG5cdCAgICBfZG9tMi5kZWZhdWx0LmJpbmQoX3RoaXMyLl9faHVlX2ZpZWxkLCAnbW91c2Vkb3duJywgZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgc2V0SChlKTtcblx0ICAgICAgX2RvbTIuZGVmYXVsdC5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIHNldEgpO1xuXHQgICAgICBfZG9tMi5kZWZhdWx0LmJpbmQod2luZG93LCAnbW91c2V1cCcsIGZpZWxkVXBIKTtcblx0ICAgIH0pO1xuXHRcblx0ICAgIGZ1bmN0aW9uIGZpZWxkRG93bihlKSB7XG5cdCAgICAgIHNldFNWKGUpO1xuXHQgICAgICAvLyBkb2N1bWVudC5ib2R5LnN0eWxlLmN1cnNvciA9ICdub25lJztcblx0ICAgICAgX2RvbTIuZGVmYXVsdC5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIHNldFNWKTtcblx0ICAgICAgX2RvbTIuZGVmYXVsdC5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBmaWVsZFVwU1YpO1xuXHQgICAgfVxuXHRcblx0ICAgIGZ1bmN0aW9uIGZpZWxkVXBTVigpIHtcblx0ICAgICAgX2RvbTIuZGVmYXVsdC51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgc2V0U1YpO1xuXHQgICAgICBfZG9tMi5kZWZhdWx0LnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgZmllbGRVcFNWKTtcblx0ICAgICAgLy8gZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG5cdCAgICAgIG9uRmluaXNoKCk7XG5cdCAgICB9XG5cdFxuXHQgICAgZnVuY3Rpb24gb25CbHVyKCkge1xuXHQgICAgICB2YXIgaSA9ICgwLCBfaW50ZXJwcmV0Mi5kZWZhdWx0KSh0aGlzLnZhbHVlKTtcblx0ICAgICAgaWYgKGkgIT09IGZhbHNlKSB7XG5cdCAgICAgICAgX3RoaXMuX19jb2xvci5fX3N0YXRlID0gaTtcblx0ICAgICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5fX2NvbG9yLnRvT3JpZ2luYWwoKSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IF90aGlzLl9fY29sb3IudG9TdHJpbmcoKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIGZ1bmN0aW9uIGZpZWxkVXBIKCkge1xuXHQgICAgICBfZG9tMi5kZWZhdWx0LnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRIKTtcblx0ICAgICAgX2RvbTIuZGVmYXVsdC51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIGZpZWxkVXBIKTtcblx0ICAgICAgb25GaW5pc2goKTtcblx0ICAgIH1cblx0XG5cdCAgICBmdW5jdGlvbiBvbkZpbmlzaCgpIHtcblx0ICAgICAgaWYgKF90aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcblx0ICAgICAgICBfdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwoX3RoaXMsIF90aGlzLl9fY29sb3IudG9PcmlnaW5hbCgpKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIF90aGlzMi5fX3NhdHVyYXRpb25fZmllbGQuYXBwZW5kQ2hpbGQodmFsdWVGaWVsZCk7XG5cdCAgICBfdGhpczIuX19zZWxlY3Rvci5hcHBlbmRDaGlsZChfdGhpczIuX19maWVsZF9rbm9iKTtcblx0ICAgIF90aGlzMi5fX3NlbGVjdG9yLmFwcGVuZENoaWxkKF90aGlzMi5fX3NhdHVyYXRpb25fZmllbGQpO1xuXHQgICAgX3RoaXMyLl9fc2VsZWN0b3IuYXBwZW5kQ2hpbGQoX3RoaXMyLl9faHVlX2ZpZWxkKTtcblx0ICAgIF90aGlzMi5fX2h1ZV9maWVsZC5hcHBlbmRDaGlsZChfdGhpczIuX19odWVfa25vYik7XG5cdFxuXHQgICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9faW5wdXQpO1xuXHQgICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9fc2VsZWN0b3IpO1xuXHRcblx0ICAgIF90aGlzMi51cGRhdGVEaXNwbGF5KCk7XG5cdFxuXHQgICAgZnVuY3Rpb24gc2V0U1YoZSkge1xuXHQgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cdFxuXHQgICAgICB2YXIgZmllbGRSZWN0ID0gX3RoaXMuX19zYXR1cmF0aW9uX2ZpZWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHQgICAgICB2YXIgcyA9IChlLmNsaWVudFggLSBmaWVsZFJlY3QubGVmdCkgLyAoZmllbGRSZWN0LnJpZ2h0IC0gZmllbGRSZWN0LmxlZnQpO1xuXHQgICAgICB2YXIgdiA9IDEgLSAoZS5jbGllbnRZIC0gZmllbGRSZWN0LnRvcCkgLyAoZmllbGRSZWN0LmJvdHRvbSAtIGZpZWxkUmVjdC50b3ApO1xuXHRcblx0ICAgICAgaWYgKHYgPiAxKSB7XG5cdCAgICAgICAgdiA9IDE7XG5cdCAgICAgIH0gZWxzZSBpZiAodiA8IDApIHtcblx0ICAgICAgICB2ID0gMDtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgaWYgKHMgPiAxKSB7XG5cdCAgICAgICAgcyA9IDE7XG5cdCAgICAgIH0gZWxzZSBpZiAocyA8IDApIHtcblx0ICAgICAgICBzID0gMDtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgX3RoaXMuX19jb2xvci52ID0gdjtcblx0ICAgICAgX3RoaXMuX19jb2xvci5zID0gcztcblx0XG5cdCAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLl9fY29sb3IudG9PcmlnaW5hbCgpKTtcblx0XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0XG5cdCAgICBmdW5jdGlvbiBzZXRIKGUpIHtcblx0ICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcblx0ICAgICAgdmFyIGZpZWxkUmVjdCA9IF90aGlzLl9faHVlX2ZpZWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHQgICAgICB2YXIgaCA9IDEgLSAoZS5jbGllbnRZIC0gZmllbGRSZWN0LnRvcCkgLyAoZmllbGRSZWN0LmJvdHRvbSAtIGZpZWxkUmVjdC50b3ApO1xuXHRcblx0ICAgICAgaWYgKGggPiAxKSB7XG5cdCAgICAgICAgaCA9IDE7XG5cdCAgICAgIH0gZWxzZSBpZiAoaCA8IDApIHtcblx0ICAgICAgICBoID0gMDtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgX3RoaXMuX19jb2xvci5oID0gaCAqIDM2MDtcblx0XG5cdCAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLl9fY29sb3IudG9PcmlnaW5hbCgpKTtcblx0XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBfdGhpczI7XG5cdCAgfVxuXHRcblx0ICBDb2xvckNvbnRyb2xsZXIucHJvdG90eXBlLnVwZGF0ZURpc3BsYXkgPSBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuXHQgICAgdmFyIGkgPSAoMCwgX2ludGVycHJldDIuZGVmYXVsdCkodGhpcy5nZXRWYWx1ZSgpKTtcblx0XG5cdCAgICBpZiAoaSAhPT0gZmFsc2UpIHtcblx0ICAgICAgdmFyIG1pc21hdGNoID0gZmFsc2U7XG5cdFxuXHQgICAgICAvLyBDaGVjayBmb3IgbWlzbWF0Y2ggb24gdGhlIGludGVycHJldGVkIHZhbHVlLlxuXHRcblx0ICAgICAgX2NvbW1vbjIuZGVmYXVsdC5lYWNoKF9Db2xvcjIuZGVmYXVsdC5DT01QT05FTlRTLCBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG5cdCAgICAgICAgaWYgKCFfY29tbW9uMi5kZWZhdWx0LmlzVW5kZWZpbmVkKGlbY29tcG9uZW50XSkgJiYgIV9jb21tb24yLmRlZmF1bHQuaXNVbmRlZmluZWQodGhpcy5fX2NvbG9yLl9fc3RhdGVbY29tcG9uZW50XSkgJiYgaVtjb21wb25lbnRdICE9PSB0aGlzLl9fY29sb3IuX19zdGF0ZVtjb21wb25lbnRdKSB7XG5cdCAgICAgICAgICBtaXNtYXRjaCA9IHRydWU7XG5cdCAgICAgICAgICByZXR1cm4ge307IC8vIGJyZWFrXG5cdCAgICAgICAgfVxuXHQgICAgICB9LCB0aGlzKTtcblx0XG5cdCAgICAgIC8vIElmIG5vdGhpbmcgZGl2ZXJnZXMsIHdlIGtlZXAgb3VyIHByZXZpb3VzIHZhbHVlc1xuXHQgICAgICAvLyBmb3Igc3RhdGVmdWxuZXNzLCBvdGhlcndpc2Ugd2UgcmVjYWxjdWxhdGUgZnJlc2hcblx0ICAgICAgaWYgKG1pc21hdGNoKSB7XG5cdCAgICAgICAgX2NvbW1vbjIuZGVmYXVsdC5leHRlbmQodGhpcy5fX2NvbG9yLl9fc3RhdGUsIGkpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdFxuXHQgICAgX2NvbW1vbjIuZGVmYXVsdC5leHRlbmQodGhpcy5fX3RlbXAuX19zdGF0ZSwgdGhpcy5fX2NvbG9yLl9fc3RhdGUpO1xuXHRcblx0ICAgIHRoaXMuX190ZW1wLmEgPSAxO1xuXHRcblx0ICAgIHZhciBmbGlwID0gdGhpcy5fX2NvbG9yLnYgPCAwLjUgfHwgdGhpcy5fX2NvbG9yLnMgPiAwLjUgPyAyNTUgOiAwO1xuXHQgICAgdmFyIF9mbGlwID0gMjU1IC0gZmxpcDtcblx0XG5cdCAgICBfY29tbW9uMi5kZWZhdWx0LmV4dGVuZCh0aGlzLl9fZmllbGRfa25vYi5zdHlsZSwge1xuXHQgICAgICBtYXJnaW5MZWZ0OiAxMDAgKiB0aGlzLl9fY29sb3IucyAtIDcgKyAncHgnLFxuXHQgICAgICBtYXJnaW5Ub3A6IDEwMCAqICgxIC0gdGhpcy5fX2NvbG9yLnYpIC0gNyArICdweCcsXG5cdCAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5fX3RlbXAudG9IZXhTdHJpbmcoKSxcblx0ICAgICAgYm9yZGVyOiB0aGlzLl9fZmllbGRfa25vYl9ib3JkZXIgKyAncmdiKCcgKyBmbGlwICsgJywnICsgZmxpcCArICcsJyArIGZsaXAgKyAnKSdcblx0ICAgIH0pO1xuXHRcblx0ICAgIHRoaXMuX19odWVfa25vYi5zdHlsZS5tYXJnaW5Ub3AgPSAoMSAtIHRoaXMuX19jb2xvci5oIC8gMzYwKSAqIDEwMCArICdweCc7XG5cdFxuXHQgICAgdGhpcy5fX3RlbXAucyA9IDE7XG5cdCAgICB0aGlzLl9fdGVtcC52ID0gMTtcblx0XG5cdCAgICBsaW5lYXJHcmFkaWVudCh0aGlzLl9fc2F0dXJhdGlvbl9maWVsZCwgJ2xlZnQnLCAnI2ZmZicsIHRoaXMuX190ZW1wLnRvSGV4U3RyaW5nKCkpO1xuXHRcblx0ICAgIHRoaXMuX19pbnB1dC52YWx1ZSA9IHRoaXMuX19jb2xvci50b1N0cmluZygpO1xuXHRcblx0ICAgIF9jb21tb24yLmRlZmF1bHQuZXh0ZW5kKHRoaXMuX19pbnB1dC5zdHlsZSwge1xuXHQgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuX19jb2xvci50b0hleFN0cmluZygpLFxuXHQgICAgICBjb2xvcjogJ3JnYignICsgZmxpcCArICcsJyArIGZsaXAgKyAnLCcgKyBmbGlwICsgJyknLFxuXHQgICAgICB0ZXh0U2hhZG93OiB0aGlzLl9faW5wdXRfdGV4dFNoYWRvdyArICdyZ2JhKCcgKyBfZmxpcCArICcsJyArIF9mbGlwICsgJywnICsgX2ZsaXAgKyAnLC43KSdcblx0ICAgIH0pO1xuXHQgIH07XG5cdFxuXHQgIHJldHVybiBDb2xvckNvbnRyb2xsZXI7XG5cdH0oX0NvbnRyb2xsZXIzLmRlZmF1bHQpO1xuXHRcblx0dmFyIHZlbmRvcnMgPSBbJy1tb3otJywgJy1vLScsICctd2Via2l0LScsICctbXMtJywgJyddO1xuXHRcblx0ZnVuY3Rpb24gbGluZWFyR3JhZGllbnQoZWxlbSwgeCwgYSwgYikge1xuXHQgIGVsZW0uc3R5bGUuYmFja2dyb3VuZCA9ICcnO1xuXHQgIF9jb21tb24yLmRlZmF1bHQuZWFjaCh2ZW5kb3JzLCBmdW5jdGlvbiAodmVuZG9yKSB7XG5cdCAgICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6ICcgKyB2ZW5kb3IgKyAnbGluZWFyLWdyYWRpZW50KCcgKyB4ICsgJywgJyArIGEgKyAnIDAlLCAnICsgYiArICcgMTAwJSk7ICc7XG5cdCAgfSk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGh1ZUdyYWRpZW50KGVsZW0pIHtcblx0ICBlbGVtLnN0eWxlLmJhY2tncm91bmQgPSAnJztcblx0ICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6IC1tb3otbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsICNmZjAwZmYgMTclLCAjMDAwMGZmIDM0JSwgIzAwZmZmZiA1MCUsICMwMGZmMDAgNjclLCAjZmZmZjAwIDg0JSwgI2ZmMDAwMCAxMDAlKTsnO1xuXHQgIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpOyc7XG5cdCAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtby1saW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpOyc7XG5cdCAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtbXMtbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsI2ZmMDBmZiAxNyUsIzAwMDBmZiAzNCUsIzAwZmZmZiA1MCUsIzAwZmYwMCA2NyUsI2ZmZmYwMCA4NCUsI2ZmMDAwMCAxMDAlKTsnO1xuXHQgIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsI2ZmMDBmZiAxNyUsIzAwMDBmZiAzNCUsIzAwZmZmZiA1MCUsIzAwZmYwMCA2NyUsI2ZmZmYwMCA4NCUsI2ZmMDAwMCAxMDAlKTsnO1xuXHR9XG5cdFxuXHRleHBvcnRzLmRlZmF1bHQgPSBDb2xvckNvbnRyb2xsZXI7XG5cbi8qKiovIH0sXG4vKiAxNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0dmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IC8qKlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGRhdC1ndWkgSmF2YVNjcmlwdCBDb250cm9sbGVyIExpYnJhcnlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZGF0LWd1aVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ29weXJpZ2h0IDIwMTEgRGF0YSBBcnRzIFRlYW0sIEdvb2dsZSBDcmVhdGl2ZSBMYWJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cdFxuXHR2YXIgX2NzcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuXHRcblx0dmFyIF9jc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3NzKTtcblx0XG5cdHZhciBfc2F2ZURpYWxvZ3VlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5cdFxuXHR2YXIgX3NhdmVEaWFsb2d1ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zYXZlRGlhbG9ndWUpO1xuXHRcblx0dmFyIF9Db250cm9sbGVyRmFjdG9yeSA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXHRcblx0dmFyIF9Db250cm9sbGVyRmFjdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Db250cm9sbGVyRmFjdG9yeSk7XG5cdFxuXHR2YXIgX0NvbnRyb2xsZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXHRcblx0dmFyIF9Db250cm9sbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NvbnRyb2xsZXIpO1xuXHRcblx0dmFyIF9Cb29sZWFuQ29udHJvbGxlciA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cdFxuXHR2YXIgX0Jvb2xlYW5Db250cm9sbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jvb2xlYW5Db250cm9sbGVyKTtcblx0XG5cdHZhciBfRnVuY3Rpb25Db250cm9sbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cdFxuXHR2YXIgX0Z1bmN0aW9uQ29udHJvbGxlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9GdW5jdGlvbkNvbnRyb2xsZXIpO1xuXHRcblx0dmFyIF9OdW1iZXJDb250cm9sbGVyQm94ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cdFxuXHR2YXIgX051bWJlckNvbnRyb2xsZXJCb3gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTnVtYmVyQ29udHJvbGxlckJveCk7XG5cdFxuXHR2YXIgX051bWJlckNvbnRyb2xsZXJTbGlkZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblx0XG5cdHZhciBfTnVtYmVyQ29udHJvbGxlclNsaWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9OdW1iZXJDb250cm9sbGVyU2xpZGVyKTtcblx0XG5cdHZhciBfQ29sb3JDb250cm9sbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cdFxuXHR2YXIgX0NvbG9yQ29udHJvbGxlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Db2xvckNvbnRyb2xsZXIpO1xuXHRcblx0dmFyIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcblx0XG5cdHZhciBfcmVxdWVzdEFuaW1hdGlvbkZyYW1lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlcXVlc3RBbmltYXRpb25GcmFtZSk7XG5cdFxuXHR2YXIgX0NlbnRlcmVkRGl2ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG5cdFxuXHR2YXIgX0NlbnRlcmVkRGl2MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NlbnRlcmVkRGl2KTtcblx0XG5cdHZhciBfZG9tID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblx0XG5cdHZhciBfZG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RvbSk7XG5cdFxuXHR2YXIgX2NvbW1vbiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdFxuXHR2YXIgX2NvbW1vbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21tb24pO1xuXHRcblx0dmFyIF9zdHlsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuXHRcblx0dmFyIF9zdHlsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdHlsZSk7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXHRcblx0Ly8gQ1NTIHRvIGVtYmVkIGluIGJ1aWxkXG5cdFxuXHRfY3NzMi5kZWZhdWx0LmluamVjdChfc3R5bGUyLmRlZmF1bHQpO1xuXHRcblx0LyoqIE91dGVyLW1vc3QgY2xhc3NOYW1lIGZvciBHVUkncyAqL1xuXHR2YXIgQ1NTX05BTUVTUEFDRSA9ICdkZyc7XG5cdFxuXHR2YXIgSElERV9LRVlfQ09ERSA9IDcyO1xuXHRcblx0LyoqIFRoZSBvbmx5IHZhbHVlIHNoYXJlZCBiZXR3ZWVuIHRoZSBKUyBhbmQgU0NTUy4gVXNlIGNhdXRpb24uICovXG5cdHZhciBDTE9TRV9CVVRUT05fSEVJR0hUID0gMjA7XG5cdFxuXHR2YXIgREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FID0gJ0RlZmF1bHQnO1xuXHRcblx0dmFyIFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdHJ5IHtcblx0ICAgIHJldHVybiAnbG9jYWxTdG9yYWdlJyBpbiB3aW5kb3cgJiYgd2luZG93LmxvY2FsU3RvcmFnZSAhPT0gbnVsbDtcblx0ICB9IGNhdGNoIChlKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHR9KCk7XG5cdFxuXHR2YXIgU0FWRV9ESUFMT0dVRSA9IHZvaWQgMDtcblx0XG5cdC8qKiBIYXZlIHdlIHlldCB0byBjcmVhdGUgYW4gYXV0b1BsYWNlIEdVST8gKi9cblx0dmFyIGF1dG9QbGFjZVZpcmdpbiA9IHRydWU7XG5cdFxuXHQvKiogRml4ZWQgcG9zaXRpb24gZGl2IHRoYXQgYXV0byBwbGFjZSBHVUkncyBnbyBpbnNpZGUgKi9cblx0dmFyIGF1dG9QbGFjZUNvbnRhaW5lciA9IHZvaWQgMDtcblx0XG5cdC8qKiBBcmUgd2UgaGlkaW5nIHRoZSBHVUkncyA/ICovXG5cdHZhciBoaWRlID0gZmFsc2U7XG5cdFxuXHQvKiogR1VJJ3Mgd2hpY2ggc2hvdWxkIGJlIGhpZGRlbiAqL1xuXHR2YXIgaGlkZWFibGVHdWlzID0gW107XG5cdFxuXHQvKipcblx0ICogQSBsaWdodHdlaWdodCBjb250cm9sbGVyIGxpYnJhcnkgZm9yIEphdmFTY3JpcHQuIEl0IGFsbG93cyB5b3UgdG8gZWFzaWx5XG5cdCAqIG1hbmlwdWxhdGUgdmFyaWFibGVzIGFuZCBmaXJlIGZ1bmN0aW9ucyBvbiB0aGUgZmx5LlxuXHQgKiBAY2xhc3Ncblx0ICpcblx0ICogQG1lbWJlciBkYXQuZ3VpXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy5uYW1lXSBUaGUgbmFtZSBvZiB0aGlzIEdVSS5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXMubG9hZF0gSlNPTiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzYXZlZCBzdGF0ZSBvZlxuXHQgKiB0aGlzIEdVSS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLmF1dG89dHJ1ZV1cblx0ICogQHBhcmFtIHtkYXQuZ3VpLkdVSX0gW3BhcmFtcy5wYXJlbnRdIFRoZSBHVUkgSSdtIG5lc3RlZCBpbi5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLmNsb3NlZF0gSWYgdHJ1ZSwgc3RhcnRzIGNsb3NlZFxuXHQgKi9cblx0dmFyIEdVSSA9IGZ1bmN0aW9uIEdVSShwYXJzKSB7XG5cdCAgdmFyIF90aGlzID0gdGhpcztcblx0XG5cdCAgdmFyIHBhcmFtcyA9IHBhcnMgfHwge307XG5cdFxuXHQgIC8qKlxuXHQgICAqIE91dGVybW9zdCBET00gRWxlbWVudFxuXHQgICAqIEB0eXBlIERPTUVsZW1lbnRcblx0ICAgKi9cblx0ICB0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0ICB0aGlzLl9fdWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuXHQgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9fdWwpO1xuXHRcblx0ICBfZG9tMi5kZWZhdWx0LmFkZENsYXNzKHRoaXMuZG9tRWxlbWVudCwgQ1NTX05BTUVTUEFDRSk7XG5cdFxuXHQgIC8qKlxuXHQgICAqIE5lc3RlZCBHVUkncyBieSBuYW1lXG5cdCAgICogQGlnbm9yZVxuXHQgICAqL1xuXHQgIHRoaXMuX19mb2xkZXJzID0ge307XG5cdFxuXHQgIHRoaXMuX19jb250cm9sbGVycyA9IFtdO1xuXHRcblx0ICAvKipcblx0ICAgKiBMaXN0IG9mIG9iamVjdHMgSSdtIHJlbWVtYmVyaW5nIGZvciBzYXZlLCBvbmx5IHVzZWQgaW4gdG9wIGxldmVsIEdVSVxuXHQgICAqIEBpZ25vcmVcblx0ICAgKi9cblx0ICB0aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMgPSBbXTtcblx0XG5cdCAgLyoqXG5cdCAgICogTWFwcyB0aGUgaW5kZXggb2YgcmVtZW1iZXJlZCBvYmplY3RzIHRvIGEgbWFwIG9mIGNvbnRyb2xsZXJzLCBvbmx5IHVzZWRcblx0ICAgKiBpbiB0b3AgbGV2ZWwgR1VJLlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKiBAaWdub3JlXG5cdCAgICpcblx0ICAgKiBAZXhhbXBsZVxuXHQgICAqIFtcblx0ICAgKiAge1xuXHQgICAgICogICAgcHJvcGVydHlOYW1lOiBDb250cm9sbGVyLFxuXHQgICAgICogICAgYW5vdGhlclByb3BlcnR5TmFtZTogQ29udHJvbGxlclxuXHQgICAgICogIH0sXG5cdCAgICogIHtcblx0ICAgICAqICAgIHByb3BlcnR5TmFtZTogQ29udHJvbGxlclxuXHQgICAgICogIH1cblx0ICAgKiBdXG5cdCAgICovXG5cdCAgdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RJbmRlY2VzVG9Db250cm9sbGVycyA9IFtdO1xuXHRcblx0ICB0aGlzLl9fbGlzdGVuaW5nID0gW107XG5cdFxuXHQgIC8vIERlZmF1bHQgcGFyYW1ldGVyc1xuXHQgIHBhcmFtcyA9IF9jb21tb24yLmRlZmF1bHQuZGVmYXVsdHMocGFyYW1zLCB7XG5cdCAgICBhdXRvUGxhY2U6IHRydWUsXG5cdCAgICB3aWR0aDogR1VJLkRFRkFVTFRfV0lEVEhcblx0ICB9KTtcblx0XG5cdCAgcGFyYW1zID0gX2NvbW1vbjIuZGVmYXVsdC5kZWZhdWx0cyhwYXJhbXMsIHtcblx0ICAgIHJlc2l6YWJsZTogcGFyYW1zLmF1dG9QbGFjZSxcblx0ICAgIGhpZGVhYmxlOiBwYXJhbXMuYXV0b1BsYWNlXG5cdCAgfSk7XG5cdFxuXHQgIGlmICghX2NvbW1vbjIuZGVmYXVsdC5pc1VuZGVmaW5lZChwYXJhbXMubG9hZCkpIHtcblx0ICAgIC8vIEV4cGxpY2l0IHByZXNldFxuXHQgICAgaWYgKHBhcmFtcy5wcmVzZXQpIHtcblx0ICAgICAgcGFyYW1zLmxvYWQucHJlc2V0ID0gcGFyYW1zLnByZXNldDtcblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAgcGFyYW1zLmxvYWQgPSB7IHByZXNldDogREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FIH07XG5cdCAgfVxuXHRcblx0ICBpZiAoX2NvbW1vbjIuZGVmYXVsdC5pc1VuZGVmaW5lZChwYXJhbXMucGFyZW50KSAmJiBwYXJhbXMuaGlkZWFibGUpIHtcblx0ICAgIGhpZGVhYmxlR3Vpcy5wdXNoKHRoaXMpO1xuXHQgIH1cblx0XG5cdCAgLy8gT25seSByb290IGxldmVsIEdVSSdzIGFyZSByZXNpemFibGUuXG5cdCAgcGFyYW1zLnJlc2l6YWJsZSA9IF9jb21tb24yLmRlZmF1bHQuaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkgJiYgcGFyYW1zLnJlc2l6YWJsZTtcblx0XG5cdCAgaWYgKHBhcmFtcy5hdXRvUGxhY2UgJiYgX2NvbW1vbjIuZGVmYXVsdC5pc1VuZGVmaW5lZChwYXJhbXMuc2Nyb2xsYWJsZSkpIHtcblx0ICAgIHBhcmFtcy5zY3JvbGxhYmxlID0gdHJ1ZTtcblx0ICB9XG5cdCAgLy8gICAgcGFyYW1zLnNjcm9sbGFibGUgPSBjb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkgJiYgcGFyYW1zLnNjcm9sbGFibGUgPT09IHRydWU7XG5cdFxuXHQgIC8vIE5vdCBwYXJ0IG9mIHBhcmFtcyBiZWNhdXNlIEkgZG9uJ3Qgd2FudCBwZW9wbGUgcGFzc2luZyB0aGlzIGluIHZpYVxuXHQgIC8vIGNvbnN0cnVjdG9yLiBTaG91bGQgYmUgYSAncmVtZW1iZXJlZCcgdmFsdWUuXG5cdCAgdmFyIHVzZUxvY2FsU3RvcmFnZSA9IFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UgJiYgbG9jYWxTdG9yYWdlLmdldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaCh0aGlzLCAnaXNMb2NhbCcpKSA9PT0gJ3RydWUnO1xuXHRcblx0ICB2YXIgc2F2ZVRvTG9jYWxTdG9yYWdlID0gdm9pZCAwO1xuXHRcblx0ICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLFxuXHQgIC8qKiBAbGVuZHMgZGF0Lmd1aS5HVUkucHJvdG90eXBlICovXG5cdCAge1xuXHQgICAgLyoqXG5cdCAgICAgKiBUaGUgcGFyZW50IDxjb2RlPkdVSTwvY29kZT5cblx0ICAgICAqIEB0eXBlIGRhdC5ndWkuR1VJXG5cdCAgICAgKi9cblx0ICAgIHBhcmVudDoge1xuXHQgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgICByZXR1cm4gcGFyYW1zLnBhcmVudDtcblx0ICAgICAgfVxuXHQgICAgfSxcblx0XG5cdCAgICBzY3JvbGxhYmxlOiB7XG5cdCAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICAgIHJldHVybiBwYXJhbXMuc2Nyb2xsYWJsZTtcblx0ICAgICAgfVxuXHQgICAgfSxcblx0XG5cdCAgICAvKipcblx0ICAgICAqIEhhbmRsZXMgPGNvZGU+R1VJPC9jb2RlPidzIGVsZW1lbnQgcGxhY2VtZW50IGZvciB5b3Vcblx0ICAgICAqIEB0eXBlIEJvb2xlYW5cblx0ICAgICAqL1xuXHQgICAgYXV0b1BsYWNlOiB7XG5cdCAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICAgIHJldHVybiBwYXJhbXMuYXV0b1BsYWNlO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVGhlIGlkZW50aWZpZXIgZm9yIGEgc2V0IG9mIHNhdmVkIHZhbHVlc1xuXHQgICAgICogQHR5cGUgU3RyaW5nXG5cdCAgICAgKi9cblx0ICAgIHByZXNldDoge1xuXHQgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgICBpZiAoX3RoaXMucGFyZW50KSB7XG5cdCAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0Um9vdCgpLnByZXNldDtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIHJldHVybiBwYXJhbXMubG9hZC5wcmVzZXQ7XG5cdCAgICAgIH0sXG5cdFxuXHQgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2KSB7XG5cdCAgICAgICAgaWYgKF90aGlzLnBhcmVudCkge1xuXHQgICAgICAgICAgX3RoaXMuZ2V0Um9vdCgpLnByZXNldCA9IHY7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHBhcmFtcy5sb2FkLnByZXNldCA9IHY7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHNldFByZXNldFNlbGVjdEluZGV4KHRoaXMpO1xuXHQgICAgICAgIF90aGlzLnJldmVydCgpO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVGhlIHdpZHRoIG9mIDxjb2RlPkdVSTwvY29kZT4gZWxlbWVudFxuXHQgICAgICogQHR5cGUgTnVtYmVyXG5cdCAgICAgKi9cblx0ICAgIHdpZHRoOiB7XG5cdCAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICAgIHJldHVybiBwYXJhbXMud2lkdGg7XG5cdCAgICAgIH0sXG5cdCAgICAgIHNldDogZnVuY3Rpb24gc2V0KHYpIHtcblx0ICAgICAgICBwYXJhbXMud2lkdGggPSB2O1xuXHQgICAgICAgIHNldFdpZHRoKF90aGlzLCB2KTtcblx0ICAgICAgfVxuXHQgICAgfSxcblx0XG5cdCAgICAvKipcblx0ICAgICAqIFRoZSBuYW1lIG9mIDxjb2RlPkdVSTwvY29kZT4uIFVzZWQgZm9yIGZvbGRlcnMuIGkuZVxuXHQgICAgICogYSBmb2xkZXIncyBuYW1lXG5cdCAgICAgKiBAdHlwZSBTdHJpbmdcblx0ICAgICAqL1xuXHQgICAgbmFtZToge1xuXHQgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgICByZXR1cm4gcGFyYW1zLm5hbWU7XG5cdCAgICAgIH0sXG5cdCAgICAgIHNldDogZnVuY3Rpb24gc2V0KHYpIHtcblx0ICAgICAgICAvLyBUT0RPIENoZWNrIGZvciBjb2xsaXNpb25zIGFtb25nIHNpYmxpbmcgZm9sZGVyc1xuXHQgICAgICAgIHBhcmFtcy5uYW1lID0gdjtcblx0ICAgICAgICBpZiAodGl0bGVSb3dOYW1lKSB7XG5cdCAgICAgICAgICB0aXRsZVJvd05hbWUuaW5uZXJIVE1MID0gcGFyYW1zLm5hbWU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9LFxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogV2hldGhlciB0aGUgPGNvZGU+R1VJPC9jb2RlPiBpcyBjb2xsYXBzZWQgb3Igbm90XG5cdCAgICAgKiBAdHlwZSBCb29sZWFuXG5cdCAgICAgKi9cblx0ICAgIGNsb3NlZDoge1xuXHQgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgICByZXR1cm4gcGFyYW1zLmNsb3NlZDtcblx0ICAgICAgfSxcblx0ICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodikge1xuXHQgICAgICAgIHBhcmFtcy5jbG9zZWQgPSB2O1xuXHQgICAgICAgIGlmIChwYXJhbXMuY2xvc2VkKSB7XG5cdCAgICAgICAgICBfZG9tMi5kZWZhdWx0LmFkZENsYXNzKF90aGlzLl9fdWwsIEdVSS5DTEFTU19DTE9TRUQpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBfZG9tMi5kZWZhdWx0LnJlbW92ZUNsYXNzKF90aGlzLl9fdWwsIEdVSS5DTEFTU19DTE9TRUQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBGb3IgYnJvd3NlcnMgdGhhdCBhcmVuJ3QgZ29pbmcgdG8gcmVzcGVjdCB0aGUgQ1NTIHRyYW5zaXRpb24sXG5cdCAgICAgICAgLy8gTGV0cyBqdXN0IGNoZWNrIG91ciBoZWlnaHQgYWdhaW5zdCB0aGUgd2luZG93IGhlaWdodCByaWdodCBvZmZcblx0ICAgICAgICAvLyB0aGUgYmF0LlxuXHQgICAgICAgIHRoaXMub25SZXNpemUoKTtcblx0XG5cdCAgICAgICAgaWYgKF90aGlzLl9fY2xvc2VCdXR0b24pIHtcblx0ICAgICAgICAgIF90aGlzLl9fY2xvc2VCdXR0b24uaW5uZXJIVE1MID0gdiA/IEdVSS5URVhUX09QRU4gOiBHVUkuVEVYVF9DTE9TRUQ7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9LFxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ29udGFpbnMgYWxsIHByZXNldHNcblx0ICAgICAqIEB0eXBlIE9iamVjdFxuXHQgICAgICovXG5cdCAgICBsb2FkOiB7XG5cdCAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICAgIHJldHVybiBwYXJhbXMubG9hZDtcblx0ICAgICAgfVxuXHQgICAgfSxcblx0XG5cdCAgICAvKipcblx0ICAgICAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdG8gdXNlIDxhIGhyZWY9XCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vU3RvcmFnZSNsb2NhbFN0b3JhZ2VcIj5sb2NhbFN0b3JhZ2U8L2E+IGFzIHRoZSBtZWFucyBmb3Jcblx0ICAgICAqIDxjb2RlPnJlbWVtYmVyPC9jb2RlPmluZ1xuXHQgICAgICogQHR5cGUgQm9vbGVhblxuXHQgICAgICovXG5cdCAgICB1c2VMb2NhbFN0b3JhZ2U6IHtcblx0XG5cdCAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICAgIHJldHVybiB1c2VMb2NhbFN0b3JhZ2U7XG5cdCAgICAgIH0sXG5cdCAgICAgIHNldDogZnVuY3Rpb24gc2V0KGJvb2wpIHtcblx0ICAgICAgICBpZiAoU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSkge1xuXHQgICAgICAgICAgdXNlTG9jYWxTdG9yYWdlID0gYm9vbDtcblx0ICAgICAgICAgIGlmIChib29sKSB7XG5cdCAgICAgICAgICAgIF9kb20yLmRlZmF1bHQuYmluZCh3aW5kb3csICd1bmxvYWQnLCBzYXZlVG9Mb2NhbFN0b3JhZ2UpO1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgX2RvbTIuZGVmYXVsdC51bmJpbmQod2luZG93LCAndW5sb2FkJywgc2F2ZVRvTG9jYWxTdG9yYWdlKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2goX3RoaXMsICdpc0xvY2FsJyksIGJvb2wpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICAvLyBBcmUgd2UgYSByb290IGxldmVsIEdVST9cblx0ICBpZiAoX2NvbW1vbjIuZGVmYXVsdC5pc1VuZGVmaW5lZChwYXJhbXMucGFyZW50KSkge1xuXHQgICAgcGFyYW1zLmNsb3NlZCA9IGZhbHNlO1xuXHRcblx0ICAgIF9kb20yLmRlZmF1bHQuYWRkQ2xhc3ModGhpcy5kb21FbGVtZW50LCBHVUkuQ0xBU1NfTUFJTik7XG5cdCAgICBfZG9tMi5kZWZhdWx0Lm1ha2VTZWxlY3RhYmxlKHRoaXMuZG9tRWxlbWVudCwgZmFsc2UpO1xuXHRcblx0ICAgIC8vIEFyZSB3ZSBzdXBwb3NlZCB0byBiZSBsb2FkaW5nIGxvY2FsbHk/XG5cdCAgICBpZiAoU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSkge1xuXHQgICAgICBpZiAodXNlTG9jYWxTdG9yYWdlKSB7XG5cdCAgICAgICAgX3RoaXMudXNlTG9jYWxTdG9yYWdlID0gdHJ1ZTtcblx0XG5cdCAgICAgICAgdmFyIHNhdmVkR3VpID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaCh0aGlzLCAnZ3VpJykpO1xuXHRcblx0ICAgICAgICBpZiAoc2F2ZWRHdWkpIHtcblx0ICAgICAgICAgIHBhcmFtcy5sb2FkID0gSlNPTi5wYXJzZShzYXZlZEd1aSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdFxuXHQgICAgdGhpcy5fX2Nsb3NlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdCAgICB0aGlzLl9fY2xvc2VCdXR0b24uaW5uZXJIVE1MID0gR1VJLlRFWFRfQ0xPU0VEO1xuXHQgICAgX2RvbTIuZGVmYXVsdC5hZGRDbGFzcyh0aGlzLl9fY2xvc2VCdXR0b24sIEdVSS5DTEFTU19DTE9TRV9CVVRUT04pO1xuXHQgICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19jbG9zZUJ1dHRvbik7XG5cdFxuXHQgICAgX2RvbTIuZGVmYXVsdC5iaW5kKHRoaXMuX19jbG9zZUJ1dHRvbiwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuXHQgICAgICBfdGhpcy5jbG9zZWQgPSAhX3RoaXMuY2xvc2VkO1xuXHQgICAgfSk7XG5cdCAgICAvLyBPaCwgeW91J3JlIGEgbmVzdGVkIEdVSSFcblx0ICB9IGVsc2Uge1xuXHQgICAgaWYgKHBhcmFtcy5jbG9zZWQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICBwYXJhbXMuY2xvc2VkID0gdHJ1ZTtcblx0ICAgIH1cblx0XG5cdCAgICB2YXIgX3RpdGxlUm93TmFtZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHBhcmFtcy5uYW1lKTtcblx0ICAgIF9kb20yLmRlZmF1bHQuYWRkQ2xhc3MoX3RpdGxlUm93TmFtZSwgJ2NvbnRyb2xsZXItbmFtZScpO1xuXHRcblx0ICAgIHZhciB0aXRsZVJvdyA9IGFkZFJvdyhfdGhpcywgX3RpdGxlUm93TmFtZSk7XG5cdFxuXHQgICAgdmFyIG9uQ2xpY2tUaXRsZSA9IGZ1bmN0aW9uIG9uQ2xpY2tUaXRsZShlKSB7XG5cdCAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblx0ICAgICAgX3RoaXMuY2xvc2VkID0gIV90aGlzLmNsb3NlZDtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfTtcblx0XG5cdCAgICBfZG9tMi5kZWZhdWx0LmFkZENsYXNzKHRoaXMuX191bCwgR1VJLkNMQVNTX0NMT1NFRCk7XG5cdFxuXHQgICAgX2RvbTIuZGVmYXVsdC5hZGRDbGFzcyh0aXRsZVJvdywgJ3RpdGxlJyk7XG5cdCAgICBfZG9tMi5kZWZhdWx0LmJpbmQodGl0bGVSb3csICdjbGljaycsIG9uQ2xpY2tUaXRsZSk7XG5cdFxuXHQgICAgaWYgKCFwYXJhbXMuY2xvc2VkKSB7XG5cdCAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG5cdCAgICB9XG5cdCAgfVxuXHRcblx0ICBpZiAocGFyYW1zLmF1dG9QbGFjZSkge1xuXHQgICAgaWYgKF9jb21tb24yLmRlZmF1bHQuaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkpIHtcblx0ICAgICAgaWYgKGF1dG9QbGFjZVZpcmdpbikge1xuXHQgICAgICAgIGF1dG9QbGFjZUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHQgICAgICAgIF9kb20yLmRlZmF1bHQuYWRkQ2xhc3MoYXV0b1BsYWNlQ29udGFpbmVyLCBDU1NfTkFNRVNQQUNFKTtcblx0ICAgICAgICBfZG9tMi5kZWZhdWx0LmFkZENsYXNzKGF1dG9QbGFjZUNvbnRhaW5lciwgR1VJLkNMQVNTX0FVVE9fUExBQ0VfQ09OVEFJTkVSKTtcblx0ICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGF1dG9QbGFjZUNvbnRhaW5lcik7XG5cdCAgICAgICAgYXV0b1BsYWNlVmlyZ2luID0gZmFsc2U7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIC8vIFB1dCBpdCBpbiB0aGUgZG9tIGZvciB5b3UuXG5cdCAgICAgIGF1dG9QbGFjZUNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbUVsZW1lbnQpO1xuXHRcblx0ICAgICAgLy8gQXBwbHkgdGhlIGF1dG8gc3R5bGVzXG5cdCAgICAgIF9kb20yLmRlZmF1bHQuYWRkQ2xhc3ModGhpcy5kb21FbGVtZW50LCBHVUkuQ0xBU1NfQVVUT19QTEFDRSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLy8gTWFrZSBpdCBub3QgZWxhc3RpYy5cblx0ICAgIGlmICghdGhpcy5wYXJlbnQpIHtcblx0ICAgICAgc2V0V2lkdGgoX3RoaXMsIHBhcmFtcy53aWR0aCk7XG5cdCAgICB9XG5cdCAgfVxuXHRcblx0ICB0aGlzLl9fcmVzaXplSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIF90aGlzLm9uUmVzaXplRGVib3VuY2VkKCk7XG5cdCAgfTtcblx0XG5cdCAgX2RvbTIuZGVmYXVsdC5iaW5kKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX19yZXNpemVIYW5kbGVyKTtcblx0ICBfZG9tMi5kZWZhdWx0LmJpbmQodGhpcy5fX3VsLCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIHRoaXMuX19yZXNpemVIYW5kbGVyKTtcblx0ICBfZG9tMi5kZWZhdWx0LmJpbmQodGhpcy5fX3VsLCAndHJhbnNpdGlvbmVuZCcsIHRoaXMuX19yZXNpemVIYW5kbGVyKTtcblx0ICBfZG9tMi5kZWZhdWx0LmJpbmQodGhpcy5fX3VsLCAnb1RyYW5zaXRpb25FbmQnLCB0aGlzLl9fcmVzaXplSGFuZGxlcik7XG5cdCAgdGhpcy5vblJlc2l6ZSgpO1xuXHRcblx0ICBpZiAocGFyYW1zLnJlc2l6YWJsZSkge1xuXHQgICAgYWRkUmVzaXplSGFuZGxlKHRoaXMpO1xuXHQgIH1cblx0XG5cdCAgc2F2ZVRvTG9jYWxTdG9yYWdlID0gZnVuY3Rpb24gc2F2ZVRvTG9jYWxTdG9yYWdlKCkge1xuXHQgICAgaWYgKFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UgJiYgbG9jYWxTdG9yYWdlLmdldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaChfdGhpcywgJ2lzTG9jYWwnKSkgPT09ICd0cnVlJykge1xuXHQgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKF90aGlzLCAnZ3VpJyksIEpTT04uc3RyaW5naWZ5KF90aGlzLmdldFNhdmVPYmplY3QoKSkpO1xuXHQgICAgfVxuXHQgIH07XG5cdFxuXHQgIC8vIGV4cG9zZSB0aGlzIG1ldGhvZCBwdWJsaWNseVxuXHQgIHRoaXMuc2F2ZVRvTG9jYWxTdG9yYWdlSWZQb3NzaWJsZSA9IHNhdmVUb0xvY2FsU3RvcmFnZTtcblx0XG5cdCAgZnVuY3Rpb24gcmVzZXRXaWR0aCgpIHtcblx0ICAgIHZhciByb290ID0gX3RoaXMuZ2V0Um9vdCgpO1xuXHQgICAgcm9vdC53aWR0aCArPSAxO1xuXHQgICAgX2NvbW1vbjIuZGVmYXVsdC5kZWZlcihmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJvb3Qud2lkdGggLT0gMTtcblx0ICAgIH0pO1xuXHQgIH1cblx0XG5cdCAgaWYgKCFwYXJhbXMucGFyZW50KSB7XG5cdCAgICByZXNldFdpZHRoKCk7XG5cdCAgfVxuXHR9O1xuXHRcblx0R1VJLnRvZ2dsZUhpZGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgaGlkZSA9ICFoaWRlO1xuXHQgIF9jb21tb24yLmRlZmF1bHQuZWFjaChoaWRlYWJsZUd1aXMsIGZ1bmN0aW9uIChndWkpIHtcblx0ICAgIGd1aS5kb21FbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBoaWRlID8gJ25vbmUnIDogJyc7XG5cdCAgfSk7XG5cdH07XG5cdFxuXHRHVUkuQ0xBU1NfQVVUT19QTEFDRSA9ICdhJztcblx0R1VJLkNMQVNTX0FVVE9fUExBQ0VfQ09OVEFJTkVSID0gJ2FjJztcblx0R1VJLkNMQVNTX01BSU4gPSAnbWFpbic7XG5cdEdVSS5DTEFTU19DT05UUk9MTEVSX1JPVyA9ICdjcic7XG5cdEdVSS5DTEFTU19UT09fVEFMTCA9ICd0YWxsZXItdGhhbi13aW5kb3cnO1xuXHRHVUkuQ0xBU1NfQ0xPU0VEID0gJ2Nsb3NlZCc7XG5cdEdVSS5DTEFTU19DTE9TRV9CVVRUT04gPSAnY2xvc2UtYnV0dG9uJztcblx0R1VJLkNMQVNTX0RSQUcgPSAnZHJhZyc7XG5cdFxuXHRHVUkuREVGQVVMVF9XSURUSCA9IDI0NTtcblx0R1VJLlRFWFRfQ0xPU0VEID0gJ0Nsb3NlIENvbnRyb2xzJztcblx0R1VJLlRFWFRfT1BFTiA9ICdPcGVuIENvbnRyb2xzJztcblx0XG5cdEdVSS5fa2V5ZG93bkhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuXHQgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50LnR5cGUgIT09ICd0ZXh0JyAmJiAoZS53aGljaCA9PT0gSElERV9LRVlfQ09ERSB8fCBlLmtleUNvZGUgPT09IEhJREVfS0VZX0NPREUpKSB7XG5cdCAgICBHVUkudG9nZ2xlSGlkZSgpO1xuXHQgIH1cblx0fTtcblx0X2RvbTIuZGVmYXVsdC5iaW5kKHdpbmRvdywgJ2tleWRvd24nLCBHVUkuX2tleWRvd25IYW5kbGVyLCBmYWxzZSk7XG5cdFxuXHRfY29tbW9uMi5kZWZhdWx0LmV4dGVuZChHVUkucHJvdG90eXBlLFxuXHRcblx0LyoqIEBsZW5kcyBkYXQuZ3VpLkdVSSAqL1xuXHR7XG5cdFxuXHQgIC8qKlxuXHQgICAqIEBwYXJhbSBvYmplY3Rcblx0ICAgKiBAcGFyYW0gcHJvcGVydHlcblx0ICAgKiBAcmV0dXJucyB7ZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJ9IFRoZSBuZXcgY29udHJvbGxlciB0aGF0IHdhcyBhZGRlZC5cblx0ICAgKiBAaW5zdGFuY2Vcblx0ICAgKi9cblx0ICBhZGQ6IGZ1bmN0aW9uIGFkZChvYmplY3QsIHByb3BlcnR5KSB7XG5cdCAgICByZXR1cm4gX2FkZCh0aGlzLCBvYmplY3QsIHByb3BlcnR5LCB7XG5cdCAgICAgIGZhY3RvcnlBcmdzOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpXG5cdCAgICB9KTtcblx0ICB9LFxuXHRcblx0ICAvKipcblx0ICAgKiBAcGFyYW0gb2JqZWN0XG5cdCAgICogQHBhcmFtIHByb3BlcnR5XG5cdCAgICogQHJldHVybnMge2RhdC5jb250cm9sbGVycy5Db2xvckNvbnRyb2xsZXJ9IFRoZSBuZXcgY29udHJvbGxlciB0aGF0IHdhcyBhZGRlZC5cblx0ICAgKiBAaW5zdGFuY2Vcblx0ICAgKi9cblx0ICBhZGRDb2xvcjogZnVuY3Rpb24gYWRkQ29sb3Iob2JqZWN0LCBwcm9wZXJ0eSkge1xuXHQgICAgcmV0dXJuIF9hZGQodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSwge1xuXHQgICAgICBjb2xvcjogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgfSxcblx0XG5cdCAgLyoqXG5cdCAgICogQHBhcmFtIGNvbnRyb2xsZXJcblx0ICAgKiBAaW5zdGFuY2Vcblx0ICAgKi9cblx0ICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShjb250cm9sbGVyKSB7XG5cdCAgICAvLyBUT0RPIGxpc3RlbmluZz9cblx0ICAgIHRoaXMuX191bC5yZW1vdmVDaGlsZChjb250cm9sbGVyLl9fbGkpO1xuXHQgICAgdGhpcy5fX2NvbnRyb2xsZXJzLnNwbGljZSh0aGlzLl9fY29udHJvbGxlcnMuaW5kZXhPZihjb250cm9sbGVyKSwgMSk7XG5cdCAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgX2NvbW1vbjIuZGVmYXVsdC5kZWZlcihmdW5jdGlvbiAoKSB7XG5cdCAgICAgIF90aGlzLm9uUmVzaXplKCk7XG5cdCAgICB9KTtcblx0ICB9LFxuXHRcblx0ICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuXHQgICAgaWYgKHRoaXMuYXV0b1BsYWNlKSB7XG5cdCAgICAgIGF1dG9QbGFjZUNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLmRvbUVsZW1lbnQpO1xuXHQgICAgfVxuXHRcblx0ICAgIF9kb20yLmRlZmF1bHQudW5iaW5kKHdpbmRvdywgJ2tleWRvd24nLCBHVUkuX2tleWRvd25IYW5kbGVyLCBmYWxzZSk7XG5cdCAgICBfZG9tMi5kZWZhdWx0LnVuYmluZCh3aW5kb3csICdyZXNpemUnLCB0aGlzLl9fcmVzaXplSGFuZGxlcik7XG5cdFxuXHQgICAgaWYgKHRoaXMuc2F2ZVRvTG9jYWxTdG9yYWdlSWZQb3NzaWJsZSkge1xuXHQgICAgICBfZG9tMi5kZWZhdWx0LnVuYmluZCh3aW5kb3csICd1bmxvYWQnLCB0aGlzLnNhdmVUb0xvY2FsU3RvcmFnZUlmUG9zc2libGUpO1xuXHQgICAgfVxuXHQgIH0sXG5cdFxuXHQgIC8qKlxuXHQgICAqIEBwYXJhbSBuYW1lXG5cdCAgICogQHJldHVybnMge2RhdC5ndWkuR1VJfSBUaGUgbmV3IGZvbGRlci5cblx0ICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhpcyBHVUkgYWxyZWFkeSBoYXMgYSBmb2xkZXIgYnkgdGhlIHNwZWNpZmllZFxuXHQgICAqIG5hbWVcblx0ICAgKiBAaW5zdGFuY2Vcblx0ICAgKi9cblx0ICBhZGRGb2xkZXI6IGZ1bmN0aW9uIGFkZEZvbGRlcihuYW1lKSB7XG5cdCAgICAvLyBXZSBoYXZlIHRvIHByZXZlbnQgY29sbGlzaW9ucyBvbiBuYW1lcyBpbiBvcmRlciB0byBoYXZlIGEga2V5XG5cdCAgICAvLyBieSB3aGljaCB0byByZW1lbWJlciBzYXZlZCB2YWx1ZXNcblx0ICAgIGlmICh0aGlzLl9fZm9sZGVyc1tuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGFscmVhZHkgaGF2ZSBhIGZvbGRlciBpbiB0aGlzIEdVSSBieSB0aGUnICsgJyBuYW1lIFwiJyArIG5hbWUgKyAnXCInKTtcblx0ICAgIH1cblx0XG5cdCAgICB2YXIgbmV3R3VpUGFyYW1zID0geyBuYW1lOiBuYW1lLCBwYXJlbnQ6IHRoaXMgfTtcblx0XG5cdCAgICAvLyBXZSBuZWVkIHRvIHBhc3MgZG93biB0aGUgYXV0b1BsYWNlIHRyYWl0IHNvIHRoYXQgd2UgY2FuXG5cdCAgICAvLyBhdHRhY2ggZXZlbnQgbGlzdGVuZXJzIHRvIG9wZW4vY2xvc2UgZm9sZGVyIGFjdGlvbnMgdG9cblx0ICAgIC8vIGVuc3VyZSB0aGF0IGEgc2Nyb2xsYmFyIGFwcGVhcnMgaWYgdGhlIHdpbmRvdyBpcyB0b28gc2hvcnQuXG5cdCAgICBuZXdHdWlQYXJhbXMuYXV0b1BsYWNlID0gdGhpcy5hdXRvUGxhY2U7XG5cdFxuXHQgICAgLy8gRG8gd2UgaGF2ZSBzYXZlZCBhcHBlYXJhbmNlIGRhdGEgZm9yIHRoaXMgZm9sZGVyP1xuXHQgICAgaWYgKHRoaXMubG9hZCAmJiAvLyBBbnl0aGluZyBsb2FkZWQ/XG5cdCAgICB0aGlzLmxvYWQuZm9sZGVycyAmJiAvLyBXYXMgbXkgcGFyZW50IGEgZGVhZC1lbmQ/XG5cdCAgICB0aGlzLmxvYWQuZm9sZGVyc1tuYW1lXSkge1xuXHQgICAgICAvLyBEaWQgZGFkZHkgcmVtZW1iZXIgbWU/XG5cdCAgICAgIC8vIFN0YXJ0IG1lIGNsb3NlZCBpZiBJIHdhcyBjbG9zZWRcblx0ICAgICAgbmV3R3VpUGFyYW1zLmNsb3NlZCA9IHRoaXMubG9hZC5mb2xkZXJzW25hbWVdLmNsb3NlZDtcblx0XG5cdCAgICAgIC8vIFBhc3MgZG93biB0aGUgbG9hZGVkIGRhdGFcblx0ICAgICAgbmV3R3VpUGFyYW1zLmxvYWQgPSB0aGlzLmxvYWQuZm9sZGVyc1tuYW1lXTtcblx0ICAgIH1cblx0XG5cdCAgICB2YXIgZ3VpID0gbmV3IEdVSShuZXdHdWlQYXJhbXMpO1xuXHQgICAgdGhpcy5fX2ZvbGRlcnNbbmFtZV0gPSBndWk7XG5cdFxuXHQgICAgdmFyIGxpID0gYWRkUm93KHRoaXMsIGd1aS5kb21FbGVtZW50KTtcblx0ICAgIF9kb20yLmRlZmF1bHQuYWRkQ2xhc3MobGksICdmb2xkZXInKTtcblx0ICAgIHJldHVybiBndWk7XG5cdCAgfSxcblx0XG5cdCAgb3BlbjogZnVuY3Rpb24gb3BlbigpIHtcblx0ICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG5cdCAgfSxcblx0XG5cdCAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xuXHQgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuXHQgIH0sXG5cdFxuXHQgIG9uUmVzaXplOiBmdW5jdGlvbiBvblJlc2l6ZSgpIHtcblx0ICAgIC8vIHdlIGRlYm91bmNlIHRoaXMgZnVuY3Rpb24gdG8gcHJldmVudCBwZXJmb3JtYW5jZSBpc3N1ZXMgd2hlbiByb3RhdGluZyBvbiB0YWJsZXQvbW9iaWxlXG5cdCAgICB2YXIgcm9vdCA9IHRoaXMuZ2V0Um9vdCgpO1xuXHQgICAgaWYgKHJvb3Quc2Nyb2xsYWJsZSkge1xuXHQgICAgICB2YXIgdG9wID0gX2RvbTIuZGVmYXVsdC5nZXRPZmZzZXQocm9vdC5fX3VsKS50b3A7XG5cdCAgICAgIHZhciBoID0gMDtcblx0XG5cdCAgICAgIF9jb21tb24yLmRlZmF1bHQuZWFjaChyb290Ll9fdWwuY2hpbGROb2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcblx0ICAgICAgICBpZiAoIShyb290LmF1dG9QbGFjZSAmJiBub2RlID09PSByb290Ll9fc2F2ZV9yb3cpKSB7XG5cdCAgICAgICAgICBoICs9IF9kb20yLmRlZmF1bHQuZ2V0SGVpZ2h0KG5vZGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdFxuXHQgICAgICBpZiAod2luZG93LmlubmVySGVpZ2h0IC0gdG9wIC0gQ0xPU0VfQlVUVE9OX0hFSUdIVCA8IGgpIHtcblx0ICAgICAgICBfZG9tMi5kZWZhdWx0LmFkZENsYXNzKHJvb3QuZG9tRWxlbWVudCwgR1VJLkNMQVNTX1RPT19UQUxMKTtcblx0ICAgICAgICByb290Ll9fdWwuc3R5bGUuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC0gdG9wIC0gQ0xPU0VfQlVUVE9OX0hFSUdIVCArICdweCc7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgX2RvbTIuZGVmYXVsdC5yZW1vdmVDbGFzcyhyb290LmRvbUVsZW1lbnQsIEdVSS5DTEFTU19UT09fVEFMTCk7XG5cdCAgICAgICAgcm9vdC5fX3VsLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcblx0ICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIGlmIChyb290Ll9fcmVzaXplX2hhbmRsZSkge1xuXHQgICAgICBfY29tbW9uMi5kZWZhdWx0LmRlZmVyKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByb290Ll9fcmVzaXplX2hhbmRsZS5zdHlsZS5oZWlnaHQgPSByb290Ll9fdWwub2Zmc2V0SGVpZ2h0ICsgJ3B4Jztcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdFxuXHQgICAgaWYgKHJvb3QuX19jbG9zZUJ1dHRvbikge1xuXHQgICAgICByb290Ll9fY2xvc2VCdXR0b24uc3R5bGUud2lkdGggPSByb290LndpZHRoICsgJ3B4Jztcblx0ICAgIH1cblx0ICB9LFxuXHRcblx0ICBvblJlc2l6ZURlYm91bmNlZDogX2NvbW1vbjIuZGVmYXVsdC5kZWJvdW5jZShmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLm9uUmVzaXplKCk7XG5cdCAgfSwgMjAwKSxcblx0XG5cdCAgLyoqXG5cdCAgICogTWFyayBvYmplY3RzIGZvciBzYXZpbmcuIFRoZSBvcmRlciBvZiB0aGVzZSBvYmplY3RzIGNhbm5vdCBjaGFuZ2UgYXNcblx0ICAgKiB0aGUgR1VJIGdyb3dzLiBXaGVuIHJlbWVtYmVyaW5nIG5ldyBvYmplY3RzLCBhcHBlbmQgdGhlbSB0byB0aGUgZW5kXG5cdCAgICogb2YgdGhlIGxpc3QuXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge09iamVjdC4uLn0gb2JqZWN0c1xuXHQgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiBub3QgY2FsbGVkIG9uIGEgdG9wIGxldmVsIEdVSS5cblx0ICAgKiBAaW5zdGFuY2Vcblx0ICAgKi9cblx0ICByZW1lbWJlcjogZnVuY3Rpb24gcmVtZW1iZXIoKSB7XG5cdCAgICBpZiAoX2NvbW1vbjIuZGVmYXVsdC5pc1VuZGVmaW5lZChTQVZFX0RJQUxPR1VFKSkge1xuXHQgICAgICBTQVZFX0RJQUxPR1VFID0gbmV3IF9DZW50ZXJlZERpdjIuZGVmYXVsdCgpO1xuXHQgICAgICBTQVZFX0RJQUxPR1VFLmRvbUVsZW1lbnQuaW5uZXJIVE1MID0gX3NhdmVEaWFsb2d1ZTIuZGVmYXVsdDtcblx0ICAgIH1cblx0XG5cdCAgICBpZiAodGhpcy5wYXJlbnQpIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2FuIG9ubHkgY2FsbCByZW1lbWJlciBvbiBhIHRvcCBsZXZlbCBHVUkuJyk7XG5cdCAgICB9XG5cdFxuXHQgICAgdmFyIF90aGlzID0gdGhpcztcblx0XG5cdCAgICBfY29tbW9uMi5kZWZhdWx0LmVhY2goQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSwgZnVuY3Rpb24gKG9iamVjdCkge1xuXHQgICAgICBpZiAoX3RoaXMuX19yZW1lbWJlcmVkT2JqZWN0cy5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICBhZGRTYXZlTWVudShfdGhpcyk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKF90aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMuaW5kZXhPZihvYmplY3QpID09PSAtMSkge1xuXHQgICAgICAgIF90aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMucHVzaChvYmplY3QpO1xuXHQgICAgICB9XG5cdCAgICB9KTtcblx0XG5cdCAgICBpZiAodGhpcy5hdXRvUGxhY2UpIHtcblx0ICAgICAgLy8gU2V0IHNhdmUgcm93IHdpZHRoXG5cdCAgICAgIHNldFdpZHRoKHRoaXMsIHRoaXMud2lkdGgpO1xuXHQgICAgfVxuXHQgIH0sXG5cdFxuXHQgIC8qKlxuXHQgICAqIEByZXR1cm5zIHtkYXQuZ3VpLkdVSX0gdGhlIHRvcG1vc3QgcGFyZW50IEdVSSBvZiBhIG5lc3RlZCBHVUkuXG5cdCAgICogQGluc3RhbmNlXG5cdCAgICovXG5cdCAgZ2V0Um9vdDogZnVuY3Rpb24gZ2V0Um9vdCgpIHtcblx0ICAgIHZhciBndWkgPSB0aGlzO1xuXHQgICAgd2hpbGUgKGd1aS5wYXJlbnQpIHtcblx0ICAgICAgZ3VpID0gZ3VpLnBhcmVudDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBndWk7XG5cdCAgfSxcblx0XG5cdCAgLyoqXG5cdCAgICogQHJldHVybnMge09iamVjdH0gYSBKU09OIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgc3RhdGUgb2Zcblx0ICAgKiB0aGlzIEdVSSBhcyB3ZWxsIGFzIGl0cyByZW1lbWJlcmVkIHByb3BlcnRpZXMuXG5cdCAgICogQGluc3RhbmNlXG5cdCAgICovXG5cdCAgZ2V0U2F2ZU9iamVjdDogZnVuY3Rpb24gZ2V0U2F2ZU9iamVjdCgpIHtcblx0ICAgIHZhciB0b1JldHVybiA9IHRoaXMubG9hZDtcblx0ICAgIHRvUmV0dXJuLmNsb3NlZCA9IHRoaXMuY2xvc2VkO1xuXHRcblx0ICAgIC8vIEFtIEkgcmVtZW1iZXJpbmcgYW55IHZhbHVlcz9cblx0ICAgIGlmICh0aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMubGVuZ3RoID4gMCkge1xuXHQgICAgICB0b1JldHVybi5wcmVzZXQgPSB0aGlzLnByZXNldDtcblx0XG5cdCAgICAgIGlmICghdG9SZXR1cm4ucmVtZW1iZXJlZCkge1xuXHQgICAgICAgIHRvUmV0dXJuLnJlbWVtYmVyZWQgPSB7fTtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgdG9SZXR1cm4ucmVtZW1iZXJlZFt0aGlzLnByZXNldF0gPSBnZXRDdXJyZW50UHJlc2V0KHRoaXMpO1xuXHQgICAgfVxuXHRcblx0ICAgIHRvUmV0dXJuLmZvbGRlcnMgPSB7fTtcblx0ICAgIF9jb21tb24yLmRlZmF1bHQuZWFjaCh0aGlzLl9fZm9sZGVycywgZnVuY3Rpb24gKGVsZW1lbnQsIGtleSkge1xuXHQgICAgICB0b1JldHVybi5mb2xkZXJzW2tleV0gPSBlbGVtZW50LmdldFNhdmVPYmplY3QoKTtcblx0ICAgIH0pO1xuXHRcblx0ICAgIHJldHVybiB0b1JldHVybjtcblx0ICB9LFxuXHRcblx0ICBzYXZlOiBmdW5jdGlvbiBzYXZlKCkge1xuXHQgICAgaWYgKCF0aGlzLmxvYWQucmVtZW1iZXJlZCkge1xuXHQgICAgICB0aGlzLmxvYWQucmVtZW1iZXJlZCA9IHt9O1xuXHQgICAgfVxuXHRcblx0ICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkW3RoaXMucHJlc2V0XSA9IGdldEN1cnJlbnRQcmVzZXQodGhpcyk7XG5cdCAgICBtYXJrUHJlc2V0TW9kaWZpZWQodGhpcywgZmFsc2UpO1xuXHQgICAgdGhpcy5zYXZlVG9Mb2NhbFN0b3JhZ2VJZlBvc3NpYmxlKCk7XG5cdCAgfSxcblx0XG5cdCAgc2F2ZUFzOiBmdW5jdGlvbiBzYXZlQXMocHJlc2V0TmFtZSkge1xuXHQgICAgaWYgKCF0aGlzLmxvYWQucmVtZW1iZXJlZCkge1xuXHQgICAgICAvLyBSZXRhaW4gZGVmYXVsdCB2YWx1ZXMgdXBvbiBmaXJzdCBzYXZlXG5cdCAgICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkID0ge307XG5cdCAgICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkW0RFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRV0gPSBnZXRDdXJyZW50UHJlc2V0KHRoaXMsIHRydWUpO1xuXHQgICAgfVxuXHRcblx0ICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkW3ByZXNldE5hbWVdID0gZ2V0Q3VycmVudFByZXNldCh0aGlzKTtcblx0ICAgIHRoaXMucHJlc2V0ID0gcHJlc2V0TmFtZTtcblx0ICAgIGFkZFByZXNldE9wdGlvbih0aGlzLCBwcmVzZXROYW1lLCB0cnVlKTtcblx0ICAgIHRoaXMuc2F2ZVRvTG9jYWxTdG9yYWdlSWZQb3NzaWJsZSgpO1xuXHQgIH0sXG5cdFxuXHQgIHJldmVydDogZnVuY3Rpb24gcmV2ZXJ0KGd1aSkge1xuXHQgICAgX2NvbW1vbjIuZGVmYXVsdC5lYWNoKHRoaXMuX19jb250cm9sbGVycywgZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcblx0ICAgICAgLy8gTWFrZSByZXZlcnQgd29yayBvbiBEZWZhdWx0LlxuXHQgICAgICBpZiAoIXRoaXMuZ2V0Um9vdCgpLmxvYWQucmVtZW1iZXJlZCkge1xuXHQgICAgICAgIGNvbnRyb2xsZXIuc2V0VmFsdWUoY29udHJvbGxlci5pbml0aWFsVmFsdWUpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJlY2FsbFNhdmVkVmFsdWUoZ3VpIHx8IHRoaXMuZ2V0Um9vdCgpLCBjb250cm9sbGVyKTtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgLy8gZmlyZSBvbkZpbmlzaENoYW5nZSBjYWxsYmFja1xuXHQgICAgICBpZiAoY29udHJvbGxlci5fX29uRmluaXNoQ2hhbmdlKSB7XG5cdCAgICAgICAgY29udHJvbGxlci5fX29uRmluaXNoQ2hhbmdlLmNhbGwoY29udHJvbGxlciwgY29udHJvbGxlci5nZXRWYWx1ZSgpKTtcblx0ICAgICAgfVxuXHQgICAgfSwgdGhpcyk7XG5cdFxuXHQgICAgX2NvbW1vbjIuZGVmYXVsdC5lYWNoKHRoaXMuX19mb2xkZXJzLCBmdW5jdGlvbiAoZm9sZGVyKSB7XG5cdCAgICAgIGZvbGRlci5yZXZlcnQoZm9sZGVyKTtcblx0ICAgIH0pO1xuXHRcblx0ICAgIGlmICghZ3VpKSB7XG5cdCAgICAgIG1hcmtQcmVzZXRNb2RpZmllZCh0aGlzLmdldFJvb3QoKSwgZmFsc2UpO1xuXHQgICAgfVxuXHQgIH0sXG5cdFxuXHQgIGxpc3RlbjogZnVuY3Rpb24gbGlzdGVuKGNvbnRyb2xsZXIpIHtcblx0ICAgIHZhciBpbml0ID0gdGhpcy5fX2xpc3RlbmluZy5sZW5ndGggPT09IDA7XG5cdCAgICB0aGlzLl9fbGlzdGVuaW5nLnB1c2goY29udHJvbGxlcik7XG5cdCAgICBpZiAoaW5pdCkge1xuXHQgICAgICB1cGRhdGVEaXNwbGF5cyh0aGlzLl9fbGlzdGVuaW5nKTtcblx0ICAgIH1cblx0ICB9LFxuXHRcblx0ICB1cGRhdGVEaXNwbGF5OiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuXHQgICAgX2NvbW1vbjIuZGVmYXVsdC5lYWNoKHRoaXMuX19jb250cm9sbGVycywgZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcblx0ICAgICAgY29udHJvbGxlci51cGRhdGVEaXNwbGF5KCk7XG5cdCAgICB9KTtcblx0ICAgIF9jb21tb24yLmRlZmF1bHQuZWFjaCh0aGlzLl9fZm9sZGVycywgZnVuY3Rpb24gKGZvbGRlcikge1xuXHQgICAgICBmb2xkZXIudXBkYXRlRGlzcGxheSgpO1xuXHQgICAgfSk7XG5cdCAgfVxuXHR9KTtcblx0XG5cdC8qKlxuXHQgKiBBZGQgYSByb3cgdG8gdGhlIGVuZCBvZiB0aGUgR1VJIG9yIGJlZm9yZSBhbm90aGVyIHJvdy5cblx0ICpcblx0ICogQHBhcmFtIGd1aVxuXHQgKiBAcGFyYW0gW25ld0RvbV0gSWYgc3BlY2lmaWVkLCBpbnNlcnRzIHRoZSBkb20gY29udGVudCBpbiB0aGUgbmV3IHJvd1xuXHQgKiBAcGFyYW0gW2xpQmVmb3JlXSBJZiBzcGVjaWZpZWQsIHBsYWNlcyB0aGUgbmV3IHJvdyBiZWZvcmUgYW5vdGhlciByb3dcblx0ICovXG5cdGZ1bmN0aW9uIGFkZFJvdyhndWksIG5ld0RvbSwgbGlCZWZvcmUpIHtcblx0ICB2YXIgbGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuXHQgIGlmIChuZXdEb20pIHtcblx0ICAgIGxpLmFwcGVuZENoaWxkKG5ld0RvbSk7XG5cdCAgfVxuXHRcblx0ICBpZiAobGlCZWZvcmUpIHtcblx0ICAgIGd1aS5fX3VsLmluc2VydEJlZm9yZShsaSwgbGlCZWZvcmUpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBndWkuX191bC5hcHBlbmRDaGlsZChsaSk7XG5cdCAgfVxuXHQgIGd1aS5vblJlc2l6ZSgpO1xuXHQgIHJldHVybiBsaTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gbWFya1ByZXNldE1vZGlmaWVkKGd1aSwgbW9kaWZpZWQpIHtcblx0ICB2YXIgb3B0ID0gZ3VpLl9fcHJlc2V0X3NlbGVjdFtndWkuX19wcmVzZXRfc2VsZWN0LnNlbGVjdGVkSW5kZXhdO1xuXHRcblx0ICAvLyBjb25zb2xlLmxvZygnbWFyaycsIG1vZGlmaWVkLCBvcHQpO1xuXHQgIGlmIChtb2RpZmllZCkge1xuXHQgICAgb3B0LmlubmVySFRNTCA9IG9wdC52YWx1ZSArICcqJztcblx0ICB9IGVsc2Uge1xuXHQgICAgb3B0LmlubmVySFRNTCA9IG9wdC52YWx1ZTtcblx0ICB9XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGF1Z21lbnRDb250cm9sbGVyKGd1aSwgbGksIGNvbnRyb2xsZXIpIHtcblx0ICBjb250cm9sbGVyLl9fbGkgPSBsaTtcblx0ICBjb250cm9sbGVyLl9fZ3VpID0gZ3VpO1xuXHRcblx0ICBfY29tbW9uMi5kZWZhdWx0LmV4dGVuZChjb250cm9sbGVyLCB7XG5cdCAgICBvcHRpb25zOiBmdW5jdGlvbiBvcHRpb25zKF9vcHRpb25zKSB7XG5cdCAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHQgICAgICAgIHZhciBuZXh0U2libGluZyA9IGNvbnRyb2xsZXIuX19saS5uZXh0RWxlbWVudFNpYmxpbmc7XG5cdCAgICAgICAgY29udHJvbGxlci5yZW1vdmUoKTtcblx0XG5cdCAgICAgICAgcmV0dXJuIF9hZGQoZ3VpLCBjb250cm9sbGVyLm9iamVjdCwgY29udHJvbGxlci5wcm9wZXJ0eSwge1xuXHQgICAgICAgICAgYmVmb3JlOiBuZXh0U2libGluZyxcblx0ICAgICAgICAgIGZhY3RvcnlBcmdzOiBbX2NvbW1vbjIuZGVmYXVsdC50b0FycmF5KGFyZ3VtZW50cyldXG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIGlmIChfY29tbW9uMi5kZWZhdWx0LmlzQXJyYXkoX29wdGlvbnMpIHx8IF9jb21tb24yLmRlZmF1bHQuaXNPYmplY3QoX29wdGlvbnMpKSB7XG5cdCAgICAgICAgdmFyIF9uZXh0U2libGluZyA9IGNvbnRyb2xsZXIuX19saS5uZXh0RWxlbWVudFNpYmxpbmc7XG5cdCAgICAgICAgY29udHJvbGxlci5yZW1vdmUoKTtcblx0XG5cdCAgICAgICAgcmV0dXJuIF9hZGQoZ3VpLCBjb250cm9sbGVyLm9iamVjdCwgY29udHJvbGxlci5wcm9wZXJ0eSwge1xuXHQgICAgICAgICAgYmVmb3JlOiBfbmV4dFNpYmxpbmcsXG5cdCAgICAgICAgICBmYWN0b3J5QXJnczogW19vcHRpb25zXVxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHRcblx0ICAgIG5hbWU6IGZ1bmN0aW9uIG5hbWUodikge1xuXHQgICAgICBjb250cm9sbGVyLl9fbGkuZmlyc3RFbGVtZW50Q2hpbGQuZmlyc3RFbGVtZW50Q2hpbGQuaW5uZXJIVE1MID0gdjtcblx0ICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG5cdCAgICB9LFxuXHRcblx0ICAgIGxpc3RlbjogZnVuY3Rpb24gbGlzdGVuKCkge1xuXHQgICAgICBjb250cm9sbGVyLl9fZ3VpLmxpc3Rlbihjb250cm9sbGVyKTtcblx0ICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG5cdCAgICB9LFxuXHRcblx0ICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuXHQgICAgICBjb250cm9sbGVyLl9fZ3VpLnJlbW92ZShjb250cm9sbGVyKTtcblx0ICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIC8vIEFsbCBzbGlkZXJzIHNob3VsZCBiZSBhY2NvbXBhbmllZCBieSBhIGJveC5cblx0ICBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIF9OdW1iZXJDb250cm9sbGVyU2xpZGVyMi5kZWZhdWx0KSB7XG5cdCAgICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICB2YXIgYm94ID0gbmV3IF9OdW1iZXJDb250cm9sbGVyQm94Mi5kZWZhdWx0KGNvbnRyb2xsZXIub2JqZWN0LCBjb250cm9sbGVyLnByb3BlcnR5LCB7IG1pbjogY29udHJvbGxlci5fX21pbiwgbWF4OiBjb250cm9sbGVyLl9fbWF4LCBzdGVwOiBjb250cm9sbGVyLl9fc3RlcCB9KTtcblx0XG5cdCAgICAgIF9jb21tb24yLmRlZmF1bHQuZWFjaChbJ3VwZGF0ZURpc3BsYXknLCAnb25DaGFuZ2UnLCAnb25GaW5pc2hDaGFuZ2UnLCAnc3RlcCddLCBmdW5jdGlvbiAobWV0aG9kKSB7XG5cdCAgICAgICAgdmFyIHBjID0gY29udHJvbGxlclttZXRob2RdO1xuXHQgICAgICAgIHZhciBwYiA9IGJveFttZXRob2RdO1xuXHQgICAgICAgIGNvbnRyb2xsZXJbbWV0aG9kXSA9IGJveFttZXRob2RdID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHQgICAgICAgICAgcGIuYXBwbHkoYm94LCBhcmdzKTtcblx0ICAgICAgICAgIHJldHVybiBwYy5hcHBseShjb250cm9sbGVyLCBhcmdzKTtcblx0ICAgICAgICB9O1xuXHQgICAgICB9KTtcblx0XG5cdCAgICAgIF9kb20yLmRlZmF1bHQuYWRkQ2xhc3MobGksICdoYXMtc2xpZGVyJyk7XG5cdCAgICAgIGNvbnRyb2xsZXIuZG9tRWxlbWVudC5pbnNlcnRCZWZvcmUoYm94LmRvbUVsZW1lbnQsIGNvbnRyb2xsZXIuZG9tRWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCk7XG5cdCAgICB9KSgpO1xuXHQgIH0gZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIF9OdW1iZXJDb250cm9sbGVyQm94Mi5kZWZhdWx0KSB7XG5cdCAgICB2YXIgciA9IGZ1bmN0aW9uIHIocmV0dXJuZWQpIHtcblx0ICAgICAgLy8gSGF2ZSB3ZSBkZWZpbmVkIGJvdGggYm91bmRhcmllcz9cblx0ICAgICAgaWYgKF9jb21tb24yLmRlZmF1bHQuaXNOdW1iZXIoY29udHJvbGxlci5fX21pbikgJiYgX2NvbW1vbjIuZGVmYXVsdC5pc051bWJlcihjb250cm9sbGVyLl9fbWF4KSkge1xuXHQgICAgICAgIC8vIFdlbGwsIHRoZW4gbGV0cyBqdXN0IHJlcGxhY2UgdGhpcyB3aXRoIGEgc2xpZGVyLlxuXHRcblx0ICAgICAgICAvLyBsZXRzIHJlbWVtYmVyIGlmIHRoZSBvbGQgY29udHJvbGxlciBoYWQgYSBzcGVjaWZpYyBuYW1lIG9yIHdhcyBsaXN0ZW5pbmdcblx0ICAgICAgICB2YXIgb2xkTmFtZSA9IGNvbnRyb2xsZXIuX19saS5maXJzdEVsZW1lbnRDaGlsZC5maXJzdEVsZW1lbnRDaGlsZC5pbm5lckhUTUw7XG5cdCAgICAgICAgdmFyIHdhc0xpc3RlbmluZyA9IGNvbnRyb2xsZXIuX19ndWkuX19saXN0ZW5pbmcuaW5kZXhPZihjb250cm9sbGVyKSA+IC0xO1xuXHRcblx0ICAgICAgICBjb250cm9sbGVyLnJlbW92ZSgpO1xuXHQgICAgICAgIHZhciBuZXdDb250cm9sbGVyID0gX2FkZChndWksIGNvbnRyb2xsZXIub2JqZWN0LCBjb250cm9sbGVyLnByb3BlcnR5LCB7XG5cdCAgICAgICAgICBiZWZvcmU6IGNvbnRyb2xsZXIuX19saS5uZXh0RWxlbWVudFNpYmxpbmcsXG5cdCAgICAgICAgICBmYWN0b3J5QXJnczogW2NvbnRyb2xsZXIuX19taW4sIGNvbnRyb2xsZXIuX19tYXgsIGNvbnRyb2xsZXIuX19zdGVwXVxuXHQgICAgICAgIH0pO1xuXHRcblx0ICAgICAgICBuZXdDb250cm9sbGVyLm5hbWUob2xkTmFtZSk7XG5cdCAgICAgICAgaWYgKHdhc0xpc3RlbmluZykgbmV3Q29udHJvbGxlci5saXN0ZW4oKTtcblx0XG5cdCAgICAgICAgcmV0dXJuIG5ld0NvbnRyb2xsZXI7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHJldHVybiByZXR1cm5lZDtcblx0ICAgIH07XG5cdFxuXHQgICAgY29udHJvbGxlci5taW4gPSBfY29tbW9uMi5kZWZhdWx0LmNvbXBvc2UociwgY29udHJvbGxlci5taW4pO1xuXHQgICAgY29udHJvbGxlci5tYXggPSBfY29tbW9uMi5kZWZhdWx0LmNvbXBvc2UociwgY29udHJvbGxlci5tYXgpO1xuXHQgIH0gZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIF9Cb29sZWFuQ29udHJvbGxlcjIuZGVmYXVsdCkge1xuXHQgICAgX2RvbTIuZGVmYXVsdC5iaW5kKGxpLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIF9kb20yLmRlZmF1bHQuZmFrZUV2ZW50KGNvbnRyb2xsZXIuX19jaGVja2JveCwgJ2NsaWNrJyk7XG5cdCAgICB9KTtcblx0XG5cdCAgICBfZG9tMi5kZWZhdWx0LmJpbmQoY29udHJvbGxlci5fX2NoZWNrYm94LCAnY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuXHQgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpOyAvLyBQcmV2ZW50cyBkb3VibGUtdG9nZ2xlXG5cdCAgICB9KTtcblx0ICB9IGVsc2UgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBfRnVuY3Rpb25Db250cm9sbGVyMi5kZWZhdWx0KSB7XG5cdCAgICBfZG9tMi5kZWZhdWx0LmJpbmQobGksICdjbGljaycsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgX2RvbTIuZGVmYXVsdC5mYWtlRXZlbnQoY29udHJvbGxlci5fX2J1dHRvbiwgJ2NsaWNrJyk7XG5cdCAgICB9KTtcblx0XG5cdCAgICBfZG9tMi5kZWZhdWx0LmJpbmQobGksICdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIF9kb20yLmRlZmF1bHQuYWRkQ2xhc3MoY29udHJvbGxlci5fX2J1dHRvbiwgJ2hvdmVyJyk7XG5cdCAgICB9KTtcblx0XG5cdCAgICBfZG9tMi5kZWZhdWx0LmJpbmQobGksICdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgX2RvbTIuZGVmYXVsdC5yZW1vdmVDbGFzcyhjb250cm9sbGVyLl9fYnV0dG9uLCAnaG92ZXInKTtcblx0ICAgIH0pO1xuXHQgIH0gZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIF9Db2xvckNvbnRyb2xsZXIyLmRlZmF1bHQpIHtcblx0ICAgIF9kb20yLmRlZmF1bHQuYWRkQ2xhc3MobGksICdjb2xvcicpO1xuXHQgICAgY29udHJvbGxlci51cGRhdGVEaXNwbGF5ID0gX2NvbW1vbjIuZGVmYXVsdC5jb21wb3NlKGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgbGkuc3R5bGUuYm9yZGVyTGVmdENvbG9yID0gY29udHJvbGxlci5fX2NvbG9yLnRvU3RyaW5nKCk7XG5cdCAgICAgIHJldHVybiB2YWw7XG5cdCAgICB9LCBjb250cm9sbGVyLnVwZGF0ZURpc3BsYXkpO1xuXHRcblx0ICAgIGNvbnRyb2xsZXIudXBkYXRlRGlzcGxheSgpO1xuXHQgIH1cblx0XG5cdCAgY29udHJvbGxlci5zZXRWYWx1ZSA9IF9jb21tb24yLmRlZmF1bHQuY29tcG9zZShmdW5jdGlvbiAodmFsKSB7XG5cdCAgICBpZiAoZ3VpLmdldFJvb3QoKS5fX3ByZXNldF9zZWxlY3QgJiYgY29udHJvbGxlci5pc01vZGlmaWVkKCkpIHtcblx0ICAgICAgbWFya1ByZXNldE1vZGlmaWVkKGd1aS5nZXRSb290KCksIHRydWUpO1xuXHQgICAgfVxuXHRcblx0ICAgIHJldHVybiB2YWw7XG5cdCAgfSwgY29udHJvbGxlci5zZXRWYWx1ZSk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHJlY2FsbFNhdmVkVmFsdWUoZ3VpLCBjb250cm9sbGVyKSB7XG5cdCAgLy8gRmluZCB0aGUgdG9wbW9zdCBHVUksIHRoYXQncyB3aGVyZSByZW1lbWJlcmVkIG9iamVjdHMgbGl2ZS5cblx0ICB2YXIgcm9vdCA9IGd1aS5nZXRSb290KCk7XG5cdFxuXHQgIC8vIERvZXMgdGhlIG9iamVjdCB3ZSdyZSBjb250cm9sbGluZyBtYXRjaCBhbnl0aGluZyB3ZSd2ZSBiZWVuIHRvbGQgdG9cblx0ICAvLyByZW1lbWJlcj9cblx0ICB2YXIgbWF0Y2hlZEluZGV4ID0gcm9vdC5fX3JlbWVtYmVyZWRPYmplY3RzLmluZGV4T2YoY29udHJvbGxlci5vYmplY3QpO1xuXHRcblx0ICAvLyBXaHkgeWVzLCBpdCBkb2VzIVxuXHQgIGlmIChtYXRjaGVkSW5kZXggIT09IC0xKSB7XG5cdCAgICAvLyBMZXQgbWUgZmV0Y2ggYSBtYXAgb2YgY29udHJvbGxlcnMgZm9yIHRoY29tbW9uLmlzT2JqZWN0LlxuXHQgICAgdmFyIGNvbnRyb2xsZXJNYXAgPSByb290Ll9fcmVtZW1iZXJlZE9iamVjdEluZGVjZXNUb0NvbnRyb2xsZXJzW21hdGNoZWRJbmRleF07XG5cdFxuXHQgICAgLy8gT2hwLCBJIGJlbGlldmUgdGhpcyBpcyB0aGUgZmlyc3QgY29udHJvbGxlciB3ZSd2ZSBjcmVhdGVkIGZvciB0aGlzXG5cdCAgICAvLyBvYmplY3QuIExldHMgbWFrZSB0aGUgbWFwIGZyZXNoLlxuXHQgICAgaWYgKGNvbnRyb2xsZXJNYXAgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICBjb250cm9sbGVyTWFwID0ge307XG5cdCAgICAgIHJvb3QuX19yZW1lbWJlcmVkT2JqZWN0SW5kZWNlc1RvQ29udHJvbGxlcnNbbWF0Y2hlZEluZGV4XSA9IGNvbnRyb2xsZXJNYXA7XG5cdCAgICB9XG5cdFxuXHQgICAgLy8gS2VlcCB0cmFjayBvZiB0aGlzIGNvbnRyb2xsZXJcblx0ICAgIGNvbnRyb2xsZXJNYXBbY29udHJvbGxlci5wcm9wZXJ0eV0gPSBjb250cm9sbGVyO1xuXHRcblx0ICAgIC8vIE9rYXksIG5vdyBoYXZlIHdlIHNhdmVkIGFueSB2YWx1ZXMgZm9yIHRoaXMgY29udHJvbGxlcj9cblx0ICAgIGlmIChyb290LmxvYWQgJiYgcm9vdC5sb2FkLnJlbWVtYmVyZWQpIHtcblx0ICAgICAgdmFyIHByZXNldE1hcCA9IHJvb3QubG9hZC5yZW1lbWJlcmVkO1xuXHRcblx0ICAgICAgLy8gV2hpY2ggcHJlc2V0IGFyZSB3ZSB0cnlpbmcgdG8gbG9hZD9cblx0ICAgICAgdmFyIHByZXNldCA9IHZvaWQgMDtcblx0XG5cdCAgICAgIGlmIChwcmVzZXRNYXBbZ3VpLnByZXNldF0pIHtcblx0ICAgICAgICBwcmVzZXQgPSBwcmVzZXRNYXBbZ3VpLnByZXNldF07XG5cdCAgICAgIH0gZWxzZSBpZiAocHJlc2V0TWFwW0RFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRV0pIHtcblx0ICAgICAgICAvLyBVaGgsIHlvdSBjYW4gaGF2ZSB0aGUgZGVmYXVsdCBpbnN0ZWFkP1xuXHQgICAgICAgIHByZXNldCA9IHByZXNldE1hcFtERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUVdO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIC8vIE5hZGEuXG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICAvLyBEaWQgdGhlIGxvYWRlZCBvYmplY3QgcmVtZW1iZXIgdGhjb21tb24uaXNPYmplY3Q/ICYmICBEaWQgd2UgcmVtZW1iZXIgdGhpcyBwYXJ0aWN1bGFyIHByb3BlcnR5P1xuXHQgICAgICBpZiAocHJlc2V0W21hdGNoZWRJbmRleF0gJiYgcHJlc2V0W21hdGNoZWRJbmRleF1bY29udHJvbGxlci5wcm9wZXJ0eV0gIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIC8vIFdlIGRpZCByZW1lbWJlciBzb21ldGhpbmcgZm9yIHRoaXMgZ3V5IC4uLlxuXHQgICAgICAgIHZhciB2YWx1ZSA9IHByZXNldFttYXRjaGVkSW5kZXhdW2NvbnRyb2xsZXIucHJvcGVydHldO1xuXHRcblx0ICAgICAgICAvLyBBbmQgdGhhdCdzIHdoYXQgaXQgaXMuXG5cdCAgICAgICAgY29udHJvbGxlci5pbml0aWFsVmFsdWUgPSB2YWx1ZTtcblx0ICAgICAgICBjb250cm9sbGVyLnNldFZhbHVlKHZhbHVlKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRcblx0ZnVuY3Rpb24gX2FkZChndWksIG9iamVjdCwgcHJvcGVydHksIHBhcmFtcykge1xuXHQgIGlmIChvYmplY3RbcHJvcGVydHldID09PSB1bmRlZmluZWQpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcignT2JqZWN0IFwiJyArIG9iamVjdCArICdcIiBoYXMgbm8gcHJvcGVydHkgXCInICsgcHJvcGVydHkgKyAnXCInKTtcblx0ICB9XG5cdFxuXHQgIHZhciBjb250cm9sbGVyID0gdm9pZCAwO1xuXHRcblx0ICBpZiAocGFyYW1zLmNvbG9yKSB7XG5cdCAgICBjb250cm9sbGVyID0gbmV3IF9Db2xvckNvbnRyb2xsZXIyLmRlZmF1bHQob2JqZWN0LCBwcm9wZXJ0eSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHZhciBmYWN0b3J5QXJncyA9IFtvYmplY3QsIHByb3BlcnR5XS5jb25jYXQocGFyYW1zLmZhY3RvcnlBcmdzKTtcblx0ICAgIGNvbnRyb2xsZXIgPSBfQ29udHJvbGxlckZhY3RvcnkyLmRlZmF1bHQuYXBwbHkoZ3VpLCBmYWN0b3J5QXJncyk7XG5cdCAgfVxuXHRcblx0ICBpZiAocGFyYW1zLmJlZm9yZSBpbnN0YW5jZW9mIF9Db250cm9sbGVyMi5kZWZhdWx0KSB7XG5cdCAgICBwYXJhbXMuYmVmb3JlID0gcGFyYW1zLmJlZm9yZS5fX2xpO1xuXHQgIH1cblx0XG5cdCAgcmVjYWxsU2F2ZWRWYWx1ZShndWksIGNvbnRyb2xsZXIpO1xuXHRcblx0ICBfZG9tMi5kZWZhdWx0LmFkZENsYXNzKGNvbnRyb2xsZXIuZG9tRWxlbWVudCwgJ2MnKTtcblx0XG5cdCAgdmFyIG5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG5cdCAgX2RvbTIuZGVmYXVsdC5hZGRDbGFzcyhuYW1lLCAncHJvcGVydHktbmFtZScpO1xuXHQgIG5hbWUuaW5uZXJIVE1MID0gY29udHJvbGxlci5wcm9wZXJ0eTtcblx0XG5cdCAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHQgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChuYW1lKTtcblx0ICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY29udHJvbGxlci5kb21FbGVtZW50KTtcblx0XG5cdCAgdmFyIGxpID0gYWRkUm93KGd1aSwgY29udGFpbmVyLCBwYXJhbXMuYmVmb3JlKTtcblx0XG5cdCAgX2RvbTIuZGVmYXVsdC5hZGRDbGFzcyhsaSwgR1VJLkNMQVNTX0NPTlRST0xMRVJfUk9XKTtcblx0ICBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIF9Db2xvckNvbnRyb2xsZXIyLmRlZmF1bHQpIHtcblx0ICAgIF9kb20yLmRlZmF1bHQuYWRkQ2xhc3MobGksICdjb2xvcicpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBfZG9tMi5kZWZhdWx0LmFkZENsYXNzKGxpLCBfdHlwZW9mKGNvbnRyb2xsZXIuZ2V0VmFsdWUoKSkpO1xuXHQgIH1cblx0XG5cdCAgYXVnbWVudENvbnRyb2xsZXIoZ3VpLCBsaSwgY29udHJvbGxlcik7XG5cdFxuXHQgIGd1aS5fX2NvbnRyb2xsZXJzLnB1c2goY29udHJvbGxlcik7XG5cdFxuXHQgIHJldHVybiBjb250cm9sbGVyO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBnZXRMb2NhbFN0b3JhZ2VIYXNoKGd1aSwga2V5KSB7XG5cdCAgLy8gVE9ETyBob3cgZG9lcyB0aGlzIGRlYWwgd2l0aCBtdWx0aXBsZSBHVUkncz9cblx0ICByZXR1cm4gZG9jdW1lbnQubG9jYXRpb24uaHJlZiArICcuJyArIGtleTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gYWRkUHJlc2V0T3B0aW9uKGd1aSwgbmFtZSwgc2V0U2VsZWN0ZWQpIHtcblx0ICB2YXIgb3B0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG5cdCAgb3B0LmlubmVySFRNTCA9IG5hbWU7XG5cdCAgb3B0LnZhbHVlID0gbmFtZTtcblx0ICBndWkuX19wcmVzZXRfc2VsZWN0LmFwcGVuZENoaWxkKG9wdCk7XG5cdCAgaWYgKHNldFNlbGVjdGVkKSB7XG5cdCAgICBndWkuX19wcmVzZXRfc2VsZWN0LnNlbGVjdGVkSW5kZXggPSBndWkuX19wcmVzZXRfc2VsZWN0Lmxlbmd0aCAtIDE7XG5cdCAgfVxuXHR9XG5cdFxuXHRmdW5jdGlvbiBzaG93SGlkZUV4cGxhaW4oZ3VpLCBleHBsYWluKSB7XG5cdCAgZXhwbGFpbi5zdHlsZS5kaXNwbGF5ID0gZ3VpLnVzZUxvY2FsU3RvcmFnZSA/ICdibG9jaycgOiAnbm9uZSc7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGFkZFNhdmVNZW51KGd1aSkge1xuXHQgIHZhciBkaXYgPSBndWkuX19zYXZlX3JvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG5cdFxuXHQgIF9kb20yLmRlZmF1bHQuYWRkQ2xhc3MoZ3VpLmRvbUVsZW1lbnQsICdoYXMtc2F2ZScpO1xuXHRcblx0ICBndWkuX191bC5pbnNlcnRCZWZvcmUoZGl2LCBndWkuX191bC5maXJzdENoaWxkKTtcblx0XG5cdCAgX2RvbTIuZGVmYXVsdC5hZGRDbGFzcyhkaXYsICdzYXZlLXJvdycpO1xuXHRcblx0ICB2YXIgZ2VhcnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG5cdCAgZ2VhcnMuaW5uZXJIVE1MID0gJyZuYnNwOyc7XG5cdCAgX2RvbTIuZGVmYXVsdC5hZGRDbGFzcyhnZWFycywgJ2J1dHRvbiBnZWFycycpO1xuXHRcblx0ICAvLyBUT0RPIHJlcGxhY2Ugd2l0aCBGdW5jdGlvbkNvbnRyb2xsZXJcblx0ICB2YXIgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuXHQgIGJ1dHRvbi5pbm5lckhUTUwgPSAnU2F2ZSc7XG5cdCAgX2RvbTIuZGVmYXVsdC5hZGRDbGFzcyhidXR0b24sICdidXR0b24nKTtcblx0ICBfZG9tMi5kZWZhdWx0LmFkZENsYXNzKGJ1dHRvbiwgJ3NhdmUnKTtcblx0XG5cdCAgdmFyIGJ1dHRvbjIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG5cdCAgYnV0dG9uMi5pbm5lckhUTUwgPSAnTmV3Jztcblx0ICBfZG9tMi5kZWZhdWx0LmFkZENsYXNzKGJ1dHRvbjIsICdidXR0b24nKTtcblx0ICBfZG9tMi5kZWZhdWx0LmFkZENsYXNzKGJ1dHRvbjIsICdzYXZlLWFzJyk7XG5cdFxuXHQgIHZhciBidXR0b24zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuXHQgIGJ1dHRvbjMuaW5uZXJIVE1MID0gJ1JldmVydCc7XG5cdCAgX2RvbTIuZGVmYXVsdC5hZGRDbGFzcyhidXR0b24zLCAnYnV0dG9uJyk7XG5cdCAgX2RvbTIuZGVmYXVsdC5hZGRDbGFzcyhidXR0b24zLCAncmV2ZXJ0Jyk7XG5cdFxuXHQgIHZhciBzZWxlY3QgPSBndWkuX19wcmVzZXRfc2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XG5cdFxuXHQgIGlmIChndWkubG9hZCAmJiBndWkubG9hZC5yZW1lbWJlcmVkKSB7XG5cdCAgICBfY29tbW9uMi5kZWZhdWx0LmVhY2goZ3VpLmxvYWQucmVtZW1iZXJlZCwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcblx0ICAgICAgYWRkUHJlc2V0T3B0aW9uKGd1aSwga2V5LCBrZXkgPT09IGd1aS5wcmVzZXQpO1xuXHQgICAgfSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGFkZFByZXNldE9wdGlvbihndWksIERFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRSwgZmFsc2UpO1xuXHQgIH1cblx0XG5cdCAgX2RvbTIuZGVmYXVsdC5iaW5kKHNlbGVjdCwgJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcblx0ICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBndWkuX19wcmVzZXRfc2VsZWN0Lmxlbmd0aDsgaW5kZXgrKykge1xuXHQgICAgICBndWkuX19wcmVzZXRfc2VsZWN0W2luZGV4XS5pbm5lckhUTUwgPSBndWkuX19wcmVzZXRfc2VsZWN0W2luZGV4XS52YWx1ZTtcblx0ICAgIH1cblx0XG5cdCAgICBndWkucHJlc2V0ID0gdGhpcy52YWx1ZTtcblx0ICB9KTtcblx0XG5cdCAgZGl2LmFwcGVuZENoaWxkKHNlbGVjdCk7XG5cdCAgZGl2LmFwcGVuZENoaWxkKGdlYXJzKTtcblx0ICBkaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcblx0ICBkaXYuYXBwZW5kQ2hpbGQoYnV0dG9uMik7XG5cdCAgZGl2LmFwcGVuZENoaWxkKGJ1dHRvbjMpO1xuXHRcblx0ICBpZiAoU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSkge1xuXHQgICAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIGV4cGxhaW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGctbG9jYWwtZXhwbGFpbicpO1xuXHQgICAgICB2YXIgbG9jYWxTdG9yYWdlQ2hlY2tCb3ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGctbG9jYWwtc3RvcmFnZScpO1xuXHQgICAgICB2YXIgc2F2ZUxvY2FsbHkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGctc2F2ZS1sb2NhbGx5Jyk7XG5cdFxuXHQgICAgICBzYXZlTG9jYWxseS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblx0XG5cdCAgICAgIGlmIChsb2NhbFN0b3JhZ2UuZ2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKGd1aSwgJ2lzTG9jYWwnKSkgPT09ICd0cnVlJykge1xuXHQgICAgICAgIGxvY2FsU3RvcmFnZUNoZWNrQm94LnNldEF0dHJpYnV0ZSgnY2hlY2tlZCcsICdjaGVja2VkJyk7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHNob3dIaWRlRXhwbGFpbihndWksIGV4cGxhaW4pO1xuXHRcblx0ICAgICAgLy8gVE9ETzogVXNlIGEgYm9vbGVhbiBjb250cm9sbGVyLCBmb29sIVxuXHQgICAgICBfZG9tMi5kZWZhdWx0LmJpbmQobG9jYWxTdG9yYWdlQ2hlY2tCb3gsICdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZ3VpLnVzZUxvY2FsU3RvcmFnZSA9ICFndWkudXNlTG9jYWxTdG9yYWdlO1xuXHQgICAgICAgIHNob3dIaWRlRXhwbGFpbihndWksIGV4cGxhaW4pO1xuXHQgICAgICB9KTtcblx0ICAgIH0pKCk7XG5cdCAgfVxuXHRcblx0ICB2YXIgbmV3Q29uc3RydWN0b3JUZXh0QXJlYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZy1uZXctY29uc3RydWN0b3InKTtcblx0XG5cdCAgX2RvbTIuZGVmYXVsdC5iaW5kKG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEsICdrZXlkb3duJywgZnVuY3Rpb24gKGUpIHtcblx0ICAgIGlmIChlLm1ldGFLZXkgJiYgKGUud2hpY2ggPT09IDY3IHx8IGUua2V5Q29kZSA9PT0gNjcpKSB7XG5cdCAgICAgIFNBVkVfRElBTE9HVUUuaGlkZSgpO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBfZG9tMi5kZWZhdWx0LmJpbmQoZ2VhcnMsICdjbGljaycsIGZ1bmN0aW9uICgpIHtcblx0ICAgIG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEuaW5uZXJIVE1MID0gSlNPTi5zdHJpbmdpZnkoZ3VpLmdldFNhdmVPYmplY3QoKSwgdW5kZWZpbmVkLCAyKTtcblx0ICAgIFNBVkVfRElBTE9HVUUuc2hvdygpO1xuXHQgICAgbmV3Q29uc3RydWN0b3JUZXh0QXJlYS5mb2N1cygpO1xuXHQgICAgbmV3Q29uc3RydWN0b3JUZXh0QXJlYS5zZWxlY3QoKTtcblx0ICB9KTtcblx0XG5cdCAgX2RvbTIuZGVmYXVsdC5iaW5kKGJ1dHRvbiwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuXHQgICAgZ3VpLnNhdmUoKTtcblx0ICB9KTtcblx0XG5cdCAgX2RvbTIuZGVmYXVsdC5iaW5kKGJ1dHRvbjIsICdjbGljaycsIGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBwcmVzZXROYW1lID0gcHJvbXB0KCdFbnRlciBhIG5ldyBwcmVzZXQgbmFtZS4nKTtcblx0ICAgIGlmIChwcmVzZXROYW1lKSB7XG5cdCAgICAgIGd1aS5zYXZlQXMocHJlc2V0TmFtZSk7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIF9kb20yLmRlZmF1bHQuYmluZChidXR0b24zLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG5cdCAgICBndWkucmV2ZXJ0KCk7XG5cdCAgfSk7XG5cdFxuXHQgIC8vIGRpdi5hcHBlbmRDaGlsZChidXR0b24yKTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gYWRkUmVzaXplSGFuZGxlKGd1aSkge1xuXHQgIHZhciBwbW91c2VYID0gdm9pZCAwO1xuXHRcblx0ICBndWkuX19yZXNpemVfaGFuZGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFxuXHQgIF9jb21tb24yLmRlZmF1bHQuZXh0ZW5kKGd1aS5fX3Jlc2l6ZV9oYW5kbGUuc3R5bGUsIHtcblx0XG5cdCAgICB3aWR0aDogJzZweCcsXG5cdCAgICBtYXJnaW5MZWZ0OiAnLTNweCcsXG5cdCAgICBoZWlnaHQ6ICcyMDBweCcsXG5cdCAgICBjdXJzb3I6ICdldy1yZXNpemUnLFxuXHQgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcblx0ICAgIC8vIGJvcmRlcjogJzFweCBzb2xpZCBibHVlJ1xuXHRcblx0ICB9KTtcblx0XG5cdCAgZnVuY3Rpb24gZHJhZyhlKSB7XG5cdCAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cdFxuXHQgICAgZ3VpLndpZHRoICs9IHBtb3VzZVggLSBlLmNsaWVudFg7XG5cdCAgICBndWkub25SZXNpemUoKTtcblx0ICAgIHBtb3VzZVggPSBlLmNsaWVudFg7XG5cdFxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gZHJhZ1N0b3AoKSB7XG5cdCAgICBfZG9tMi5kZWZhdWx0LnJlbW92ZUNsYXNzKGd1aS5fX2Nsb3NlQnV0dG9uLCBHVUkuQ0xBU1NfRFJBRyk7XG5cdCAgICBfZG9tMi5kZWZhdWx0LnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBkcmFnKTtcblx0ICAgIF9kb20yLmRlZmF1bHQudW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBkcmFnU3RvcCk7XG5cdCAgfVxuXHRcblx0ICBmdW5jdGlvbiBkcmFnU3RhcnQoZSkge1xuXHQgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcblx0ICAgIHBtb3VzZVggPSBlLmNsaWVudFg7XG5cdFxuXHQgICAgX2RvbTIuZGVmYXVsdC5hZGRDbGFzcyhndWkuX19jbG9zZUJ1dHRvbiwgR1VJLkNMQVNTX0RSQUcpO1xuXHQgICAgX2RvbTIuZGVmYXVsdC5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIGRyYWcpO1xuXHQgICAgX2RvbTIuZGVmYXVsdC5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBkcmFnU3RvcCk7XG5cdFxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0XG5cdCAgX2RvbTIuZGVmYXVsdC5iaW5kKGd1aS5fX3Jlc2l6ZV9oYW5kbGUsICdtb3VzZWRvd24nLCBkcmFnU3RhcnQpO1xuXHQgIF9kb20yLmRlZmF1bHQuYmluZChndWkuX19jbG9zZUJ1dHRvbiwgJ21vdXNlZG93bicsIGRyYWdTdGFydCk7XG5cdFxuXHQgIGd1aS5kb21FbGVtZW50Lmluc2VydEJlZm9yZShndWkuX19yZXNpemVfaGFuZGxlLCBndWkuZG9tRWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHNldFdpZHRoKGd1aSwgdykge1xuXHQgIGd1aS5kb21FbGVtZW50LnN0eWxlLndpZHRoID0gdyArICdweCc7XG5cdCAgLy8gQXV0byBwbGFjZWQgc2F2ZS1yb3dzIGFyZSBwb3NpdGlvbiBmaXhlZCwgc28gd2UgaGF2ZSB0b1xuXHQgIC8vIHNldCB0aGUgd2lkdGggbWFudWFsbHkgaWYgd2Ugd2FudCBpdCB0byBibGVlZCB0byB0aGUgZWRnZVxuXHQgIGlmIChndWkuX19zYXZlX3JvdyAmJiBndWkuYXV0b1BsYWNlKSB7XG5cdCAgICBndWkuX19zYXZlX3Jvdy5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuXHQgIH1cblx0ICBpZiAoZ3VpLl9fY2xvc2VCdXR0b24pIHtcblx0ICAgIGd1aS5fX2Nsb3NlQnV0dG9uLnN0eWxlLndpZHRoID0gdyArICdweCc7XG5cdCAgfVxuXHR9XG5cdFxuXHRmdW5jdGlvbiBnZXRDdXJyZW50UHJlc2V0KGd1aSwgdXNlSW5pdGlhbFZhbHVlcykge1xuXHQgIHZhciB0b1JldHVybiA9IHt9O1xuXHRcblx0ICAvLyBGb3IgZWFjaCBvYmplY3QgSSdtIHJlbWVtYmVyaW5nXG5cdCAgX2NvbW1vbjIuZGVmYXVsdC5lYWNoKGd1aS5fX3JlbWVtYmVyZWRPYmplY3RzLCBmdW5jdGlvbiAodmFsLCBpbmRleCkge1xuXHQgICAgdmFyIHNhdmVkVmFsdWVzID0ge307XG5cdFxuXHQgICAgLy8gVGhlIGNvbnRyb2xsZXJzIEkndmUgbWFkZSBmb3IgdGhjb21tb24uaXNPYmplY3QgYnkgcHJvcGVydHlcblx0ICAgIHZhciBjb250cm9sbGVyTWFwID0gZ3VpLl9fcmVtZW1iZXJlZE9iamVjdEluZGVjZXNUb0NvbnRyb2xsZXJzW2luZGV4XTtcblx0XG5cdCAgICAvLyBSZW1lbWJlciBlYWNoIHZhbHVlIGZvciBlYWNoIHByb3BlcnR5XG5cdCAgICBfY29tbW9uMi5kZWZhdWx0LmVhY2goY29udHJvbGxlck1hcCwgZnVuY3Rpb24gKGNvbnRyb2xsZXIsIHByb3BlcnR5KSB7XG5cdCAgICAgIHNhdmVkVmFsdWVzW3Byb3BlcnR5XSA9IHVzZUluaXRpYWxWYWx1ZXMgPyBjb250cm9sbGVyLmluaXRpYWxWYWx1ZSA6IGNvbnRyb2xsZXIuZ2V0VmFsdWUoKTtcblx0ICAgIH0pO1xuXHRcblx0ICAgIC8vIFNhdmUgdGhlIHZhbHVlcyBmb3IgdGhjb21tb24uaXNPYmplY3Rcblx0ICAgIHRvUmV0dXJuW2luZGV4XSA9IHNhdmVkVmFsdWVzO1xuXHQgIH0pO1xuXHRcblx0ICByZXR1cm4gdG9SZXR1cm47XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHNldFByZXNldFNlbGVjdEluZGV4KGd1aSkge1xuXHQgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBndWkuX19wcmVzZXRfc2VsZWN0Lmxlbmd0aDsgaW5kZXgrKykge1xuXHQgICAgaWYgKGd1aS5fX3ByZXNldF9zZWxlY3RbaW5kZXhdLnZhbHVlID09PSBndWkucHJlc2V0KSB7XG5cdCAgICAgIGd1aS5fX3ByZXNldF9zZWxlY3Quc2VsZWN0ZWRJbmRleCA9IGluZGV4O1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRcblx0ZnVuY3Rpb24gdXBkYXRlRGlzcGxheXMoY29udHJvbGxlckFycmF5KSB7XG5cdCAgaWYgKGNvbnRyb2xsZXJBcnJheS5sZW5ndGggIT09IDApIHtcblx0ICAgIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUyLmRlZmF1bHQuY2FsbCh3aW5kb3csIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdXBkYXRlRGlzcGxheXMoY29udHJvbGxlckFycmF5KTtcblx0ICAgIH0pO1xuXHQgIH1cblx0XG5cdCAgX2NvbW1vbjIuZGVmYXVsdC5lYWNoKGNvbnRyb2xsZXJBcnJheSwgZnVuY3Rpb24gKGMpIHtcblx0ICAgIGMudXBkYXRlRGlzcGxheSgpO1xuXHQgIH0pO1xuXHR9XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IEdVSTtcblxuLyoqKi8gfSxcbi8qIDE4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHQvKipcblx0ICogZGF0LWd1aSBKYXZhU2NyaXB0IENvbnRyb2xsZXIgTGlicmFyeVxuXHQgKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZGF0LWd1aVxuXHQgKlxuXHQgKiBDb3B5cmlnaHQgMjAxMSBEYXRhIEFydHMgVGVhbSwgR29vZ2xlIENyZWF0aXZlIExhYlxuXHQgKlxuXHQgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuXHQgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5cdCAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXHQgKlxuXHQgKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblx0ICovXG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IHtcblx0ICBsb2FkOiBmdW5jdGlvbiBsb2FkKHVybCwgaW5kb2MpIHtcblx0ICAgIHZhciBkb2MgPSBpbmRvYyB8fCBkb2N1bWVudDtcblx0ICAgIHZhciBsaW5rID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtcblx0ICAgIGxpbmsudHlwZSA9ICd0ZXh0L2Nzcyc7XG5cdCAgICBsaW5rLnJlbCA9ICdzdHlsZXNoZWV0Jztcblx0ICAgIGxpbmsuaHJlZiA9IHVybDtcblx0ICAgIGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKGxpbmspO1xuXHQgIH0sXG5cdFxuXHQgIGluamVjdDogZnVuY3Rpb24gaW5qZWN0KGNzcywgaW5kb2MpIHtcblx0ICAgIHZhciBkb2MgPSBpbmRvYyB8fCBkb2N1bWVudDtcblx0ICAgIHZhciBpbmplY3RlZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cdCAgICBpbmplY3RlZC50eXBlID0gJ3RleHQvY3NzJztcblx0ICAgIGluamVjdGVkLmlubmVySFRNTCA9IGNzcztcblx0ICAgIHZhciBoZWFkID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG5cdCAgICB0cnkge1xuXHQgICAgICBoZWFkLmFwcGVuZENoaWxkKGluamVjdGVkKTtcblx0ICAgIH0gY2F0Y2ggKGUpIHsvLyBVbmFibGUgdG8gaW5qZWN0IENTUywgcHJvYmFibHkgYmVjYXVzZSBvZiBhIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG4vKioqLyB9LFxuLyogMTkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGlkPVxcXCJkZy1zYXZlXFxcIiBjbGFzcz1cXFwiZGcgZGlhbG9ndWVcXFwiPlxcblxcbiAgSGVyZSdzIHRoZSBuZXcgbG9hZCBwYXJhbWV0ZXIgZm9yIHlvdXIgPGNvZGU+R1VJPC9jb2RlPidzIGNvbnN0cnVjdG9yOlxcblxcbiAgPHRleHRhcmVhIGlkPVxcXCJkZy1uZXctY29uc3RydWN0b3JcXFwiPjwvdGV4dGFyZWE+XFxuXFxuICA8ZGl2IGlkPVxcXCJkZy1zYXZlLWxvY2FsbHlcXFwiPlxcblxcbiAgICA8aW5wdXQgaWQ9XFxcImRnLWxvY2FsLXN0b3JhZ2VcXFwiIHR5cGU9XFxcImNoZWNrYm94XFxcIi8+IEF1dG9tYXRpY2FsbHkgc2F2ZVxcbiAgICB2YWx1ZXMgdG8gPGNvZGU+bG9jYWxTdG9yYWdlPC9jb2RlPiBvbiBleGl0LlxcblxcbiAgICA8ZGl2IGlkPVxcXCJkZy1sb2NhbC1leHBsYWluXFxcIj5UaGUgdmFsdWVzIHNhdmVkIHRvIDxjb2RlPmxvY2FsU3RvcmFnZTwvY29kZT4gd2lsbFxcbiAgICAgIG92ZXJyaWRlIHRob3NlIHBhc3NlZCB0byA8Y29kZT5kYXQuR1VJPC9jb2RlPidzIGNvbnN0cnVjdG9yLiBUaGlzIG1ha2VzIGl0XFxuICAgICAgZWFzaWVyIHRvIHdvcmsgaW5jcmVtZW50YWxseSwgYnV0IDxjb2RlPmxvY2FsU3RvcmFnZTwvY29kZT4gaXMgZnJhZ2lsZSxcXG4gICAgICBhbmQgeW91ciBmcmllbmRzIG1heSBub3Qgc2VlIHRoZSBzYW1lIHZhbHVlcyB5b3UgZG8uXFxuXFxuICAgIDwvZGl2PlxcblxcbiAgPC9kaXY+XFxuXFxuPC9kaXY+XCI7XG5cbi8qKiovIH0sXG4vKiAyMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblx0XG5cdHZhciBfT3B0aW9uQ29udHJvbGxlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXHRcblx0dmFyIF9PcHRpb25Db250cm9sbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX09wdGlvbkNvbnRyb2xsZXIpO1xuXHRcblx0dmFyIF9OdW1iZXJDb250cm9sbGVyQm94ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cdFxuXHR2YXIgX051bWJlckNvbnRyb2xsZXJCb3gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTnVtYmVyQ29udHJvbGxlckJveCk7XG5cdFxuXHR2YXIgX051bWJlckNvbnRyb2xsZXJTbGlkZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblx0XG5cdHZhciBfTnVtYmVyQ29udHJvbGxlclNsaWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9OdW1iZXJDb250cm9sbGVyU2xpZGVyKTtcblx0XG5cdHZhciBfU3RyaW5nQ29udHJvbGxlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXHRcblx0dmFyIF9TdHJpbmdDb250cm9sbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N0cmluZ0NvbnRyb2xsZXIpO1xuXHRcblx0dmFyIF9GdW5jdGlvbkNvbnRyb2xsZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblx0XG5cdHZhciBfRnVuY3Rpb25Db250cm9sbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Z1bmN0aW9uQ29udHJvbGxlcik7XG5cdFxuXHR2YXIgX0Jvb2xlYW5Db250cm9sbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblx0XG5cdHZhciBfQm9vbGVhbkNvbnRyb2xsZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQm9vbGVhbkNvbnRyb2xsZXIpO1xuXHRcblx0dmFyIF9jb21tb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHRcblx0dmFyIF9jb21tb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tbW9uKTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cdFxuXHR2YXIgQ29udHJvbGxlckZhY3RvcnkgPSBmdW5jdGlvbiBDb250cm9sbGVyRmFjdG9yeShvYmplY3QsIHByb3BlcnR5KSB7XG5cdCAgdmFyIGluaXRpYWxWYWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG5cdFxuXHQgIC8vIFByb3ZpZGluZyBvcHRpb25zP1xuXHQgIGlmIChfY29tbW9uMi5kZWZhdWx0LmlzQXJyYXkoYXJndW1lbnRzWzJdKSB8fCBfY29tbW9uMi5kZWZhdWx0LmlzT2JqZWN0KGFyZ3VtZW50c1syXSkpIHtcblx0ICAgIHJldHVybiBuZXcgX09wdGlvbkNvbnRyb2xsZXIyLmRlZmF1bHQob2JqZWN0LCBwcm9wZXJ0eSwgYXJndW1lbnRzWzJdKTtcblx0ICB9XG5cdFxuXHQgIC8vIFByb3ZpZGluZyBhIG1hcD9cblx0ICBpZiAoX2NvbW1vbjIuZGVmYXVsdC5pc051bWJlcihpbml0aWFsVmFsdWUpKSB7XG5cdCAgICAvLyBIYXMgbWluIGFuZCBtYXg/IChzbGlkZXIpXG5cdCAgICBpZiAoX2NvbW1vbjIuZGVmYXVsdC5pc051bWJlcihhcmd1bWVudHNbMl0pICYmIF9jb21tb24yLmRlZmF1bHQuaXNOdW1iZXIoYXJndW1lbnRzWzNdKSkge1xuXHQgICAgICAvLyBoYXMgc3RlcD9cblx0ICAgICAgaWYgKF9jb21tb24yLmRlZmF1bHQuaXNOdW1iZXIoYXJndW1lbnRzWzRdKSkge1xuXHQgICAgICAgIHJldHVybiBuZXcgX051bWJlckNvbnRyb2xsZXJTbGlkZXIyLmRlZmF1bHQob2JqZWN0LCBwcm9wZXJ0eSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10sIGFyZ3VtZW50c1s0XSk7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHJldHVybiBuZXcgX051bWJlckNvbnRyb2xsZXJTbGlkZXIyLmRlZmF1bHQob2JqZWN0LCBwcm9wZXJ0eSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10pO1xuXHQgICAgfVxuXHRcblx0ICAgIC8vIG51bWJlciBib3hcblx0ICAgIGlmIChfY29tbW9uMi5kZWZhdWx0LmlzTnVtYmVyKGFyZ3VtZW50c1s0XSkpIHtcblx0ICAgICAgLy8gaGFzIHN0ZXBcblx0ICAgICAgcmV0dXJuIG5ldyBfTnVtYmVyQ29udHJvbGxlckJveDIuZGVmYXVsdChvYmplY3QsIHByb3BlcnR5LCB7IG1pbjogYXJndW1lbnRzWzJdLCBtYXg6IGFyZ3VtZW50c1szXSwgc3RlcDogYXJndW1lbnRzWzRdIH0pO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG5ldyBfTnVtYmVyQ29udHJvbGxlckJveDIuZGVmYXVsdChvYmplY3QsIHByb3BlcnR5LCB7IG1pbjogYXJndW1lbnRzWzJdLCBtYXg6IGFyZ3VtZW50c1szXSB9KTtcblx0ICB9XG5cdFxuXHQgIGlmIChfY29tbW9uMi5kZWZhdWx0LmlzU3RyaW5nKGluaXRpYWxWYWx1ZSkpIHtcblx0ICAgIHJldHVybiBuZXcgX1N0cmluZ0NvbnRyb2xsZXIyLmRlZmF1bHQob2JqZWN0LCBwcm9wZXJ0eSk7XG5cdCAgfVxuXHRcblx0ICBpZiAoX2NvbW1vbjIuZGVmYXVsdC5pc0Z1bmN0aW9uKGluaXRpYWxWYWx1ZSkpIHtcblx0ICAgIHJldHVybiBuZXcgX0Z1bmN0aW9uQ29udHJvbGxlcjIuZGVmYXVsdChvYmplY3QsIHByb3BlcnR5LCAnJyk7XG5cdCAgfVxuXHRcblx0ICBpZiAoX2NvbW1vbjIuZGVmYXVsdC5pc0Jvb2xlYW4oaW5pdGlhbFZhbHVlKSkge1xuXHQgICAgcmV0dXJuIG5ldyBfQm9vbGVhbkNvbnRyb2xsZXIyLmRlZmF1bHQob2JqZWN0LCBwcm9wZXJ0eSk7XG5cdCAgfVxuXHRcblx0ICByZXR1cm4gbnVsbDtcblx0fTsgLyoqXG5cdCAgICAqIGRhdC1ndWkgSmF2YVNjcmlwdCBDb250cm9sbGVyIExpYnJhcnlcblx0ICAgICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2RhdC1ndWlcblx0ICAgICpcblx0ICAgICogQ29weXJpZ2h0IDIwMTEgRGF0YSBBcnRzIFRlYW0sIEdvb2dsZSBDcmVhdGl2ZSBMYWJcblx0ICAgICpcblx0ICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcblx0ICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuXHQgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblx0ICAgICpcblx0ICAgICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cdCAgICAqL1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gQ29udHJvbGxlckZhY3Rvcnk7XG5cbi8qKiovIH0sXG4vKiAyMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHQvKipcblx0ICogZGF0LWd1aSBKYXZhU2NyaXB0IENvbnRyb2xsZXIgTGlicmFyeVxuXHQgKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZGF0LWd1aVxuXHQgKlxuXHQgKiBDb3B5cmlnaHQgMjAxMSBEYXRhIEFydHMgVGVhbSwgR29vZ2xlIENyZWF0aXZlIExhYlxuXHQgKlxuXHQgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuXHQgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5cdCAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXHQgKlxuXHQgKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblx0ICovXG5cdFxuXHRmdW5jdGlvbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spIHtcblx0ICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuXHR9XG5cdFxuXHRleHBvcnRzLmRlZmF1bHQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXG4vKioqLyB9LFxuLyogMjIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cdFxuXHR2YXIgX2RvbSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cdFxuXHR2YXIgX2RvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kb20pO1xuXHRcblx0dmFyIF9jb21tb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHRcblx0dmFyIF9jb21tb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tbW9uKTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfSAvKipcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGRhdC1ndWkgSmF2YVNjcmlwdCBDb250cm9sbGVyIExpYnJhcnlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9kYXQtZ3VpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ29weXJpZ2h0IDIwMTEgRGF0YSBBcnRzIFRlYW0sIEdvb2dsZSBDcmVhdGl2ZSBMYWJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblx0XG5cdHZhciBDZW50ZXJlZERpdiA9IGZ1bmN0aW9uICgpIHtcblx0ICBmdW5jdGlvbiBDZW50ZXJlZERpdigpIHtcblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDZW50ZXJlZERpdik7XG5cdFxuXHQgICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHQgICAgX2NvbW1vbjIuZGVmYXVsdC5leHRlbmQodGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZSwge1xuXHQgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuOCknLFxuXHQgICAgICB0b3A6IDAsXG5cdCAgICAgIGxlZnQ6IDAsXG5cdCAgICAgIGRpc3BsYXk6ICdub25lJyxcblx0ICAgICAgekluZGV4OiAnMTAwMCcsXG5cdCAgICAgIG9wYWNpdHk6IDAsXG5cdCAgICAgIFdlYmtpdFRyYW5zaXRpb246ICdvcGFjaXR5IDAuMnMgbGluZWFyJyxcblx0ICAgICAgdHJhbnNpdGlvbjogJ29wYWNpdHkgMC4ycyBsaW5lYXInXG5cdCAgICB9KTtcblx0XG5cdCAgICBfZG9tMi5kZWZhdWx0Lm1ha2VGdWxsc2NyZWVuKHRoaXMuYmFja2dyb3VuZEVsZW1lbnQpO1xuXHQgICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG5cdFxuXHQgICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdCAgICBfY29tbW9uMi5kZWZhdWx0LmV4dGVuZCh0aGlzLmRvbUVsZW1lbnQuc3R5bGUsIHtcblx0ICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG5cdCAgICAgIGRpc3BsYXk6ICdub25lJyxcblx0ICAgICAgekluZGV4OiAnMTAwMScsXG5cdCAgICAgIG9wYWNpdHk6IDAsXG5cdCAgICAgIFdlYmtpdFRyYW5zaXRpb246ICctd2Via2l0LXRyYW5zZm9ybSAwLjJzIGVhc2Utb3V0LCBvcGFjaXR5IDAuMnMgbGluZWFyJyxcblx0ICAgICAgdHJhbnNpdGlvbjogJ3RyYW5zZm9ybSAwLjJzIGVhc2Utb3V0LCBvcGFjaXR5IDAuMnMgbGluZWFyJ1xuXHQgICAgfSk7XG5cdFxuXHQgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmJhY2tncm91bmRFbGVtZW50KTtcblx0ICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5kb21FbGVtZW50KTtcblx0XG5cdCAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgX2RvbTIuZGVmYXVsdC5iaW5kKHRoaXMuYmFja2dyb3VuZEVsZW1lbnQsICdjbGljaycsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgX3RoaXMuaGlkZSgpO1xuXHQgICAgfSk7XG5cdCAgfVxuXHRcblx0ICBDZW50ZXJlZERpdi5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3coKSB7XG5cdCAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHRcblx0ICAgIHRoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cdFxuXHQgICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXHQgICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAwO1xuXHQgICAgLy8gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLnRvcCA9ICc1MiUnO1xuXHQgICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdzY2FsZSgxLjEpJztcblx0XG5cdCAgICB0aGlzLmxheW91dCgpO1xuXHRcblx0ICAgIF9jb21tb24yLmRlZmF1bHQuZGVmZXIoZnVuY3Rpb24gKCkge1xuXHQgICAgICBfdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMTtcblx0ICAgICAgX3RoaXMuZG9tRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMTtcblx0ICAgICAgX3RoaXMuZG9tRWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnc2NhbGUoMSknO1xuXHQgICAgfSk7XG5cdCAgfTtcblx0XG5cdCAgLyoqXG5cdCAgICogSGlkZSBjZW50ZXJlZCBkaXZcblx0ICAgKi9cblx0XG5cdFxuXHQgIENlbnRlcmVkRGl2LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gaGlkZSgpIHtcblx0ICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdFxuXHQgICAgdmFyIGhpZGUgPSBmdW5jdGlvbiBoaWRlKCkge1xuXHQgICAgICBfdGhpcy5kb21FbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdCAgICAgIF90aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdFxuXHQgICAgICBfZG9tMi5kZWZhdWx0LnVuYmluZChfdGhpcy5kb21FbGVtZW50LCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIGhpZGUpO1xuXHQgICAgICBfZG9tMi5kZWZhdWx0LnVuYmluZChfdGhpcy5kb21FbGVtZW50LCAndHJhbnNpdGlvbmVuZCcsIGhpZGUpO1xuXHQgICAgICBfZG9tMi5kZWZhdWx0LnVuYmluZChfdGhpcy5kb21FbGVtZW50LCAnb1RyYW5zaXRpb25FbmQnLCBoaWRlKTtcblx0ICAgIH07XG5cdFxuXHQgICAgX2RvbTIuZGVmYXVsdC5iaW5kKHRoaXMuZG9tRWxlbWVudCwgJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCBoaWRlKTtcblx0ICAgIF9kb20yLmRlZmF1bHQuYmluZCh0aGlzLmRvbUVsZW1lbnQsICd0cmFuc2l0aW9uZW5kJywgaGlkZSk7XG5cdCAgICBfZG9tMi5kZWZhdWx0LmJpbmQodGhpcy5kb21FbGVtZW50LCAnb1RyYW5zaXRpb25FbmQnLCBoaWRlKTtcblx0XG5cdCAgICB0aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAwO1xuXHQgICAgLy8gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLnRvcCA9ICc0OCUnO1xuXHQgICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAwO1xuXHQgICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdzY2FsZSgxLjEpJztcblx0ICB9O1xuXHRcblx0ICBDZW50ZXJlZERpdi5wcm90b3R5cGUubGF5b3V0ID0gZnVuY3Rpb24gbGF5b3V0KCkge1xuXHQgICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLmxlZnQgPSB3aW5kb3cuaW5uZXJXaWR0aCAvIDIgLSBfZG9tMi5kZWZhdWx0LmdldFdpZHRoKHRoaXMuZG9tRWxlbWVudCkgLyAyICsgJ3B4Jztcblx0ICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS50b3AgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyAyIC0gX2RvbTIuZGVmYXVsdC5nZXRIZWlnaHQodGhpcy5kb21FbGVtZW50KSAvIDIgKyAncHgnO1xuXHQgIH07XG5cdFxuXHQgIHJldHVybiBDZW50ZXJlZERpdjtcblx0fSgpO1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gQ2VudGVyZWREaXY7XG5cbi8qKiovIH0sXG4vKiAyMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0ZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCkoKTtcblx0Ly8gaW1wb3J0c1xuXHRcblx0XG5cdC8vIG1vZHVsZVxuXHRleHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuZGcge1xcbiAgLyoqIENsZWFyIGxpc3Qgc3R5bGVzICovXFxuICAvKiBBdXRvLXBsYWNlIGNvbnRhaW5lciAqL1xcbiAgLyogQXV0by1wbGFjZWQgR1VJJ3MgKi9cXG4gIC8qIExpbmUgaXRlbXMgdGhhdCBkb24ndCBjb250YWluIGZvbGRlcnMuICovXFxuICAvKiogRm9sZGVyIG5hbWVzICovXFxuICAvKiogSGlkZXMgY2xvc2VkIGl0ZW1zICovXFxuICAvKiogQ29udHJvbGxlciByb3cgKi9cXG4gIC8qKiBOYW1lLWhhbGYgKGxlZnQpICovXFxuICAvKiogQ29udHJvbGxlci1oYWxmIChyaWdodCkgKi9cXG4gIC8qKiBDb250cm9sbGVyIHBsYWNlbWVudCAqL1xcbiAgLyoqIFNob3J0ZXIgbnVtYmVyIGJveGVzIHdoZW4gc2xpZGVyIGlzIHByZXNlbnQuICovXFxuICAvKiogRW5zdXJlIHRoZSBlbnRpcmUgYm9vbGVhbiBhbmQgZnVuY3Rpb24gcm93IHNob3dzIGEgaGFuZCAqLyB9XFxuICAuZGcgdWwge1xcbiAgICBsaXN0LXN0eWxlOiBub25lO1xcbiAgICBtYXJnaW46IDA7XFxuICAgIHBhZGRpbmc6IDA7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBjbGVhcjogYm90aDsgfVxcbiAgLmRnLmFjIHtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICB0b3A6IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICBoZWlnaHQ6IDA7XFxuICAgIHotaW5kZXg6IDA7IH1cXG4gIC5kZzpub3QoLmFjKSAubWFpbiB7XFxuICAgIC8qKiBFeGNsdWRlIG1haW5zIGluIGFjIHNvIHRoYXQgd2UgZG9uJ3QgaGlkZSBjbG9zZSBidXR0b24gKi9cXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjsgfVxcbiAgLmRnLm1haW4ge1xcbiAgICAtd2Via2l0LXRyYW5zaXRpb246IG9wYWNpdHkgMC4xcyBsaW5lYXI7XFxuICAgIC1vLXRyYW5zaXRpb246IG9wYWNpdHkgMC4xcyBsaW5lYXI7XFxuICAgIC1tb3otdHJhbnNpdGlvbjogb3BhY2l0eSAwLjFzIGxpbmVhcjtcXG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjFzIGxpbmVhcjsgfVxcbiAgICAuZGcubWFpbi50YWxsZXItdGhhbi13aW5kb3cge1xcbiAgICAgIG92ZXJmbG93LXk6IGF1dG87IH1cXG4gICAgICAuZGcubWFpbi50YWxsZXItdGhhbi13aW5kb3cgLmNsb3NlLWJ1dHRvbiB7XFxuICAgICAgICBvcGFjaXR5OiAxO1xcbiAgICAgICAgLyogVE9ETywgdGhlc2UgYXJlIHN0eWxlIG5vdGVzICovXFxuICAgICAgICBtYXJnaW4tdG9wOiAtMXB4O1xcbiAgICAgICAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICMyYzJjMmM7IH1cXG4gICAgLmRnLm1haW4gdWwuY2xvc2VkIC5jbG9zZS1idXR0b24ge1xcbiAgICAgIG9wYWNpdHk6IDEgIWltcG9ydGFudDsgfVxcbiAgICAuZGcubWFpbjpob3ZlciAuY2xvc2UtYnV0dG9uLFxcbiAgICAuZGcubWFpbiAuY2xvc2UtYnV0dG9uLmRyYWcge1xcbiAgICAgIG9wYWNpdHk6IDE7IH1cXG4gICAgLmRnLm1haW4gLmNsb3NlLWJ1dHRvbiB7XFxuICAgICAgLypvcGFjaXR5OiAwOyovXFxuICAgICAgLXdlYmtpdC10cmFuc2l0aW9uOiBvcGFjaXR5IDAuMXMgbGluZWFyO1xcbiAgICAgIC1vLXRyYW5zaXRpb246IG9wYWNpdHkgMC4xcyBsaW5lYXI7XFxuICAgICAgLW1vei10cmFuc2l0aW9uOiBvcGFjaXR5IDAuMXMgbGluZWFyO1xcbiAgICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4xcyBsaW5lYXI7XFxuICAgICAgYm9yZGVyOiAwO1xcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICBsaW5lLWhlaWdodDogMTlweDtcXG4gICAgICBoZWlnaHQ6IDIwcHg7XFxuICAgICAgLyogVE9ETywgdGhlc2UgYXJlIHN0eWxlIG5vdGVzICovXFxuICAgICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDAwOyB9XFxuICAgICAgLmRnLm1haW4gLmNsb3NlLWJ1dHRvbjpob3ZlciB7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMTExOyB9XFxuICAuZGcuYSB7XFxuICAgIGZsb2F0OiByaWdodDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAxNXB4O1xcbiAgICBvdmVyZmxvdy14OiBoaWRkZW47IH1cXG4gICAgLmRnLmEuaGFzLXNhdmUgPiB1bCB7XFxuICAgICAgbWFyZ2luLXRvcDogMjdweDsgfVxcbiAgICAgIC5kZy5hLmhhcy1zYXZlID4gdWwuY2xvc2VkIHtcXG4gICAgICAgIG1hcmdpbi10b3A6IDA7IH1cXG4gICAgLmRnLmEgLnNhdmUtcm93IHtcXG4gICAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgICAgdG9wOiAwO1xcbiAgICAgIHotaW5kZXg6IDEwMDI7IH1cXG4gIC5kZyBsaSB7XFxuICAgIC13ZWJraXQtdHJhbnNpdGlvbjogaGVpZ2h0IDAuMXMgZWFzZS1vdXQ7XFxuICAgIC1vLXRyYW5zaXRpb246IGhlaWdodCAwLjFzIGVhc2Utb3V0O1xcbiAgICAtbW96LXRyYW5zaXRpb246IGhlaWdodCAwLjFzIGVhc2Utb3V0O1xcbiAgICB0cmFuc2l0aW9uOiBoZWlnaHQgMC4xcyBlYXNlLW91dDsgfVxcbiAgLmRnIGxpOm5vdCguZm9sZGVyKSB7XFxuICAgIGN1cnNvcjogYXV0bztcXG4gICAgaGVpZ2h0OiAyN3B4O1xcbiAgICBsaW5lLWhlaWdodDogMjdweDtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgcGFkZGluZzogMCA0cHggMCA1cHg7IH1cXG4gIC5kZyBsaS5mb2xkZXIge1xcbiAgICBwYWRkaW5nOiAwO1xcbiAgICBib3JkZXItbGVmdDogNHB4IHNvbGlkIHRyYW5zcGFyZW50OyB9XFxuICAuZGcgbGkudGl0bGUge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIG1hcmdpbi1sZWZ0OiAtNHB4OyB9XFxuICAuZGcgLmNsb3NlZCBsaTpub3QoLnRpdGxlKSxcXG4gIC5kZyAuY2xvc2VkIHVsIGxpLFxcbiAgLmRnIC5jbG9zZWQgdWwgbGkgPiAqIHtcXG4gICAgaGVpZ2h0OiAwO1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICBib3JkZXI6IDA7IH1cXG4gIC5kZyAuY3Ige1xcbiAgICBjbGVhcjogYm90aDtcXG4gICAgcGFkZGluZy1sZWZ0OiAzcHg7XFxuICAgIGhlaWdodDogMjdweDsgfVxcbiAgLmRnIC5wcm9wZXJ0eS1uYW1lIHtcXG4gICAgY3Vyc29yOiBkZWZhdWx0O1xcbiAgICBmbG9hdDogbGVmdDtcXG4gICAgY2xlYXI6IGxlZnQ7XFxuICAgIHdpZHRoOiA0MCU7XFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzOyB9XFxuICAuZGcgLmMge1xcbiAgICBmbG9hdDogbGVmdDtcXG4gICAgd2lkdGg6IDYwJTsgfVxcbiAgLmRnIC5jIGlucHV0W3R5cGU9dGV4dF0ge1xcbiAgICBib3JkZXI6IDA7XFxuICAgIG1hcmdpbi10b3A6IDRweDtcXG4gICAgcGFkZGluZzogM3B4O1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgZmxvYXQ6IHJpZ2h0OyB9XFxuICAuZGcgLmhhcy1zbGlkZXIgaW5wdXRbdHlwZT10ZXh0XSB7XFxuICAgIHdpZHRoOiAzMCU7XFxuICAgIC8qZGlzcGxheTogbm9uZTsqL1xcbiAgICBtYXJnaW4tbGVmdDogMDsgfVxcbiAgLmRnIC5zbGlkZXIge1xcbiAgICBmbG9hdDogbGVmdDtcXG4gICAgd2lkdGg6IDY2JTtcXG4gICAgbWFyZ2luLWxlZnQ6IC01cHg7XFxuICAgIG1hcmdpbi1yaWdodDogMDtcXG4gICAgaGVpZ2h0OiAxOXB4O1xcbiAgICBtYXJnaW4tdG9wOiA0cHg7IH1cXG4gIC5kZyAuc2xpZGVyLWZnIHtcXG4gICAgaGVpZ2h0OiAxMDAlOyB9XFxuICAuZGcgLmMgaW5wdXRbdHlwZT1jaGVja2JveF0ge1xcbiAgICBtYXJnaW4tdG9wOiA5cHg7IH1cXG4gIC5kZyAuYyBzZWxlY3Qge1xcbiAgICBtYXJnaW4tdG9wOiA1cHg7IH1cXG4gIC5kZyAuY3IuZnVuY3Rpb24sXFxuICAuZGcgLmNyLmZ1bmN0aW9uIC5wcm9wZXJ0eS1uYW1lLFxcbiAgLmRnIC5jci5mdW5jdGlvbiAqLFxcbiAgLmRnIC5jci5ib29sZWFuLFxcbiAgLmRnIC5jci5ib29sZWFuICoge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7IH1cXG4gIC5kZyAuc2VsZWN0b3Ige1xcbiAgICBkaXNwbGF5OiBub25lO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIG1hcmdpbi1sZWZ0OiAtOXB4O1xcbiAgICBtYXJnaW4tdG9wOiAyM3B4O1xcbiAgICB6LWluZGV4OiAxMDsgfVxcbiAgLmRnIC5jOmhvdmVyIC5zZWxlY3RvcixcXG4gIC5kZyAuc2VsZWN0b3IuZHJhZyB7XFxuICAgIGRpc3BsYXk6IGJsb2NrOyB9XFxuICAuZGcgbGkuc2F2ZS1yb3cge1xcbiAgICBwYWRkaW5nOiAwOyB9XFxuICAgIC5kZyBsaS5zYXZlLXJvdyAuYnV0dG9uIHtcXG4gICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgICAgcGFkZGluZzogMHB4IDZweDsgfVxcbiAgLmRnLmRpYWxvZ3VlIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzIyMjtcXG4gICAgd2lkdGg6IDQ2MHB4O1xcbiAgICBwYWRkaW5nOiAxNXB4O1xcbiAgICBmb250LXNpemU6IDEzcHg7XFxuICAgIGxpbmUtaGVpZ2h0OiAxNXB4OyB9XFxuXFxuLyogVE9ETyBTZXBhcmF0ZSBzdHlsZSBhbmQgc3RydWN0dXJlICovXFxuI2RnLW5ldy1jb25zdHJ1Y3RvciB7XFxuICBwYWRkaW5nOiAxMHB4O1xcbiAgY29sb3I6ICMyMjI7XFxuICBmb250LWZhbWlseTogTW9uYWNvLCBtb25vc3BhY2U7XFxuICBmb250LXNpemU6IDEwcHg7XFxuICBib3JkZXI6IDA7XFxuICByZXNpemU6IG5vbmU7XFxuICBib3gtc2hhZG93OiBpbnNldCAxcHggMXB4IDFweCAjODg4O1xcbiAgd29yZC13cmFwOiBicmVhay13b3JkO1xcbiAgbWFyZ2luOiAxMnB4IDA7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHdpZHRoOiA0NDBweDtcXG4gIG92ZXJmbG93LXk6IHNjcm9sbDtcXG4gIGhlaWdodDogMTAwcHg7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7IH1cXG5cXG4jZGctbG9jYWwtZXhwbGFpbiB7XFxuICBkaXNwbGF5OiBub25lO1xcbiAgZm9udC1zaXplOiAxMXB4O1xcbiAgbGluZS1oZWlnaHQ6IDE3cHg7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMzMzO1xcbiAgcGFkZGluZzogOHB4O1xcbiAgbWFyZ2luLXRvcDogMTBweDsgfVxcbiAgI2RnLWxvY2FsLWV4cGxhaW4gY29kZSB7XFxuICAgIGZvbnQtc2l6ZTogMTBweDsgfVxcblxcbiNkYXQtZ3VpLXNhdmUtbG9jYWxseSB7XFxuICBkaXNwbGF5OiBub25lOyB9XFxuXFxuLyoqIE1haW4gdHlwZSAqL1xcbi5kZyB7XFxuICBjb2xvcjogI2VlZTtcXG4gIGZvbnQ6IDExcHggJ0x1Y2lkYSBHcmFuZGUnLCBzYW5zLXNlcmlmO1xcbiAgdGV4dC1zaGFkb3c6IDAgLTFweCAwICMxMTE7XFxuICAvKiogQXV0byBwbGFjZSAqL1xcbiAgLyogQ29udHJvbGxlciByb3csIDxsaT4gKi9cXG4gIC8qKiBDb250cm9sbGVycyAqLyB9XFxuICAuZGcubWFpbiB7XFxuICAgIC8qKiBTY3JvbGxiYXIgKi8gfVxcbiAgICAuZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXIge1xcbiAgICAgIHdpZHRoOiA1cHg7XFxuICAgICAgYmFja2dyb3VuZDogIzFhMWExYTsgfVxcbiAgICAuZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXItY29ybmVyIHtcXG4gICAgICBoZWlnaHQ6IDA7XFxuICAgICAgZGlzcGxheTogbm9uZTsgfVxcbiAgICAuZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWIge1xcbiAgICAgIGJvcmRlci1yYWRpdXM6IDVweDtcXG4gICAgICBiYWNrZ3JvdW5kOiAjNjc2NzY3OyB9XFxuICAuZGcgbGk6bm90KC5mb2xkZXIpIHtcXG4gICAgYmFja2dyb3VuZDogIzFhMWExYTtcXG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICMyYzJjMmM7IH1cXG4gIC5kZyBsaS5zYXZlLXJvdyB7XFxuICAgIGxpbmUtaGVpZ2h0OiAyNXB4O1xcbiAgICBiYWNrZ3JvdW5kOiAjZGFkNWNiO1xcbiAgICBib3JkZXI6IDA7IH1cXG4gICAgLmRnIGxpLnNhdmUtcm93IHNlbGVjdCB7XFxuICAgICAgbWFyZ2luLWxlZnQ6IDVweDtcXG4gICAgICB3aWR0aDogMTA4cHg7IH1cXG4gICAgLmRnIGxpLnNhdmUtcm93IC5idXR0b24ge1xcbiAgICAgIG1hcmdpbi1sZWZ0OiA1cHg7XFxuICAgICAgbWFyZ2luLXRvcDogMXB4O1xcbiAgICAgIGJvcmRlci1yYWRpdXM6IDJweDtcXG4gICAgICBmb250LXNpemU6IDlweDtcXG4gICAgICBsaW5lLWhlaWdodDogN3B4O1xcbiAgICAgIHBhZGRpbmc6IDRweCA0cHggNXB4IDRweDtcXG4gICAgICBiYWNrZ3JvdW5kOiAjYzViZGFkO1xcbiAgICAgIGNvbG9yOiAjZmZmO1xcbiAgICAgIHRleHQtc2hhZG93OiAwIDFweCAwICNiMGE1OGY7XFxuICAgICAgYm94LXNoYWRvdzogMCAtMXB4IDAgI2IwYTU4ZjtcXG4gICAgICBjdXJzb3I6IHBvaW50ZXI7IH1cXG4gICAgICAuZGcgbGkuc2F2ZS1yb3cgLmJ1dHRvbi5nZWFycyB7XFxuICAgICAgICBiYWNrZ3JvdW5kOiAjYzViZGFkIHVybChkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFzQUFBQU5DQVlBQUFCLzlaUTdBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQVFKSlJFRlVlTnBpWUtBVS9QLy9Qd0dJQy9BcENBQmlCU0FXK0k4QUNsQWNnS3hRNFQ5aG9NQUVVcnh4MlFTR042K2VnRFgrL3ZXVDRlN044MkFNWW9QQXgvZXZ3V29Zb1NZYkFDWDJzN0t4Q3h6Y3NlekRoM2V2Rm9ERUJZVEVFcXljZ2dXQXpBOUF1VVNRUWdlWVBhOWZQdjYvWVdtL0FjeDVJUGI3dHkvZncrUVpibHc2N3ZEczhSMFlIeVFoZ09ieCt5QUprQnFtRzVkUFBEaDFhUE9HUi9ldWdXMEc0dmxJb1RJZnlGY0ErUWVraGhISmhQZFF4YmlBSWd1TUJUUVpyUEQ3MTA4TTZyb1dZREZRaUlBQXY2QW93LzFiRndYZ2lzK2YyTFVBeW53b0lhTmN6OFhOeDNEbDdNRUpVREdRcHg5Z3RROFlDdWVCK0QyNk9FQ0FBUURhZHQ3ZTQ2RDQyUUFBQUFCSlJVNUVya0pnZ2c9PSkgMnB4IDFweCBuby1yZXBlYXQ7XFxuICAgICAgICBoZWlnaHQ6IDdweDtcXG4gICAgICAgIHdpZHRoOiA4cHg7IH1cXG4gICAgICAuZGcgbGkuc2F2ZS1yb3cgLmJ1dHRvbjpob3ZlciB7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjYmFiMTllO1xcbiAgICAgICAgYm94LXNoYWRvdzogMCAtMXB4IDAgI2IwYTU4ZjsgfVxcbiAgLmRnIGxpLmZvbGRlciB7XFxuICAgIGJvcmRlci1ib3R0b206IDA7IH1cXG4gIC5kZyBsaS50aXRsZSB7XFxuICAgIHBhZGRpbmctbGVmdDogMTZweDtcXG4gICAgYmFja2dyb3VuZDogIzAwMCB1cmwoZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQlFBRkFKRUFBUC8vLy9QejgvLy8vLy8vL3lINUJBRUFBQUlBTEFBQUFBQUZBQVVBQUFJSWxJK2hLZ0Z4b0NnQU93PT0pIDZweCAxMHB4IG5vLXJlcGVhdDtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpOyB9XFxuICAuZGcgLmNsb3NlZCBsaS50aXRsZSB7XFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybChkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhCUUFGQUpFQUFQLy8vL1B6OC8vLy8vLy8veUg1QkFFQUFBSUFMQUFBQUFBRkFBVUFBQUlJbEdJV3FNQ2JXQUVBT3c9PSk7IH1cXG4gIC5kZyAuY3IuYm9vbGVhbiB7XFxuICAgIGJvcmRlci1sZWZ0OiAzcHggc29saWQgIzgwNjc4NzsgfVxcbiAgLmRnIC5jci5jb2xvciB7XFxuICAgIGJvcmRlci1sZWZ0OiAzcHggc29saWQ7IH1cXG4gIC5kZyAuY3IuZnVuY3Rpb24ge1xcbiAgICBib3JkZXItbGVmdDogM3B4IHNvbGlkICNlNjFkNWY7IH1cXG4gIC5kZyAuY3IubnVtYmVyIHtcXG4gICAgYm9yZGVyLWxlZnQ6IDNweCBzb2xpZCAjMkZBMUQ2OyB9XFxuICAgIC5kZyAuY3IubnVtYmVyIGlucHV0W3R5cGU9dGV4dF0ge1xcbiAgICAgIGNvbG9yOiAjMkZBMUQ2OyB9XFxuICAuZGcgLmNyLnN0cmluZyB7XFxuICAgIGJvcmRlci1sZWZ0OiAzcHggc29saWQgIzFlZDM2ZjsgfVxcbiAgICAuZGcgLmNyLnN0cmluZyBpbnB1dFt0eXBlPXRleHRdIHtcXG4gICAgICBjb2xvcjogIzFlZDM2ZjsgfVxcbiAgLmRnIC5jci5mdW5jdGlvbjpob3ZlciwgLmRnIC5jci5ib29sZWFuOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZDogIzExMTsgfVxcbiAgLmRnIC5jIGlucHV0W3R5cGU9dGV4dF0ge1xcbiAgICBiYWNrZ3JvdW5kOiAjMzAzMDMwO1xcbiAgICBvdXRsaW5lOiBub25lOyB9XFxuICAgIC5kZyAuYyBpbnB1dFt0eXBlPXRleHRdOmhvdmVyIHtcXG4gICAgICBiYWNrZ3JvdW5kOiAjM2MzYzNjOyB9XFxuICAgIC5kZyAuYyBpbnB1dFt0eXBlPXRleHRdOmZvY3VzIHtcXG4gICAgICBiYWNrZ3JvdW5kOiAjNDk0OTQ5O1xcbiAgICAgIGNvbG9yOiAjZmZmOyB9XFxuICAuZGcgLmMgLnNsaWRlciB7XFxuICAgIGJhY2tncm91bmQ6ICMzMDMwMzA7XFxuICAgIGN1cnNvcjogZXctcmVzaXplOyB9XFxuICAuZGcgLmMgLnNsaWRlci1mZyB7XFxuICAgIGJhY2tncm91bmQ6ICMyRkExRDY7XFxuICAgIG1heC13aWR0aDogMTAwJTsgfVxcbiAgLmRnIC5jIC5zbGlkZXI6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kOiAjM2MzYzNjOyB9XFxuICAgIC5kZyAuYyAuc2xpZGVyOmhvdmVyIC5zbGlkZXItZmcge1xcbiAgICAgIGJhY2tncm91bmQ6ICM0NGFiZGE7IH1cXG5cIiwgXCJcIl0pO1xuXHRcblx0Ly8gZXhwb3J0c1xuXG5cbi8qKiovIH0sXG4vKiAyNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0Lypcblx0XHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRcdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcblx0Ki9cblx0Ly8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGlzdCA9IFtdO1xuXHRcblx0XHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cdFx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIGl0ZW0gPSB0aGlzW2ldO1xuXHRcdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdFx0cmVzdWx0LnB1c2goXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBpdGVtWzFdICsgXCJ9XCIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKGl0ZW1bMV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0LmpvaW4oXCJcIik7XG5cdFx0fTtcblx0XG5cdFx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0XHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcblx0XHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcblx0XHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuXHRcdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcblx0XHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIGxpc3Q7XG5cdH07XG5cblxuLyoqKi8gfVxuLyoqKioqKi8gXSlcbn0pO1xuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0Lmd1aS5qcy5tYXAiLCIvL2Rvd25sb2FkLmpzIHY0LjIsIGJ5IGRhbmRhdmlzOyAyMDA4LTIwMTYuIFtDQ0JZMl0gc2VlIGh0dHA6Ly9kYW5tbC5jb20vZG93bmxvYWQuaHRtbCBmb3IgdGVzdHMvdXNhZ2VcclxuLy8gdjEgbGFuZGVkIGEgRkYrQ2hyb21lIGNvbXBhdCB3YXkgb2YgZG93bmxvYWRpbmcgc3RyaW5ncyB0byBsb2NhbCB1bi1uYW1lZCBmaWxlcywgdXBncmFkZWQgdG8gdXNlIGEgaGlkZGVuIGZyYW1lIGFuZCBvcHRpb25hbCBtaW1lXHJcbi8vIHYyIGFkZGVkIG5hbWVkIGZpbGVzIHZpYSBhW2Rvd25sb2FkXSwgbXNTYXZlQmxvYiwgSUUgKDEwKykgc3VwcG9ydCwgYW5kIHdpbmRvdy5VUkwgc3VwcG9ydCBmb3IgbGFyZ2VyK2Zhc3RlciBzYXZlcyB0aGFuIGRhdGFVUkxzXHJcbi8vIHYzIGFkZGVkIGRhdGFVUkwgYW5kIEJsb2IgSW5wdXQsIGJpbmQtdG9nZ2xlIGFyaXR5LCBhbmQgbGVnYWN5IGRhdGFVUkwgZmFsbGJhY2sgd2FzIGltcHJvdmVkIHdpdGggZm9yY2UtZG93bmxvYWQgbWltZSBhbmQgYmFzZTY0IHN1cHBvcnQuIDMuMSBpbXByb3ZlZCBzYWZhcmkgaGFuZGxpbmcuXHJcbi8vIHY0IGFkZHMgQU1EL1VNRCwgY29tbW9uSlMsIGFuZCBwbGFpbiBicm93c2VyIHN1cHBvcnRcclxuLy8gdjQuMSBhZGRzIHVybCBkb3dubG9hZCBjYXBhYmlsaXR5IHZpYSBzb2xvIFVSTCBhcmd1bWVudCAoc2FtZSBkb21haW4vQ09SUyBvbmx5KVxyXG4vLyB2NC4yIGFkZHMgc2VtYW50aWMgdmFyaWFibGUgbmFtZXMsIGxvbmcgKG92ZXIgMk1CKSBkYXRhVVJMIHN1cHBvcnQsIGFuZCBoaWRkZW4gYnkgZGVmYXVsdCB0ZW1wIGFuY2hvcnNcclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3JuZG1lL2Rvd25sb2FkXHJcblxyXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcclxuXHRpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcblx0XHQvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXHJcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xyXG5cdH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XHJcblx0XHQvLyBOb2RlLiBEb2VzIG5vdCB3b3JrIHdpdGggc3RyaWN0IENvbW1vbkpTLCBidXRcclxuXHRcdC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxyXG5cdFx0Ly8gbGlrZSBOb2RlLlxyXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXHJcblx0XHRyb290LmRvd25sb2FkID0gZmFjdG9yeSgpO1xyXG4gIH1cclxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiBkb3dubG9hZChkYXRhLCBzdHJGaWxlTmFtZSwgc3RyTWltZVR5cGUpIHtcclxuXHJcblx0XHR2YXIgc2VsZiA9IHdpbmRvdywgLy8gdGhpcyBzY3JpcHQgaXMgb25seSBmb3IgYnJvd3NlcnMgYW55d2F5Li4uXHJcblx0XHRcdGRlZmF1bHRNaW1lID0gXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIiwgLy8gdGhpcyBkZWZhdWx0IG1pbWUgYWxzbyB0cmlnZ2VycyBpZnJhbWUgZG93bmxvYWRzXHJcblx0XHRcdG1pbWVUeXBlID0gc3RyTWltZVR5cGUgfHwgZGVmYXVsdE1pbWUsXHJcblx0XHRcdHBheWxvYWQgPSBkYXRhLFxyXG5cdFx0XHR1cmwgPSAhc3RyRmlsZU5hbWUgJiYgIXN0ck1pbWVUeXBlICYmIHBheWxvYWQsXHJcblx0XHRcdGFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpLFxyXG5cdFx0XHR0b1N0cmluZyA9IGZ1bmN0aW9uKGEpe3JldHVybiBTdHJpbmcoYSk7fSxcclxuXHRcdFx0bXlCbG9iID0gKHNlbGYuQmxvYiB8fCBzZWxmLk1vekJsb2IgfHwgc2VsZi5XZWJLaXRCbG9iIHx8IHRvU3RyaW5nKSxcclxuXHRcdFx0ZmlsZU5hbWUgPSBzdHJGaWxlTmFtZSB8fCBcImRvd25sb2FkXCIsXHJcblx0XHRcdGJsb2IsXHJcblx0XHRcdHJlYWRlcjtcclxuXHRcdFx0bXlCbG9iPSBteUJsb2IuY2FsbCA/IG15QmxvYi5iaW5kKHNlbGYpIDogQmxvYiA7XHJcblx0ICBcclxuXHRcdGlmKFN0cmluZyh0aGlzKT09PVwidHJ1ZVwiKXsgLy9yZXZlcnNlIGFyZ3VtZW50cywgYWxsb3dpbmcgZG93bmxvYWQuYmluZCh0cnVlLCBcInRleHQveG1sXCIsIFwiZXhwb3J0LnhtbFwiKSB0byBhY3QgYXMgYSBjYWxsYmFja1xyXG5cdFx0XHRwYXlsb2FkPVtwYXlsb2FkLCBtaW1lVHlwZV07XHJcblx0XHRcdG1pbWVUeXBlPXBheWxvYWRbMF07XHJcblx0XHRcdHBheWxvYWQ9cGF5bG9hZFsxXTtcclxuXHRcdH1cclxuXHJcblxyXG5cdFx0aWYodXJsICYmIHVybC5sZW5ndGg8IDIwNDgpeyAvLyBpZiBubyBmaWxlbmFtZSBhbmQgbm8gbWltZSwgYXNzdW1lIGEgdXJsIHdhcyBwYXNzZWQgYXMgdGhlIG9ubHkgYXJndW1lbnRcclxuXHRcdFx0ZmlsZU5hbWUgPSB1cmwuc3BsaXQoXCIvXCIpLnBvcCgpLnNwbGl0KFwiP1wiKVswXTtcclxuXHRcdFx0YW5jaG9yLmhyZWYgPSB1cmw7IC8vIGFzc2lnbiBocmVmIHByb3AgdG8gdGVtcCBhbmNob3JcclxuXHRcdCAgXHRpZihhbmNob3IuaHJlZi5pbmRleE9mKHVybCkgIT09IC0xKXsgLy8gaWYgdGhlIGJyb3dzZXIgZGV0ZXJtaW5lcyB0aGF0IGl0J3MgYSBwb3RlbnRpYWxseSB2YWxpZCB1cmwgcGF0aDpcclxuICAgICAgICBcdFx0dmFyIGFqYXg9bmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgXHRcdGFqYXgub3BlbiggXCJHRVRcIiwgdXJsLCB0cnVlKTtcclxuICAgICAgICBcdFx0YWpheC5yZXNwb25zZVR5cGUgPSAnYmxvYic7XHJcbiAgICAgICAgXHRcdGFqYXgub25sb2FkPSBmdW5jdGlvbihlKXsgXHJcblx0XHRcdFx0ICBkb3dubG9hZChlLnRhcmdldC5yZXNwb25zZSwgZmlsZU5hbWUsIGRlZmF1bHRNaW1lKTtcclxuXHRcdFx0XHR9O1xyXG4gICAgICAgIFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7IGFqYXguc2VuZCgpO30sIDApOyAvLyBhbGxvd3Mgc2V0dGluZyBjdXN0b20gYWpheCBoZWFkZXJzIHVzaW5nIHRoZSByZXR1cm46XHJcblx0XHRcdCAgICByZXR1cm4gYWpheDtcclxuXHRcdFx0fSAvLyBlbmQgaWYgdmFsaWQgdXJsP1xyXG5cdFx0fSAvLyBlbmQgaWYgdXJsP1xyXG5cclxuXHJcblx0XHQvL2dvIGFoZWFkIGFuZCBkb3dubG9hZCBkYXRhVVJMcyByaWdodCBhd2F5XHJcblx0XHRpZigvXmRhdGFcXDpbXFx3K1xcLV0rXFwvW1xcdytcXC1dK1ssO10vLnRlc3QocGF5bG9hZCkpe1xyXG5cdFx0XHJcblx0XHRcdGlmKHBheWxvYWQubGVuZ3RoID4gKDEwMjQqMTAyNCoxLjk5OSkgJiYgbXlCbG9iICE9PSB0b1N0cmluZyApe1xyXG5cdFx0XHRcdHBheWxvYWQ9ZGF0YVVybFRvQmxvYihwYXlsb2FkKTtcclxuXHRcdFx0XHRtaW1lVHlwZT1wYXlsb2FkLnR5cGUgfHwgZGVmYXVsdE1pbWU7XHJcblx0XHRcdH1lbHNle1x0XHRcdFxyXG5cdFx0XHRcdHJldHVybiBuYXZpZ2F0b3IubXNTYXZlQmxvYiA/ICAvLyBJRTEwIGNhbid0IGRvIGFbZG93bmxvYWRdLCBvbmx5IEJsb2JzOlxyXG5cdFx0XHRcdFx0bmF2aWdhdG9yLm1zU2F2ZUJsb2IoZGF0YVVybFRvQmxvYihwYXlsb2FkKSwgZmlsZU5hbWUpIDpcclxuXHRcdFx0XHRcdHNhdmVyKHBheWxvYWQpIDsgLy8gZXZlcnlvbmUgZWxzZSBjYW4gc2F2ZSBkYXRhVVJMcyB1bi1wcm9jZXNzZWRcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdH0vL2VuZCBpZiBkYXRhVVJMIHBhc3NlZD9cclxuXHJcblx0XHRibG9iID0gcGF5bG9hZCBpbnN0YW5jZW9mIG15QmxvYiA/XHJcblx0XHRcdHBheWxvYWQgOlxyXG5cdFx0XHRuZXcgbXlCbG9iKFtwYXlsb2FkXSwge3R5cGU6IG1pbWVUeXBlfSkgO1xyXG5cclxuXHJcblx0XHRmdW5jdGlvbiBkYXRhVXJsVG9CbG9iKHN0clVybCkge1xyXG5cdFx0XHR2YXIgcGFydHM9IHN0clVybC5zcGxpdCgvWzo7LF0vKSxcclxuXHRcdFx0dHlwZT0gcGFydHNbMV0sXHJcblx0XHRcdGRlY29kZXI9IHBhcnRzWzJdID09IFwiYmFzZTY0XCIgPyBhdG9iIDogZGVjb2RlVVJJQ29tcG9uZW50LFxyXG5cdFx0XHRiaW5EYXRhPSBkZWNvZGVyKCBwYXJ0cy5wb3AoKSApLFxyXG5cdFx0XHRteD0gYmluRGF0YS5sZW5ndGgsXHJcblx0XHRcdGk9IDAsXHJcblx0XHRcdHVpQXJyPSBuZXcgVWludDhBcnJheShteCk7XHJcblxyXG5cdFx0XHRmb3IoaTtpPG14OysraSkgdWlBcnJbaV09IGJpbkRhdGEuY2hhckNvZGVBdChpKTtcclxuXHJcblx0XHRcdHJldHVybiBuZXcgbXlCbG9iKFt1aUFycl0sIHt0eXBlOiB0eXBlfSk7XHJcblx0XHQgfVxyXG5cclxuXHRcdGZ1bmN0aW9uIHNhdmVyKHVybCwgd2luTW9kZSl7XHJcblxyXG5cdFx0XHRpZiAoJ2Rvd25sb2FkJyBpbiBhbmNob3IpIHsgLy9odG1sNSBBW2Rvd25sb2FkXVxyXG5cdFx0XHRcdGFuY2hvci5ocmVmID0gdXJsO1xyXG5cdFx0XHRcdGFuY2hvci5zZXRBdHRyaWJ1dGUoXCJkb3dubG9hZFwiLCBmaWxlTmFtZSk7XHJcblx0XHRcdFx0YW5jaG9yLmNsYXNzTmFtZSA9IFwiZG93bmxvYWQtanMtbGlua1wiO1xyXG5cdFx0XHRcdGFuY2hvci5pbm5lckhUTUwgPSBcImRvd25sb2FkaW5nLi4uXCI7XHJcblx0XHRcdFx0YW5jaG9yLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuXHRcdFx0XHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGFuY2hvcik7XHJcblx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdGFuY2hvci5jbGljaygpO1xyXG5cdFx0XHRcdFx0ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChhbmNob3IpO1xyXG5cdFx0XHRcdFx0aWYod2luTW9kZT09PXRydWUpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXsgc2VsZi5VUkwucmV2b2tlT2JqZWN0VVJMKGFuY2hvci5ocmVmKTt9LCAyNTAgKTt9XHJcblx0XHRcdFx0fSwgNjYpO1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBoYW5kbGUgbm9uLWFbZG93bmxvYWRdIHNhZmFyaSBhcyBiZXN0IHdlIGNhbjpcclxuXHRcdFx0aWYoLyhWZXJzaW9uKVxcLyhcXGQrKVxcLihcXGQrKSg/OlxcLihcXGQrKSk/LipTYWZhcmlcXC8vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcclxuXHRcdFx0XHR1cmw9dXJsLnJlcGxhY2UoL15kYXRhOihbXFx3XFwvXFwtXFwrXSspLywgZGVmYXVsdE1pbWUpO1xyXG5cdFx0XHRcdGlmKCF3aW5kb3cub3Blbih1cmwpKXsgLy8gcG9wdXAgYmxvY2tlZCwgb2ZmZXIgZGlyZWN0IGRvd25sb2FkOlxyXG5cdFx0XHRcdFx0aWYoY29uZmlybShcIkRpc3BsYXlpbmcgTmV3IERvY3VtZW50XFxuXFxuVXNlIFNhdmUgQXMuLi4gdG8gZG93bmxvYWQsIHRoZW4gY2xpY2sgYmFjayB0byByZXR1cm4gdG8gdGhpcyBwYWdlLlwiKSl7IGxvY2F0aW9uLmhyZWY9dXJsOyB9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvL2RvIGlmcmFtZSBkYXRhVVJMIGRvd25sb2FkIChvbGQgY2grRkYpOlxyXG5cdFx0XHR2YXIgZiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XHJcblx0XHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZik7XHJcblxyXG5cdFx0XHRpZighd2luTW9kZSl7IC8vIGZvcmNlIGEgbWltZSB0aGF0IHdpbGwgZG93bmxvYWQ6XHJcblx0XHRcdFx0dXJsPVwiZGF0YTpcIit1cmwucmVwbGFjZSgvXmRhdGE6KFtcXHdcXC9cXC1cXCtdKykvLCBkZWZhdWx0TWltZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Zi5zcmM9dXJsO1xyXG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7IGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZik7IH0sIDMzMyk7XHJcblxyXG5cdFx0fS8vZW5kIHNhdmVyXHJcblxyXG5cclxuXHJcblxyXG5cdFx0aWYgKG5hdmlnYXRvci5tc1NhdmVCbG9iKSB7IC8vIElFMTArIDogKGhhcyBCbG9iLCBidXQgbm90IGFbZG93bmxvYWRdIG9yIFVSTClcclxuXHRcdFx0cmV0dXJuIG5hdmlnYXRvci5tc1NhdmVCbG9iKGJsb2IsIGZpbGVOYW1lKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZihzZWxmLlVSTCl7IC8vIHNpbXBsZSBmYXN0IGFuZCBtb2Rlcm4gd2F5IHVzaW5nIEJsb2IgYW5kIFVSTDpcclxuXHRcdFx0c2F2ZXIoc2VsZi5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpLCB0cnVlKTtcclxuXHRcdH1lbHNle1xyXG5cdFx0XHQvLyBoYW5kbGUgbm9uLUJsb2IoKStub24tVVJMIGJyb3dzZXJzOlxyXG5cdFx0XHRpZih0eXBlb2YgYmxvYiA9PT0gXCJzdHJpbmdcIiB8fCBibG9iLmNvbnN0cnVjdG9yPT09dG9TdHJpbmcgKXtcclxuXHRcdFx0XHR0cnl7XHJcblx0XHRcdFx0XHRyZXR1cm4gc2F2ZXIoIFwiZGF0YTpcIiArICBtaW1lVHlwZSAgICsgXCI7YmFzZTY0LFwiICArICBzZWxmLmJ0b2EoYmxvYikgICk7XHJcblx0XHRcdFx0fWNhdGNoKHkpe1xyXG5cdFx0XHRcdFx0cmV0dXJuIHNhdmVyKCBcImRhdGE6XCIgKyAgbWltZVR5cGUgICArIFwiLFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KGJsb2IpICApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gQmxvYiBidXQgbm90IFVSTCBzdXBwb3J0OlxyXG5cdFx0XHRyZWFkZXI9bmV3IEZpbGVSZWFkZXIoKTtcclxuXHRcdFx0cmVhZGVyLm9ubG9hZD1mdW5jdGlvbihlKXtcclxuXHRcdFx0XHRzYXZlcih0aGlzLnJlc3VsdCk7XHJcblx0XHRcdH07XHJcblx0XHRcdHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fTsgLyogZW5kIGRvd25sb2FkKCkgKi9cclxufSkpOyIsImltcG9ydCBQYWludENvbnRyb2wgZnJvbSAnLi9Db250cm9scy9QYWludENvbnRyb2wnO1xuaW1wb3J0IFNWRyBmcm9tICdzdmcuanMnO1xuaW1wb3J0ICogYXMgVUkgZnJvbSAnLi9tb2RlbC9VSU1hbmFnZW1lbnQnO1xuXG4oZnVuY3Rpb24oKXtcblx0bGV0IGRyYXcgPSBTVkcoJ2RyYXdpbmcnKS5zaXplKDEwMDAsIDEwMDApO1xuXHRVSS5zZXRHVUkoKTtcblx0c2V0Q29udHJvbChkcmF3KTtcblxufSkoKTtcblxuZnVuY3Rpb24gc2V0Q29udHJvbChfY29udGFpbmVyKSB7XG5cdGxldCBpc01vdXNlRG93biA9IGZhbHNlO1xuXHRsZXQgY3Vycm5ldENvbnRyb2wgPSBuZXcgUGFpbnRDb250cm9sKF9jb250YWluZXIpO1xuXHRjb25zdCB0b3AgPSBfY29udGFpbmVyLm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuXHRjb25zdCBsZWZ0ID0gX2NvbnRhaW5lci5ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG5cblx0X2NvbnRhaW5lci5vbignbW91c2Vkb3duJywgZnVuY3Rpb24gKGUpIHtcblx0XHRjb25zdCBwb2ludCA9IFtcblx0XHRcdGUuY2xpZW50WCAtIHRvcCxcblx0XHRcdGUuY2xpZW50WSAtIGxlZnRcblx0XHRdO1xuXHRcdGlzTW91c2VEb3duID0gdHJ1ZTtcblx0XHRjdXJybmV0Q29udHJvbC5zdGFydChwb2ludCk7XG5cblx0fSk7XG5cdF9jb250YWluZXIub24oJ21vdXNldXAnLCBmdW5jdGlvbiAoKSB7XG5cdFx0aXNNb3VzZURvd24gPSBmYWxzZTtcblx0XHRjdXJybmV0Q29udHJvbC5lbmQoKTtcblx0fSk7XG5cdF9jb250YWluZXIub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIHggPSBlLm9mZnNldFg7XG5cdFx0dmFyIHkgPSBlLm9mZnNldFk7XG5cdFx0aWYgKGlzTW91c2VEb3duKSB7XG5cdFx0XHRjdXJybmV0Q29udHJvbC51cGRhdGUoW3gsIHldKTtcblx0XHR9XG5cdH0pO1xufVxuXG4iLCJleHBvcnQgZGVmYXVsdCB7XG5cdHNlbGVjdGVkQ3VydmUgOltdXG59OyIsImltcG9ydCBCZXppZXIgZnJvbSAnYmV6aWVyLWpzJztcbmltcG9ydCBNYWduZXRpY0N1cnZlIGZyb20gJy4uL21vZGVsL01hZ25ldGljQ3VydmUnO1xuaW1wb3J0IEN1cnZlTWFuYWdlbWVudCBmcm9tICcuL0N1cnZlTWFuYWdlbWVudCc7XG5pbXBvcnQgKiBhcyBVSSBmcm9tICcuLi9tb2RlbC9VSU1hbmFnZW1lbnQnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExldmVsQ3VydmUge1xuXHQvKipcblx0XHRAcGFyYW0gbGV2ZWxQYXJhbSA6IGFycmF5XG5cdFx0bGVuZ3RoIDogbnVtYmVyXG5cdFx0YWxwaGEgOiBudW1iZXJcblx0XHRicmFuY2hlcyA6IG51bWJlclxuXHQqL1xuXHRjb25zdHJ1Y3RvcihiYXNlUGF0aCwgdHJ1bmtXaWR0aCwgbGV2ZWxQYXJhbSl7XG5cdFx0dGhpcy5iYXNlUGF0aCA9IGJhc2VQYXRoO1xuXHRcdHRoaXMudHJ1bmtXaWR0aCA9IHRydW5rV2lkdGg7XG5cdFx0dGhpcy5sZXZlbFBhcmFtID0gbGV2ZWxQYXJhbTtcblx0XHR0aGlzLmN1cnZlR3JvdXAgPSB1bmRlZmluZWQ7XG5cdH1cblx0ZHJhd0xldmVsQ3VydmUoYmV6aWVycywgbGV2ZWwpe1xuXHRcdGlmKCAhYmV6aWVycyApIHJldHVybjtcblx0XHRsZXQgc2lnbiA9IDE7XG5cblx0XHRsZXQgQnMgPSBiZXppZXJzLm1hcChiID0+e1xuXHRcdFx0cmV0dXJuIG5ldyBCZXppZXIoXG5cdFx0XHRcdGJbMF1bMF0sIGJbMF1bMV0sXG5cdFx0XHRcdGJbMV1bMF0sIGJbMV1bMV0sXG5cdFx0XHRcdGJbMl1bMF0sIGJbMl1bMV0sXG5cdFx0XHRcdGJbM11bMF0sIGJbM11bMV1cblx0XHRcdCk7XG5cdFx0fSk7XG5cblx0XHRsZXQgdG90YWxMZW5ndGggPSBCcy5yZWR1Y2UoIChsZW5ndGgsIEIpID0+e1xuXHRcdFx0cmV0dXJuIEIubGVuZ3RoKCkgKyBsZW5ndGg7XG5cdFx0fSwgMCk7XG5cblx0XHR0aGlzLmJyYW5jaFBvc2l0aW9uKGxldmVsKS5mb3JFYWNoKChpKSA9PiB7XG5cdFx0XHRpZiggdG90YWxMZW5ndGggPT09IDApIHJldHVybjtcblxuXHRcdFx0bGV0IGJlemllckluZGV4ID0gMDtcblxuXHRcdFx0bGV0IHBvcyA9IHRvdGFsTGVuZ3RoICogaTtcblx0XHRcdHdoaWxlKCBwb3MgPj0gQnNbYmV6aWVySW5kZXhdLmxlbmd0aCgpICkge1xuXHRcdFx0XHRwb3MgLT0gQnNbYmV6aWVySW5kZXhdLmxlbmd0aCgpO1xuXHRcdFx0XHRiZXppZXJJbmRleCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgcG9zT25TaW5nbGViZXppZXIgPSBwb3MgLyBCc1tiZXppZXJJbmRleF0ubGVuZ3RoKCk7XG5cblx0XHRcdHRoaXMuZHJhd0F0KHBvc09uU2luZ2xlYmV6aWVyLCBCc1tiZXppZXJJbmRleF0sIHNpZ24sIGxldmVsKTtcblxuXHRcdFx0c2lnbiAqPSAtMTtcblx0XHR9KTtcblx0fVxuXHRkcmF3QXQodCwgYiwgc2lnbiwgbGV2ZWwpe1xuXHRcdGxldCBzdGFydCA9IGIuZ2V0KHQpO1xuXHRcdGxldCB2ID0gYi5kZXJpdmF0aXZlKHQpO1xuXHRcdGxldCBtYWcgPSBuZXcgTWFnbmV0aWNDdXJ2ZSh7XG5cdFx0XHRzdGFydFg6IHN0YXJ0LngsXG5cdFx0XHRzdGFydFk6IHN0YXJ0LnksXG5cdFx0XHR2eDogdi54LFxuXHRcdFx0dnk6IHYueSxcblx0XHRcdFQ6IHRoaXMubGV2ZWxQYXJhbVtsZXZlbF0ubGVuZ3RoLFxuXHRcdFx0YWxwaGE6IHRoaXMubGV2ZWxQYXJhbVtsZXZlbF0uYWxwaGEsXG5cdFx0XHRzaWduOiBzaWduXG5cdFx0fSk7XG5cdFx0bWFnLmRyYXdPbih0aGlzLmN1cnZlR3JvdXApO1xuXHRcdGlmIChsZXZlbCA8IHRoaXMubGV2ZWxQYXJhbS5sZW5ndGgtMSApIHRoaXMuZHJhd0xldmVsQ3VydmUobWFnLnBvaW50cywgbGV2ZWwrMSk7XG5cdH1cblxuXHRkcmF3T24oIHBhbm5lbCApe1xuXHRcdHRoaXMucGFubmVsID0gcGFubmVsO1xuXHRcdHRoaXMuY3VydmVHcm91cCA9IHBhbm5lbC5ncm91cCgpO1xuXHRcdHBhbm5lbC5hZGQodGhpcy5jdXJ2ZUdyb3VwKTtcblx0XHRDdXJ2ZU1hbmFnZW1lbnRbdGhpcy5jdXJ2ZUdyb3VwLm5vZGUuaWRdID0gdGhpcztcblx0XHR0aGlzLmN1cnZlR3JvdXAub24oJ2NsaWNrJywgZSA9PiB7XG5cdFx0XHRjb25zb2xlLmxvZygnY2xlY2tlZCcpO1xuXG5cdFx0XHRsZXQgY3VydmVfaWQgPSBlLnRhcmdldC5wYXJlbnRFbGVtZW50LmlkO1xuXHRcdFx0bGV0IGx2Q3VydmUgPSBDdXJ2ZU1hbmFnZW1lbnRbIGN1cnZlX2lkIF07XG5cdFx0XHRDdXJ2ZU1hbmFnZW1lbnQuc2VsZWN0ZWRDdXJ2ZS5sZW5ndGggPSAwO1xuXHRcdFx0Q3VydmVNYW5hZ2VtZW50LnNlbGVjdGVkQ3VydmUucHVzaChsdkN1cnZlKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuZHJhd0xldmVsQ3VydmUodGhpcy5iYXNlUGF0aCwgMCk7XG5cdFx0dGhpcy5kcmF3U3RlbSggVUkuc3RhdGUudHJ1bmtXaWR0aCwgICk7XG5cdFx0dGhpcy5kcmF3U3RlbSggVUkuc3RhdGUudHJ1bmtXaWR0aC8zICk7XG5cdH1cblx0ZHJhd1N0ZW0od2lkdGgsIGNvbG9yKXtcblx0XHRcblx0XHRsZXQgYmFzZVBhdGggPSB0aGlzLmJhc2VQYXRoLm1hcChjID0+e1xuXHRcdFx0cmV0dXJuIG5ldyBCZXppZXIoXG5cdFx0XHRcdGNbMF1bMF0sIGNbMF1bMV0sXG5cdFx0XHRcdGNbMV1bMF0sIGNbMV1bMV0sXG5cdFx0XHRcdGNbMl1bMF0sIGNbMl1bMV0sXG5cdFx0XHRcdGNbM11bMF0sIGNbM11bMV1cblx0XHRcdCk7XG5cdFx0fSk7XG5cdFx0XG5cblx0XHRsZXQgdG90YWxMZW5ndGggPSBiYXNlUGF0aC5yZWR1Y2UoIChsZW5ndGgsIEIpID0+e1xuXHRcdFx0cmV0dXJuIEIubGVuZ3RoKCkgKyBsZW5ndGg7XG5cdFx0fSwgMCk7XG5cblx0XHRsZXQgbCA9IDA7XG5cdFx0bGV0IHcgPSB3aWR0aDtcblxuXHRcdGxldCBvdXRsaW5lID0gYmFzZVBhdGgubWFwKGIgPT4ge1xuXHRcdFx0bGV0IGQxID0gdyAqIGwgLyB0b3RhbExlbmd0aDtcblx0XHRcdGwgKz0gYi5sZW5ndGgoKTtcblx0XHRcdGxldCBkMiA9IHcgKiBsIC8gdG90YWxMZW5ndGg7XG5cdFx0XHRpZihkMSA9PT0gMCkgZDEgPSAxO1xuXHRcdFx0cmV0dXJuIGIub3V0bGluZShkMSwgZDEsIGQyLCBkMik7XG5cdFx0fSk7XG5cdFx0b3V0bGluZS5mb3JFYWNoKGIgPT4ge1xuXHRcdFx0bGV0IHBhdGhTdHJpbmcgPSBmaXR0ZWRDdXJ2ZVRvUGF0aFN0cmluZyhiKTtcblx0XHRcdGRyYXdPblBhbm5lbCggdGhpcy5jdXJ2ZUdyb3VwLCBwYXRoU3RyaW5nLCBjb2xvciApO1xuXHRcdH0pO1xuXHRcdFxuXHR9XG5cdHJlZHJhdygpIHtcblx0XHRpZiggdGhpcy5wYW5uZWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ2NhbiBub3QgcmVkcmF3IScpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLmN1cnZlR3JvdXAucmVtb3ZlKCk7XG5cdFx0dGhpcy5kcmF3T24odGhpcy5wYW5uZWwpO1xuXHR9XG5cblx0YnJhbmNoUG9zaXRpb24obGV2ZWwpe1xuXHRcdGxldCBicmFuY2hlcyA9IFtdO1xuXHRcdGxldCBicmFuY2ggPSB0aGlzLmxldmVsUGFyYW1bbGV2ZWxdLmJyYW5jaGVzO1xuXG5cdFx0bGV0IHBvcyA9IDEgLyAoYnJhbmNoICsgMSk7XG5cdFx0Zm9yIChsZXQgaSA9IDE7IGkgPD0gYnJhbmNoOyBpKyspIHtcblx0XHRcdGJyYW5jaGVzLnB1c2gocG9zICogaSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGJyYW5jaGVzO1xuXHR9XG59XG5mdW5jdGlvbiBmaXR0ZWRDdXJ2ZVRvUGF0aFN0cmluZyhmaXR0ZWRMaW5lRGF0YSkge1xuXHR2YXIgc3RyID0gJyc7XG5cdC8vYmV6aWVyIDogWyBbYzBdLCBbYzFdLCBbYzJdLCBbYzNdIF1cblx0Zml0dGVkTGluZURhdGEuY3VydmVzLm1hcChmdW5jdGlvbiAoYmV6aWVyLCBpKSB7XG5cdFx0aWYgKGkgPT0gMCkge1xuXHRcdFx0c3RyICs9ICdNICcgKyBiZXppZXIucG9pbnRzWzBdLnggKyAnICcgKyBiZXppZXIucG9pbnRzWzBdLnk7XG5cdFx0fVxuXG5cdFx0c3RyICs9ICdDICcgKyBiZXppZXIucG9pbnRzWzFdLnggKyAnICcgKyBiZXppZXIucG9pbnRzWzFdLnkgKyAnLCAnICtcblx0XHRiZXppZXIucG9pbnRzWzJdLnggKyAnICcgKyBiZXppZXIucG9pbnRzWzJdLnkgKyAnLCAnICtcblx0XHRiZXppZXIucG9pbnRzWzNdLnggKyAnICcgKyBiZXppZXIucG9pbnRzWzNdLnkgKyAnICc7XHRcblx0XHRcdFx0XHRcblx0fSk7XG5cblx0cmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIGRyYXdPblBhbm5lbChwYW5uZWwsIHBhdGhTdHJpbmcsIGNvbG9yKXtcblx0cGFubmVsLnBhdGgoIHBhdGhTdHJpbmcgKS5maWxsKGNvbG9yKS5zdHJva2UoeyB3aWR0aDogMCB9KTtcbn1cbiIsImltcG9ydCBmaXRDdXJ2ZSBmcm9tICdmaXQtY3VydmUnO1xuXG5jb25zdCBlcnJvciA9IDE7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFnbmV0aWNDdXJ2ZSB7XG5cdGNvbnN0cnVjdG9yKHBhcmFtKSB7XG5cdFx0Lypcblx0XHRzdGFydFgsIHN0YXJ0WSA6IOWIneWni+m7nlxuXHRcdHZ4LCB2eSA6IOWIneWni+mAn+W6plxuXHRcdFQgOiDnuL3pu57mlbhcblx0XHRhbHBoYSA6IOetieinkuieuue3muWPg+aVuFxuXHRcdHNpZ24gOiDpm7vojbfmraPosqBcblx0XHQqL1xuXHRcdHRoaXMucGFyYW0gPSBwYXJhbTtcblx0fVxuXG5cdG1ha2VDdXJ2ZSgpIHtcblx0XHRjb25zdCBwb2ludHMgPSBbXTtcblx0XHRcblx0XHRsZXQgc2lnbiA9IHRoaXMucGFyYW0uc2lnbiB8fCAxO1xuXHRcdGxldCB4ID0gdGhpcy5wYXJhbS5zdGFydFg7XG5cdFx0bGV0IHkgPSB0aGlzLnBhcmFtLnN0YXJ0WTtcblxuXHRcdGxldCBbdngsIHZ5XSA9IG5vcm1hbGl6ZSggW3RoaXMucGFyYW0udngsIHRoaXMucGFyYW0udnldICk7XG5cblx0XHRsZXQgVCA9IHRoaXMucGFyYW0uVDtcblx0XHRsZXQgdCA9IDA7XG5cdFx0bGV0IGR0ID0gMTtcblxuXHRcdHdoaWxlKCB0IDwgVCApIHtcblx0XHRcdHBvaW50cy5wdXNoKCBbeCwgeV0gKTtcblx0XHRcdGxldCBxID0gc2lnbiAqIE1hdGgucG93KCAoVC10KSwgLTEgKiB0aGlzLnBhcmFtLmFscGhhICk7XG5cdFx0XHR4ICs9IHZ4ICogZHQ7XG5cdFx0XHR5ICs9IHZ5ICogZHQ7XG5cblx0XHRcdGxldCBheCA9IC0xICogdnkgKiBxO1xuXHRcdFx0bGV0IGF5ID0gdnggKiBxO1xuXG5cdFx0XHR2eCArPSBheCAqIGR0O1xuXHRcdFx0dnkgKz0gYXkgKiBkdDtcblxuXHRcdFx0dCArPSBkdDtcblx0XHR9XG5cblx0XHRyZXR1cm4gcG9pbnRzO1xuXHR9XG5cblx0ZHJhd09uKHBhbm5lbCl7XG5cdFx0bGV0IG1hZyA9IHRoaXMubWFrZUN1cnZlKCk7XG5cdFx0bGV0IHNtb290aEJpemVyID0gZml0Q3VydmUoIG1hZywgZXJyb3IgKTtcblx0XHR0aGlzLnBvaW50cyA9IHNtb290aEJpemVyO1xuXG5cdFx0bGV0IHBhdGhTdHJpbmcgPSBmaXR0ZWRDdXJ2ZVRvUGF0aFN0cmluZyhzbW9vdGhCaXplcik7XG5cblx0XHRwYW5uZWwucGF0aChwYXRoU3RyaW5nKS5maWxsKCdub25lJykuc3Ryb2tlKHsgd2lkdGg6IDMgfSkuc3Ryb2tlKCcjZjAwJyk7XG5cdFx0XG5cdH1cbn1cbmZ1bmN0aW9uIGZpdHRlZEN1cnZlVG9QYXRoU3RyaW5nKGZpdHRlZExpbmVEYXRhKSB7XG5cdHZhciBzdHIgPSAnJztcblx0Ly9iZXppZXIgOiBbIFtjMF0sIFtjMV0sIFtjMl0sIFtjM10gXVxuXHRmaXR0ZWRMaW5lRGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChiZXppZXIsIGkpIHtcblx0XHRpZiAoaSA9PSAwKSB7XG5cdFx0XHRzdHIgKz0gJ00gJyArIGJlemllclswXVswXSArICcgJyArIGJlemllclswXVsxXTtcblx0XHR9XG5cblx0XHRzdHIgKz0gJ0MgJyArIGJlemllclsxXVswXSArICcgJyArIGJlemllclsxXVsxXSArICcsICcgK1xuXHRcdGJlemllclsyXVswXSArICcgJyArIGJlemllclsyXVsxXSArICcsICcgK1xuXHRcdGJlemllclszXVswXSArICcgJyArIGJlemllclszXVsxXSArICcgJztcdFxuXHRcdFx0XHRcdFxuXHR9KTtcblxuXHRyZXR1cm4gc3RyO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemUodmVjdG9yKSB7XG5cdGxldCB4ID0gdmVjdG9yWzBdO1xuXHRsZXQgeSA9IHZlY3RvclsxXTtcblx0bGV0IGxlbmd0aCA9IE1hdGguc3FydChcblx0XHRNYXRoLnBvdyh4LCAyKSArIE1hdGgucG93KHksIDIpXG5cdCk7XG5cblx0cmV0dXJuIFt4L2xlbmd0aCwgeS9sZW5ndGhdO1xufSIsImltcG9ydCAqIGFzIGRhdCBmcm9tICcuLi9saWIvZGF0Lmd1aSc7XG5pbXBvcnQgZG93bmxvYWQgZnJvbSAnLi4vbGliL2Rvd25sb2FkJztcbmltcG9ydCBDdXJ2ZU1hbmFnZW1lbnQgZnJvbSAnLi9DdXJ2ZU1hbmFnZW1lbnQnO1xuXG5sZXQgZ3VpLCBmb2xkZXJzID0gW107XG5sZXQgY29udHJvbHMgPSBbXTtcbmV4cG9ydCBsZXQgc3RhdGUgPSB7XG5cdHRydW5rV2lkdGg6IDE1LFxuXHRpbnRlcnNlY3Q6IGZhbHNlLFxuXHRsZXZlbEN1cnZlIDpbXG5cdFx0e1xuXHRcdFx0bGVuZ3RoOiAxMDAsXG5cdFx0XHRhbHBoYTogMC45LFxuXHRcdFx0YnJhbmNoZXM6IDVcblx0XHR9LFxuXHRcdHtcblx0XHRcdGxlbmd0aDogMjAsXG5cdFx0XHRhbHBoYTogMC44LFxuXHRcdFx0YnJhbmNoZXM6IDVcblx0XHR9XG5cdF1cbn07XG5cbmxldCBmZWF0dXJlcyA9IHtcblx0ZG93bmxvYWQgOiBmdW5jdGlvbigpe1xuXHRcdGxldCBzdmcgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3ZnJylbMF07XG5cdFx0ZG93bmxvYWQoc3ZnLm91dGVySFRNTCwgJ2ZpbGUuc3ZnJywgJ3RleHQvcGxhaW4nKTtcblx0fVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHNldEdVSSgpe1xuXHRndWkgPSBuZXcgZGF0LkdVSSgpO1xuXG5cdGxldCBjID0gZ3VpLmFkZChzdGF0ZSwgJ3RydW5rV2lkdGgnLCAxLCAyMCk7XG5cdGNvbnRyb2xzLnB1c2goYyk7XG5cdC8vZ3VpLmFkZChzdGF0ZSwgJ2ludGVyc2VjdCcpO1xuXG5cdGxldmVsRm9sZGVyKDApO1xuXHRsZXZlbEZvbGRlcigxKTtcblx0c2V0T25DaGFuZ2UoY29udHJvbHMpO1xuXG5cdGd1aS5hZGQoZmVhdHVyZXMsICdkb3dubG9hZCcpO1xuXG59XG5cbmZ1bmN0aW9uIGxldmVsRm9sZGVyKGluZGV4KXtcblx0bGV0IGZvbGRlciA9IGd1aS5hZGRGb2xkZXIoYExldmVsICR7aW5kZXh9YCk7XG5cdGNvbnRyb2xzLnB1c2goIGZvbGRlci5hZGQoc3RhdGUubGV2ZWxDdXJ2ZVtpbmRleF0sICdsZW5ndGgnKSApO1xuXHRjb250cm9scy5wdXNoKCBmb2xkZXIuYWRkKHN0YXRlLmxldmVsQ3VydmVbaW5kZXhdLCAnYWxwaGEnKSApO1xuXHRjb250cm9scy5wdXNoKCBmb2xkZXIuYWRkKHN0YXRlLmxldmVsQ3VydmVbaW5kZXhdLCAnYnJhbmNoZXMnKS5zdGVwKDEpICk7XG5cdGZvbGRlcnMucHVzaChmb2xkZXIpO1xufVxuXG5mdW5jdGlvbiBzZXRPbkNoYW5nZShjb250cm9scyl7XG5cdGNvbnRyb2xzLmZvckVhY2goIGMgPT4ge1xuXHRcdGMub25DaGFuZ2UoICgpID0+IHtcblx0XHRcdGlmKCBDdXJ2ZU1hbmFnZW1lbnQuc2VsZWN0ZWRDdXJ2ZS5sZW5ndGggPT09IDEgKXtcblx0XHRcdFx0Q3VydmVNYW5hZ2VtZW50LnNlbGVjdGVkQ3VydmVbMF0ucmVkcmF3KCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufSJdfQ==
